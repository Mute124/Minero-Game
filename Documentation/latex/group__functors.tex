\doxysubsection{Function Objects}
\hypertarget{group__functors}{}\label{group__functors}\index{Function Objects@{Function Objects}}
Collaboration diagram for Function Objects\+:
% FIG 0
\doxysubsubsubsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__binders}{Binder Classes}}
\item 
\mbox{\hyperlink{group__hashes}{Hashes}}
\item 
\mbox{\hyperlink{group__arithmetic__functors}{Arithmetic Function Object Classes}}
\end{DoxyCompactItemize}
\doxysubsubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
namespace std \mbox{\hyperlink{group__functors_ga544d74b2d5d0dd2197f5fd6f02691de0}{\+\_\+\+GLIBCXX\+\_\+\+VISIBILITY}} (default)
\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Function objects, or {\itshape functors}, are objects with an {\ttfamily operator()} defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to {\itshape functors}, then, generally we include function pointers in the description as well.

Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.

Two examples taken from the standard itself follow. To perform a by-\/element addition of two vectors {\ttfamily a} and {\ttfamily b} containing {\ttfamily double}, and put the result in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}\ (\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_a6eba317e3cf44d6d26c04a5a8f197dcb}{b}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ plus<double>());}

\end{DoxyCode}
 To negate every element in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}(\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ negate<double>());}

\end{DoxyCode}
 The addition and negation functions will usually be inlined directly.

An {\itshape adaptable function object} is one which provides nested typedefs {\ttfamily result\+\_\+type} and either {\ttfamily argument\+\_\+type} (for a unary function) or {\ttfamily first\+\_\+argument\+\_\+type} and {\ttfamily second\+\_\+argument\+\_\+type} (for a binary function). Those typedefs are used by function object adaptors such as {\ttfamily bind2nd}. The standard library provides two class templates, {\ttfamily unary\+\_\+function} and {\ttfamily binary\+\_\+function}, which define those typedefs and so can be used as base classes of adaptable function objects.

Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, {\ttfamily function\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}}, and more powerful type deduction (using {\ttfamily auto} and {\ttfamily decltype}). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.

Function objects, or {\itshape functors}, are objects with an {\ttfamily operator()} defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to {\itshape functors}, then, generally we include function pointers in the description as well.

Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.

Two examples taken from the standard itself follow. To perform a by-\/element addition of two vectors {\ttfamily a} and {\ttfamily b} containing {\ttfamily double}, and put the result in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}\ (\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_a6eba317e3cf44d6d26c04a5a8f197dcb}{b}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ plus<double>());}

\end{DoxyCode}
 To negate every element in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}(\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ negate<double>());}

\end{DoxyCode}
 The addition and negation functions will usually be inlined directly.

An {\itshape adaptable function object} is one which provides nested typedefs {\ttfamily result\+\_\+type} and either {\ttfamily argument\+\_\+type} (for a unary function) or {\ttfamily first\+\_\+argument\+\_\+type} and {\ttfamily second\+\_\+argument\+\_\+type} (for a binary function). Those typedefs are used by function object adaptors such as {\ttfamily bind2nd}. The standard library provides two class templates, {\ttfamily unary\+\_\+function} and {\ttfamily binary\+\_\+function}, which define those typedefs and so can be used as base classes of adaptable function objects.

Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, {\ttfamily function\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}}, and more powerful type deduction (using {\ttfamily auto} and {\ttfamily decltype}). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.

Function objects, or {\itshape functors}, are objects with an {\ttfamily operator()} defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to {\itshape functors}, then, generally we include function pointers in the description as well.

Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.

Two examples taken from the standard itself follow. To perform a by-\/element addition of two vectors {\ttfamily a} and {\ttfamily b} containing {\ttfamily double}, and put the result in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}\ (\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_a6eba317e3cf44d6d26c04a5a8f197dcb}{b}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ plus<double>());}

\end{DoxyCode}
 To negate every element in {\ttfamily a}, use 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacestd_a83797c5677d80005911de218c819adab}{transform}}(\mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.end(),\ \mbox{\hyperlink{_classes_2lib_2raylib_2src_2external_2glad_8h_ac8729153468b5dcf13f971b21d84d4e5}{a}}.begin(),\ negate<double>());}

\end{DoxyCode}
 The addition and negation functions will usually be inlined directly.

An {\itshape adaptable function object} is one which provides nested typedefs {\ttfamily result\+\_\+type} and either {\ttfamily argument\+\_\+type} (for a unary function) or {\ttfamily first\+\_\+argument\+\_\+type} and {\ttfamily second\+\_\+argument\+\_\+type} (for a binary function). Those typedefs are used by function object adaptors such as {\ttfamily bind2nd}. The standard library provides two class templates, {\ttfamily unary\+\_\+function} and {\ttfamily binary\+\_\+function}, which define those typedefs and so can be used as base classes of adaptable function objects.

Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, {\ttfamily function\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}}, and more powerful type deduction (using {\ttfamily auto} and {\ttfamily decltype}). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.

\doxysubsubsection{Function Documentation}
\Hypertarget{group__functors_ga544d74b2d5d0dd2197f5fd6f02691de0}\label{group__functors_ga544d74b2d5d0dd2197f5fd6f02691de0} 
\index{Function Objects@{Function Objects}!\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}}
\index{\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}!Function Objects@{Function Objects}}
\doxysubsubsubsection{\texorpdfstring{\_GLIBCXX\_VISIBILITY()}{\_GLIBCXX\_VISIBILITY()}}
{\footnotesize\ttfamily namespace std \+\_\+\+GLIBCXX\+\_\+\+VISIBILITY (\begin{DoxyParamCaption}\item[{default}]{ }\end{DoxyParamCaption})}

Polymorphic function wrapper.

\begin{DoxySince}{Since}
C++23
\end{DoxySince}
The {\ttfamily std\+::move\+\_\+only\+\_\+function} class template is a call wrapper similar to \texorpdfstring{$\ast$}{*} {\ttfamily std\+::function}, but does not require the stored target function to be copyable.

It also supports const-\/qualification, ref-\/qualification, and no-\/throw guarantees. The qualifications and exception-\/specification of the {\ttfamily move\+\_\+only\+\_\+function\+::operator()} member function are respected when invoking the target function.

Creates an empty object.

Creates an empty object.

Moves the target object, leaving the source empty.

Stores a target object initialized from the argument.

Stores a target object initialized from the arguments.

Stores a target object initialized from the arguments.

Stores a new target object, leaving {\ttfamily x} empty.

Destroys the target object (if any).

Stores a new target object, initialized from the argument.

True if a target object is present, false otherwise.

Invoke the target object.

The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-\/const, as dictated by the template arguments of the {\ttfamily move\+\_\+only\+\_\+function} specialization.

\begin{DoxyPrecond}{Precondition}
Must not be empty.
\end{DoxyPrecond}
Exchange the target objects (if any).

Exchange the target objects (if any).

Check for emptiness by comparing with {\ttfamily nullptr}.

Polymorphic function wrapper.

\begin{DoxySince}{Since}
C++23
\end{DoxySince}
The {\ttfamily std\+::move\+\_\+only\+\_\+function} class template is a call wrapper similar to \texorpdfstring{$\ast$}{*} {\ttfamily std\+::function}, but does not require the stored target function to be copyable.

It also supports const-\/qualification, ref-\/qualification, and no-\/throw guarantees. The qualifications and exception-\/specification of the {\ttfamily move\+\_\+only\+\_\+function\+::operator()} member function are respected when invoking the target function.

Creates an empty object.

Creates an empty object.

Moves the target object, leaving the source empty.

Stores a target object initialized from the argument.

Stores a target object initialized from the arguments.

Stores a target object initialized from the arguments.

Stores a new target object, leaving {\ttfamily x} empty.

Destroys the target object (if any).

Stores a new target object, initialized from the argument.

True if a target object is present, false otherwise.

Invoke the target object.

The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-\/const, as dictated by the template arguments of the {\ttfamily move\+\_\+only\+\_\+function} specialization.

\begin{DoxyPrecond}{Precondition}
Must not be empty.
\end{DoxyPrecond}
Exchange the target objects (if any).

Exchange the target objects (if any).

Check for emptiness by comparing with {\ttfamily nullptr}.

Polymorphic function wrapper.

\begin{DoxySince}{Since}
C++23
\end{DoxySince}
The {\ttfamily std\+::move\+\_\+only\+\_\+function} class template is a call wrapper similar to \texorpdfstring{$\ast$}{*} {\ttfamily std\+::function}, but does not require the stored target function to be copyable.

It also supports const-\/qualification, ref-\/qualification, and no-\/throw guarantees. The qualifications and exception-\/specification of the {\ttfamily move\+\_\+only\+\_\+function\+::operator()} member function are respected when invoking the target function.

Creates an empty object.

Creates an empty object.

Moves the target object, leaving the source empty.

Stores a target object initialized from the argument.

Stores a target object initialized from the arguments.

Stores a target object initialized from the arguments.

Stores a new target object, leaving {\ttfamily x} empty.

Destroys the target object (if any).

Stores a new target object, initialized from the argument.

True if a target object is present, false otherwise.

Invoke the target object.

The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-\/const, as dictated by the template arguments of the {\ttfamily move\+\_\+only\+\_\+function} specialization.

\begin{DoxyPrecond}{Precondition}
Must not be empty.
\end{DoxyPrecond}
Exchange the target objects (if any).

Exchange the target objects (if any).

Check for emptiness by comparing with {\ttfamily nullptr}.Here is the call graph for this function\+:
% FIG 1
\input{group__binders}
\input{group__hashes}
\input{group__arithmetic__functors}
