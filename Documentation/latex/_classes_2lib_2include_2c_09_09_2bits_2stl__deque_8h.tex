\doxysection{C\+:/\+Users/\+HP/\+Documents/\+Git\+Hub/\+Minero-\/\+Game/\+Classes/lib/include/c++/bits/stl\+\_\+deque.h File Reference}
\hypertarget{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h}{}\label{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h}\index{C:/Users/HP/Documents/GitHub/Minero-\/Game/Classes/lib/include/c++/bits/stl\_deque.h@{C:/Users/HP/Documents/GitHub/Minero-\/Game/Classes/lib/include/c++/bits/stl\_deque.h}}
{\ttfamily \#include $<$bits/concept\+\_\+check.\+h$>$}\newline
{\ttfamily \#include $<$bits/stl\+\_\+iterator\+\_\+base\+\_\+types.\+h$>$}\newline
{\ttfamily \#include $<$bits/stl\+\_\+iterator\+\_\+base\+\_\+funcs.\+h$>$}\newline
{\ttfamily \#include $<$debug/assertions.\+h$>$}\newline
Include dependency graph for stl\+\_\+deque.\+h\+:
% FIG 0
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#\mbox{\hyperlink{_classes_2lib_2include_2avx512fintrin_8h_a1b7950c88593de42a92cc8558f5488f6}{define}} \mbox{\hyperlink{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a87949eb8a238d15bbc7d30d84cd3b8cf}{\+\_\+\+GLIBCXX\+\_\+\+DEQUE\+\_\+\+BUF\+\_\+\+SIZE}}~512
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
namespace std \mbox{\hyperlink{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a544d74b2d5d0dd2197f5fd6f02691de0}{\+\_\+\+GLIBCXX\+\_\+\+VISIBILITY}} (default)
\end{DoxyCompactItemize}



\doxysubsection{Macro Definition Documentation}
\Hypertarget{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a87949eb8a238d15bbc7d30d84cd3b8cf}\label{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a87949eb8a238d15bbc7d30d84cd3b8cf} 
\index{stl\_deque.h@{stl\_deque.h}!\_GLIBCXX\_DEQUE\_BUF\_SIZE@{\_GLIBCXX\_DEQUE\_BUF\_SIZE}}
\index{\_GLIBCXX\_DEQUE\_BUF\_SIZE@{\_GLIBCXX\_DEQUE\_BUF\_SIZE}!stl\_deque.h@{stl\_deque.h}}
\doxysubsubsection{\texorpdfstring{\_GLIBCXX\_DEQUE\_BUF\_SIZE}{\_GLIBCXX\_DEQUE\_BUF\_SIZE}}
{\footnotesize\ttfamily \#\mbox{\hyperlink{_classes_2lib_2include_2avx512fintrin_8h_a1b7950c88593de42a92cc8558f5488f6}{define}} \+\_\+\+GLIBCXX\+\_\+\+DEQUE\+\_\+\+BUF\+\_\+\+SIZE~512}



\doxysubsection{Function Documentation}
\Hypertarget{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a544d74b2d5d0dd2197f5fd6f02691de0}\label{_classes_2lib_2include_2c_09_09_2bits_2stl__deque_8h_a544d74b2d5d0dd2197f5fd6f02691de0} 
\index{stl\_deque.h@{stl\_deque.h}!\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}}
\index{\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}!stl\_deque.h@{stl\_deque.h}}
\doxysubsubsection{\texorpdfstring{\_GLIBCXX\_VISIBILITY()}{\_GLIBCXX\_VISIBILITY()}}
{\footnotesize\ttfamily namespace std \+\_\+\+GLIBCXX\+\_\+\+VISIBILITY (\begin{DoxyParamCaption}\item[{default}]{ }\end{DoxyParamCaption})}

This function controls the size of memory nodes. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+size} & The size of an element. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number (not byte size) of elements per node.
\end{DoxyReturn}
This function started off as a compiler kludge from SGI, but seems to be a useful wrapper around a repeated constant expression. The {\bfseries{512}} is tunable (and no other code needs to change), but no investigation has been done since inheriting the SGI code. Touch \+\_\+\+GLIBCXX\+\_\+\+DEQUE\+\_\+\+BUF\+\_\+\+SIZE only if you know what you are doing, however\+: changing it breaks the binary compatibility!!

A deque\+::iterator.

Quite a bit of intelligence here. Much of the functionality of deque is actually passed off to this class. A deque holds two of these internally, marking its valid range. Access to elements is done as offsets of either of those two, relying on operator overloading in this class.

All the functions are op overloads except for \+\_\+\+M\+\_\+set\+\_\+node.

Prepares to traverse new\+\_\+node. Sets everything except \+\_\+\+M\+\_\+cur, which should therefore be set by the caller immediately afterwards, based on \+\_\+\+M\+\_\+first and \+\_\+\+M\+\_\+last.

Deque base class. This class provides the unified face for deque\textquotesingle{}s allocation. This class\textquotesingle{}s constructor and destructor allocate and deallocate (but do not initialize) storage. This makes exception safety easier.

Nothing in this class ever constructs or destroys an actual Tp element. (Deque handles that itself.) Only/\+All memory management is performed here.

Layout storage. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+num\+\_\+elements} & The count of T\textquotesingle{}s for which to allocate space at first. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
The initial underlying memory layout is a bit complicated...

A standard container using fixed-\/size memory allocation and constant-\/time manipulation of elements at either end.


\begin{DoxyTemplParams}{Template Parameters}
{\em \+\_\+\+Tp} & Type of element. \\
\hline
{\em \+\_\+\+Alloc} & Allocator type, defaults to allocator$<$\+\_\+\+Tp$>$.\\
\hline
\end{DoxyTemplParams}
Meets the requirements of a \href{tables.html\#65}{\texttt{ container}}, a \href{tables.html\#66}{\texttt{ reversible container}}, and a \href{tables.html\#67}{\texttt{ sequence}}, including the \href{tables.html\#68}{\texttt{ optional sequence requirements}}.

In previous HP/\+SGI versions of deque, there was an extra template parameter so users could control the node size. This extension turned out to violate the C++ standard (it can be detected using template template parameters), and it was removed.

Here\textquotesingle{}s how a deque$<$\+Tp$>$ manages memory. Each deque has 4 members\+:


\begin{DoxyItemize}
\item Tp\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \+\_\+\+M\+\_\+map
\item size\+\_\+t \+\_\+\+M\+\_\+map\+\_\+size
\item iterator \+\_\+\+M\+\_\+start, \+\_\+\+M\+\_\+finish
\end{DoxyItemize}

map\+\_\+size is at least 8. map is an array of map\+\_\+size pointers-\/to-\/{\itshape nodes}. (The name map has nothing to do with the std\+::map class, and {\bfseries{nodes}} should not be confused with std\+::list\textquotesingle{}s usage of {\itshape node}.)

A {\itshape node} has no specific type name as such, but it is referred to as {\itshape node} in this file. It is a simple array-\/of-\/\+Tp. If Tp is very large, there will be one Tp element per node (i.\+e., an {\itshape array} of one). For non-\/huge Tp\textquotesingle{}s, node size is inversely related to Tp size\+: the larger the Tp, the fewer Tp\textquotesingle{}s will fit in a node. The goal here is to keep the total size of a node relatively small and constant over different Tp\textquotesingle{}s, to improve allocator efficiency.

Not every pointer in the map array will point to a node. If the initial number of elements in the deque is small, the /middle/ map pointers will be valid, and the ones at the edges will be unused. This same situation will arise as the map grows\+: available map pointers, if any, will be on the ends. As new nodes are created, only a subset of the map\textquotesingle{}s pointers need to be copied {\itshape outward}.

Class invariants\+:
\begin{DoxyItemize}
\item For any nonsingular iterator i\+:
\begin{DoxyItemize}
\item i.\+node points to a member of the map array. (Yes, you read that correctly\+: i.\+node does not actually point to a node.) The member of the map array is what actually points to the node.
\item i.\+first == \texorpdfstring{$\ast$}{*}(i.\+node) (This points to the node (first Tp element).)
\item i.\+last == i.\+first + node\+\_\+size
\item i.\+cur is a pointer in the range \mbox{[}i.\+first, i.\+last). NOTE\+: the implication of this is that i.\+cur is always a dereferenceable pointer, even if i is a past-\/the-\/end iterator.
\end{DoxyItemize}
\item Start and Finish are always nonsingular iterators. NOTE\+: this means that an empty deque must have one node, a deque with \texorpdfstring{$<$}{<}N elements (where N is the node buffer size) must have one node, a deque with N through (2N-\/1) elements must have two nodes, etc.
\item For every node other than start.\+node and finish.\+node, every element in the node is an initialized object. If start.\+node == finish.\+node, then \mbox{[}start.\+cur, finish.\+cur) are initialized objects, and the elements outside that range are uninitialized storage. Otherwise, \mbox{[}start.\+cur, start.\+last) and \mbox{[}finish.\+first, finish.\+cur) are initialized objects, and \mbox{[}start.\+first, start.\+cur) and \mbox{[}finish.\+cur, finish.\+last) are uninitialized storage.
\item \mbox{[}map, map + map\+\_\+size) is a valid, non-\/empty range.
\item \mbox{[}start.\+node, finish.\+node\mbox{]} is a valid range contained within \mbox{[}map, map + map\+\_\+size).
\item A pointer in the range \mbox{[}map, map + map\+\_\+size) points to an allocated node if and only if the pointer is in the range \mbox{[}start.\+node, finish.\+node\mbox{]}.

Here\textquotesingle{}s the magic\+: nothing in deque is {\bfseries{aware}} of the discontiguous storage!

The memory setup and layout occurs in the parent, \+\_\+\+Base, and the iterator class is entirely responsible for {\itshape leaping} from one node to the next. All the implementation routines for deque itself work only through the start and finish iterators. This keeps the routines simple and sane, and we can use other standard algorithms as well.
\end{DoxyItemize}

A total of four data members accumulated down the hierarchy. May be accessed via \+\_\+\+M\+\_\+impl.\texorpdfstring{$\ast$}{*}

Creates a deque with no elements.

Creates a deque with no elements. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+a} & An allocator object.\\
\hline
\end{DoxyParams}
Creates a deque with copies of an exemplar element. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & The number of elements to initially create. \\
\hline
{\em \+\_\+\+\_\+value} & An element to copy. \\
\hline
{\em \+\_\+\+\_\+a} & An allocator.\\
\hline
\end{DoxyParams}
This constructor fills the deque with {\itshape \+\_\+\+\_\+n} copies of {\itshape \+\_\+\+\_\+value}.

Deque copy constructor. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+x} & A deque of identical element and allocator types.\\
\hline
\end{DoxyParams}
The newly-\/created deque uses a copy of the allocator object used by {\itshape \+\_\+\+\_\+x} (unless the allocator traits dictate a different object).

Builds a deque from a range. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+first} & An input iterator. \\
\hline
{\em \+\_\+\+\_\+last} & An input iterator. \\
\hline
{\em \+\_\+\+\_\+a} & An allocator object.\\
\hline
\end{DoxyParams}
Create a deque consisting of copies of the elements from \mbox{[}\+\_\+\+\_\+first, \+\_\+\+\_\+last).

If the iterators are forward, bidirectional, or random-\/access, then this will call the elements\textquotesingle{} copy constructor N times (where N is distance(\+\_\+\+\_\+first,\+\_\+\+\_\+last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations.

The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-\/to memory is not touched in any way. Managing the pointer is the user\textquotesingle{}s responsibility.

Deque assignment operator. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+x} & A deque of identical element and allocator types.\\
\hline
\end{DoxyParams}
All the elements of {\itshape x} are copied.

The newly-\/created deque uses a copy of the allocator object used by {\itshape \+\_\+\+\_\+x} (unless the allocator traits dictate a different object).

Assigns a given value to a deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & Number of elements to be assigned. \\
\hline
{\em \+\_\+\+\_\+val} & Value to be assigned.\\
\hline
\end{DoxyParams}
This function fills a deque with {\itshape n} copies of the given value. Note that the assignment completely changes the deque and that the resulting deque\textquotesingle{}s size is the same as the number of elements assigned.

Assigns a range to a deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+first} & An input iterator. \\
\hline
{\em \+\_\+\+\_\+last} & An input iterator.\\
\hline
\end{DoxyParams}
This function fills a deque with copies of the elements in the range \mbox{[}\+\_\+\+\_\+first,\+\_\+\+\_\+last).

Note that the assignment completely changes the deque and that the resulting deque\textquotesingle{}s size is the same as the number of elements assigned.

Get a copy of the memory allocation object.

Returns a read/write iterator that points to the first element in the deque. Iteration is done in ordinary element order.

Returns a read-\/only (constant) iterator that points to the first element in the deque. Iteration is done in ordinary element order.

Returns a read/write iterator that points one past the last element in the deque. Iteration is done in ordinary element order.

Returns a read-\/only (constant) iterator that points one past the last element in the deque. Iteration is done in ordinary element order.

Returns a read/write reverse iterator that points to the last element in the deque. Iteration is done in reverse element order.

Returns a read-\/only (constant) reverse iterator that points to the last element in the deque. Iteration is done in reverse element order.

Returns a read/write reverse iterator that points to one before the first element in the deque. Iteration is done in reverse element order.

Returns a read-\/only (constant) reverse iterator that points to one before the first element in the deque. Iteration is done in reverse element order.

Returns the number of elements in the deque. ~\newline


Returns the \doxylink{_classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_a3d1e3edfcf61ca2d831883e1afbad89e}{size()} of the largest possible deque. ~\newline


Resizes the deque to the specified number of elements. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+new\+\_\+size} & Number of elements the deque should contain. \\
\hline
{\em \+\_\+\+\_\+x} & Data with which new elements should be populated.\\
\hline
\end{DoxyParams}
This function will resize the deque to the specified number of elements. If the number is smaller than the deque\textquotesingle{}s current size the deque is truncated, otherwise the deque is extended and new elements are populated with given data.

Returns true if the deque is empty. (Thus begin() would equal \doxylink{_classes_2lib_2raylib_2src_2external_2glad_8h_a432111147038972f06e049e18a837002}{end()}.)

Subscript access to the data contained in the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & The index of the element for which data should be accessed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Read/write reference to data.
\end{DoxyReturn}
This operator allows for easy, array-\/style, data access. Note that data access with this operator is unchecked and out\+\_\+of\+\_\+range lookups are not defined. (For checked lookups see at().)

Subscript access to the data contained in the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & The index of the element for which data should be accessed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Read-\/only (constant) reference to data.
\end{DoxyReturn}
This operator allows for easy, array-\/style, data access. Note that data access with this operator is unchecked and out\+\_\+of\+\_\+range lookups are not defined. (For checked lookups see at().)

Safety check used only from at().

Provides access to the data contained in the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & The index of the element for which data should be accessed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Read/write reference to data. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & If {\itshape \+\_\+\+\_\+n} is an invalid index.\\
\hline
\end{DoxyExceptions}
This function provides for safer data access. The parameter is first checked that it is in the range of the deque. The function throws out\+\_\+of\+\_\+range if the check fails.

Provides access to the data contained in the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+n} & The index of the element for which data should be accessed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Read-\/only (constant) reference to data. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & If {\itshape \+\_\+\+\_\+n} is an invalid index.\\
\hline
\end{DoxyExceptions}
This function provides for safer data access. The parameter is first checked that it is in the range of the deque. The function throws out\+\_\+of\+\_\+range if the check fails.

Returns a read/write reference to the data at the first element of the deque.

Returns a read-\/only (constant) reference to the data at the first element of the deque.

Returns a read/write reference to the data at the last element of the deque.

Returns a read-\/only (constant) reference to the data at the last element of the deque.

Add data to the front of the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+x} & Data to be added.\\
\hline
\end{DoxyParams}
This is a typical stack operation. The function creates an element at the front of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time.

Add data to the end of the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+x} & Data to be added.\\
\hline
\end{DoxyParams}
This is a typical stack operation. The function creates an element at the end of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time.

Removes first element.

This is a typical stack operation. It shrinks the deque by one.

Note that no data is returned, and if the first element\textquotesingle{}s data is needed, it should be retrieved before pop\+\_\+front() is called.

Removes last element.

This is a typical stack operation. It shrinks the deque by one.

Note that no data is returned, and if the last element\textquotesingle{}s data is needed, it should be retrieved before pop\+\_\+back() is called.

Inserts given value into deque before specified iterator. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+position} & An iterator into the deque. \\
\hline
{\em \+\_\+\+\_\+x} & Data to be inserted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator that points to the inserted data.
\end{DoxyReturn}
This function will insert a copy of the given value before the specified location.

Inserts a number of copies of given data into the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+position} & An iterator into the deque. \\
\hline
{\em \+\_\+\+\_\+n} & Number of elements to be inserted. \\
\hline
{\em \+\_\+\+\_\+x} & Data to be inserted.\\
\hline
\end{DoxyParams}
This function will insert a specified number of copies of the given data before the location specified by {\itshape \+\_\+\+\_\+position}.

Inserts a range into the deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+position} & An iterator into the deque. \\
\hline
{\em \+\_\+\+\_\+first} & An input iterator. \\
\hline
{\em \+\_\+\+\_\+last} & An input iterator.\\
\hline
\end{DoxyParams}
This function will insert copies of the data in the range \mbox{[}\+\_\+\+\_\+first,\+\_\+\+\_\+last) into the deque before the location specified by {\itshape \+\_\+\+\_\+position}. This is known as {\itshape range insert}.

Remove element at given position. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+position} & Iterator pointing to element to be erased. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator pointing to the next element (or \doxylink{_classes_2lib_2raylib_2src_2external_2glad_8h_a432111147038972f06e049e18a837002}{end()}).
\end{DoxyReturn}
This function will erase the element at the given position and thus shorten the deque by one.

The user is cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-\/to memory is not touched in any way. Managing the pointer is the user\textquotesingle{}s responsibility.

Remove a range of elements. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+first} & Iterator pointing to the first element to be erased. \\
\hline
{\em \+\_\+\+\_\+last} & Iterator pointing to one past the last element to be erased. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator pointing to the element pointed to by {\itshape last} prior to erasing (or \doxylink{_classes_2lib_2raylib_2src_2external_2glad_8h_a432111147038972f06e049e18a837002}{end()}).
\end{DoxyReturn}
This function will erase the elements in the range \mbox{[}\+\_\+\+\_\+first,\+\_\+\+\_\+last) and shorten the deque accordingly.

The user is cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-\/to memory is not touched in any way. Managing the pointer is the user\textquotesingle{}s responsibility.

Swaps data with another deque. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+x} & A deque of the same element and allocator types.\\
\hline
\end{DoxyParams}
This exchanges the elements between two deques in constant time. (Four pointers, so it should be quite fast.) Note that the global \doxylink{namespacestd_a3ece115a1c8ed9020a20f1d0b70efda8}{std\+::swap()} function is specialized such that std\+::swap(d1,d2) will feed to this function.

Whether the allocators are swapped depends on the allocator traits.

Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-\/to memory is not touched in any way. Managing the pointer is the user\textquotesingle{}s responsibility.

Fills the deque with whatever is in \mbox{[}first,last). 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+first} & An input iterator. \\
\hline
{\em \+\_\+\+\_\+last} & An input iterator. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
If the iterators are actually forward iterators (or better), then the memory layout can be done all at once. Else we move forward using push\+\_\+back on each value from the iterator.Here is the call graph for this function\+:
% FIG 1
