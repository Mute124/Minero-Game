\chapter{Smooth-\/\+Infinite-\/\+Voxel-\/\+Terrain}
\hypertarget{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b}{}\label{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b}\index{Smooth-\/Infinite-\/Voxel-\/Terrain@{Smooth-\/Infinite-\/Voxel-\/Terrain}}
\label{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md715}%
\Hypertarget{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md715}%
A voxel terrain generator that allows artists to easily create endless, diverse game worlds.

dependencies\+: \href{www.transvoxel.org}{\texttt{ transvoxel}} and \href{www.volumesoffun.com}{\texttt{ polyvox}}

octree\+:

The original version of polyvox used virtual memory to page in \& out terrain chunks.

For this project, we use octree instead, as it allows us to easily implement chunk LOD.

Built-\/in multi-\/threading supports memory-\/consuming components such as A.\+I. units and surface vegetation.\hypertarget{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md716}{}\doxysection{\texorpdfstring{Chunk management with octrees}{Chunk management with octrees}}\label{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md716}
Each leaf node contains a single chunk, whose LOD is updated by the tree. The player carries a voxel modification component integrated with polyvox, and each octree calculates the distance between the component and its central location per frame. The variables mentioned above are used to determine a chunk\textquotesingle{}s LOD, which tremendously improves the overall performance during runtime. Here are some pictures comparing a terrain segment generated with the conventional method that loads chunk with virtual memory paging, and another one generated with the maneuver mentioned above.

Generated with conventional method\+:

A small-\/sized, limited with virtual memory paging\+:



Generated with octrees\+:

Huge terrain segment with vegetation and dynamic LOD

Please note that smooth shading is supported. The lowpoly effect is intentionally created by the terrain material with DDX and DDY nodes.

  

Each octree calculates the distance between the player and its central position to determine its LOD. A lower LOD indicates a larger octree with a single chunk in the same size.\hypertarget{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md717}{}\doxysection{\texorpdfstring{Drawbacks of virtual memory paging\+:}{Drawbacks of virtual memory paging:}}\label{md__c_1_2_users_2_h_p_2_documents_2_git_hub_2_minero-_game_2_classes_2lib_2_smooth-_infinite-_voc24406109f3ef65b2e2bac5add3b0b7b_autotoc_md717}
When used with a large-\/scale polygon engine, chunks must be paged out of virtual memory in a constructor. As a result, engine-\/specific multi-\/threading functions can not access terrain data during construction, which is probably the reason why the conventional method is so slow. 