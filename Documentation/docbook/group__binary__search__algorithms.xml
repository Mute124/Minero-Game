<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__binary__search__algorithms" xml:lang="en-US">
<title>Binary Search</title>
<indexterm><primary>Binary Search</primary></indexterm>
Collaboration diagram for Binary Search:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__binary__search__algorithms.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>

<para>These algorithms are variations of a classic binary search, and all assume that the sequence being searched is already sorted.</para>

<para>The number of comparisons will be logarithmic (and as few as possible). The number of steps through the sequence will be logarithmic for random-access iterators (e.g., pointers), and linear otherwise.</para>

<para>The LWG has passed Defect Report 270, which notes: <emphasis>The proposed resolution reinterprets binary search. Instead of thinking about searching for a value in a sorted range, we view that as an important special case of a more general algorithm: searching for the partition point in a partitioned range. We also add a guarantee that the old wording did not: we ensure that the upper bound is no earlier than the lower bound, that the pair returned by equal_range is a valid range, and that the first part of that pair is the lower bound.</emphasis></para>

<para>The actual effect of the first sentence is that a comparison functor passed by the user doesn&apos;t necessarily need to induce a strict weak ordering relation. Rather, it partitions the range.</para>

<para>These algorithms are variations of a classic binary search, and all assume that the sequence being searched is already sorted.</para>

<para>The number of comparisons will be logarithmic (and as few as possible). The number of steps through the sequence will be logarithmic for random-access iterators (e.g., pointers), and linear otherwise.</para>

<para>The LWG has passed Defect Report 270, which notes: <emphasis>The proposed resolution reinterprets binary search. Instead of thinking about searching for a value in a sorted range, we view that as an important special case of a more general algorithm: searching for the partition point in a partitioned range. We also add a guarantee that the old wording did not: we ensure that the upper bound is no earlier than the lower bound, that the pair returned by equal_range is a valid range, and that the first part of that pair is the lower bound.</emphasis></para>

<para>The actual effect of the first sentence is that a comparison functor passed by the user doesn&apos;t necessarily need to induce a strict weak ordering relation. Rather, it partitions the range.</para>

<para>These algorithms are variations of a classic binary search, and all assume that the sequence being searched is already sorted.</para>

<para>The number of comparisons will be logarithmic (and as few as possible). The number of steps through the sequence will be logarithmic for random-access iterators (e.g., pointers), and linear otherwise.</para>

<para>The LWG has passed Defect Report 270, which notes: <emphasis>The proposed resolution reinterprets binary search. Instead of thinking about searching for a value in a sorted range, we view that as an important special case of a more general algorithm: searching for the partition point in a partitioned range. We also add a guarantee that the old wording did not: we ensure that the upper bound is no earlier than the lower bound, that the pair returned by equal_range is a valid range, and that the first part of that pair is the lower bound.</emphasis></para>

<para>The actual effect of the first sentence is that a comparison functor passed by the user doesn&apos;t necessarily need to induce a strict weak ordering relation. Rather, it partitions the range.</para>
</section>
