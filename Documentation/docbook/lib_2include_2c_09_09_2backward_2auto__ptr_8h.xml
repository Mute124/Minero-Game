<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_lib_2include_2c_09_09_2backward_2auto__ptr_8h" xml:lang="en-US">
<title>C:/Users/HP/Documents/GitHub/Minero-Game/lib/include/c++/backward/auto_ptr.h File Reference</title>
<indexterm><primary>C:/Users/HP/Documents/GitHub/Minero-Game/lib/include/c++/backward/auto_ptr.h</primary></indexterm>
<programlisting linenumbering="unnumbered">#include &lt;bits/c++config.h&gt;<?linebreak?>#include &lt;debug/debug.h&gt;<?linebreak?></programlisting>Include dependency graph for auto_ptr.h:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="lib_2include_2c_09_09_2backward_2auto__ptr_8h__incl.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>namespace std <link linkend="_lib_2include_2c_09_09_2backward_2auto__ptr_8h_1a544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</link> (default)</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Function Documentation</title>
<anchor xml:id="_lib_2include_2c_09_09_2backward_2auto__ptr_8h_1a544d74b2d5d0dd2197f5fd6f02691de0"/><section>
    <title>_GLIBCXX_VISIBILITY()</title>
<indexterm><primary>_GLIBCXX_VISIBILITY</primary><secondary>auto_ptr.h</secondary></indexterm>
<indexterm><primary>auto_ptr.h</primary><secondary>_GLIBCXX_VISIBILITY</secondary></indexterm>
<para><computeroutput>namespace std _GLIBCXX_VISIBILITY (default )</computeroutput></para>
<para>A wrapper class to provide auto_ptr with reference semantics. For example, an auto_ptr can be assigned (or constructed from) the result of a function which returns an auto_ptr by value.</para>

<para>All the auto_ptr_ref stuff should happen behind the scenes.</para>

<para>A simple smart pointer providing strict ownership semantics.</para>

<para>The Standard says: <literallayout>
An <computeroutput>auto_ptr</computeroutput> owns the object it holds a pointer to.  Copying
an <computeroutput>auto_ptr</computeroutput> copies the pointer and transfers ownership to the
destination.  If more than one <computeroutput>auto_ptr</computeroutput> owns the same object
at the same time the behavior of the program is undefined.

The uses of <computeroutput>auto_ptr</computeroutput> include providing temporary
exception-safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and
returning dynamically allocated memory from a function.  <computeroutput>auto_ptr</computeroutput> does not meet the CopyConstructible and Assignable
requirements for Standard Library <link xlink:href="tables.html#65">container</link> elements and thus
instantiating a Standard Library container with an <computeroutput>auto_ptr</computeroutput> results in undefined behavior.
</literallayout> Quoted from [20.4.5]/3.</para>

<para>Good examples of what can and cannot be done with auto_ptr can be found in the libstdc++ testsuite.</para>

<para>_GLIBCXX_RESOLVE_LIB_DEFECTS<orderedlist>
<listitem>
<para>auto_ptr&lt;&gt; conversion issues These resolutions have all been incorporated.</para>
</listitem></orderedlist>
</para>

<para>The pointed-to type.</para>

<para>An auto_ptr is usually constructed from a raw pointer. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__p</entry><entry>
<para>A pointer (defaults to NULL).</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                This object now <emphasis>owns</emphasis> the object pointed to by <emphasis>__p</emphasis>.</para>

<para>An auto_ptr can be constructed from another auto_ptr. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__a</entry><entry>
<para>Another auto_ptr of the same type.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                This object now <emphasis>owns</emphasis> the object previously owned by <emphasis>__a</emphasis>, which has given up ownership.</para>

<para>An auto_ptr can be constructed from another auto_ptr. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__a</entry><entry>
<para>Another auto_ptr of a different but related type.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</para>

<para>This object now <emphasis>owns</emphasis> the object previously owned by <emphasis>__a</emphasis>, which has given up ownership.</para>

<para>auto_ptr assignment operator. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__a</entry><entry>
<para>Another auto_ptr of the same type.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                This object now <emphasis>owns</emphasis> the object previously owned by <emphasis>__a</emphasis>, which has given up ownership. The object that this one <emphasis>used</emphasis> to own and track has been deleted.</para>

<para>auto_ptr assignment operator. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__a</entry><entry>
<para>Another auto_ptr of a different but related type.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</para>

<para>This object now <emphasis>owns</emphasis> the object previously owned by <emphasis>__a</emphasis>, which has given up ownership. The object that this one <emphasis>used</emphasis> to own and track has been deleted.</para>

<para>When the auto_ptr goes out of scope, the object it owns is deleted. If it no longer owns anything (i.e., <computeroutput><link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1afc5e04fa58feb228bb06199ff10caa22">get()</link></computeroutput> is <computeroutput>NULL</computeroutput>), then this has no effect.</para>

<para>The C++ standard says there is supposed to be an empty throw specification here, but omitting it is standard conforming. Its presence can be detected only if _Tp::~_Tp() throws, but this is prohibited. [17.4.3.6]/2</para>

<para>Smart pointer dereferencing.</para>

<para>If this auto_ptr no longer owns anything, then this operation will crash. (For a smart pointer, <emphasis>no longer owns anything</emphasis> is the same as being a null pointer, and you know what happens when you dereference one of those...)</para>

<para>Smart pointer dereferencing.</para>

<para>This returns the pointer itself, which the language then will automatically cause to be dereferenced.</para>

<para>Bypassing the smart pointer. <formalpara><title>Returns</title>

<para>The raw pointer being managed.</para>
</formalpara>
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</para>

<para><note><title>Note</title>

<para>This auto_ptr still owns the memory.</para>
</note>
Bypassing the smart pointer. <formalpara><title>Returns</title>

<para>The raw pointer being managed.</para>
</formalpara>
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</para>

<para><note><title>Note</title>

<para>This auto_ptr no longer owns the memory. When this object goes out of scope, nothing will happen.</para>
</note>
Forcibly deletes the managed object. 
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>__p</entry><entry>
<para>A pointer (defaults to NULL).</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                This object now <emphasis>owns</emphasis> the object pointed to by <emphasis>__p</emphasis>. The previous object has been deleted.</para>

<para>Automatic conversions</para>

<para>These operations are supposed to convert an auto_ptr into and from an auto_ptr_ref automatically as needed. This would allow constructs such as <literallayout><computeroutput>auto_ptr&lt;Derived&gt;&#32;&#32;func_returning_auto_ptr(.....);
...
auto_ptr&lt;Base&gt;&#32;ptr&#32;=&#32;func_returning_auto_ptr(.....);
</computeroutput></literallayout></para>

<para>But it doesn&apos;t work, and won&apos;t be fixed. For further details see <link xlink:href="http://cplusplus.github.io/LWG/lwg-closed.html#463">http://cplusplus.github.io/LWG/lwg-closed.html#463</link></para>
Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="lib_2include_2c_09_09_2backward_2auto__ptr_8h_a544d74b2d5d0dd2197f5fd6f02691de0_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
</section>
</section>
