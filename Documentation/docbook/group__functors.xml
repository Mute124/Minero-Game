<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__functors" xml:lang="en-US">
<title>Function Objects</title>
<indexterm><primary>Function Objects</primary></indexterm>
Collaboration diagram for Function Objects:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__functors.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Modules    </title>
        <itemizedlist>
            <listitem><para><link linkend="_group__binders">Binder Classes</link></para>
</listitem>
            <listitem><para><link linkend="_group__hashes">Hashes</link></para>
</listitem>
            <listitem><para><link linkend="_group__arithmetic__functors">Arithmetic Function Object Classes</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>namespace std <link linkend="_group__functors_1ga544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</link> (default)</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Function objects, or <emphasis>functors</emphasis>, are objects with an <computeroutput>operator()</computeroutput> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <emphasis>functors</emphasis>, then, generally we include function pointers in the description as well.</para>

<para>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</para>

<para>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput> containing <computeroutput>double</computeroutput>, and put the result in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a6eba317e3cf44d6d26c04a5a8f197dcb">b</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;plus&lt;double&gt;());
</computeroutput></literallayout> To negate every element in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;negate&lt;double&gt;());
</computeroutput></literallayout> The addition and negation functions will usually be inlined directly.</para>

<para>An <emphasis>adaptable function object</emphasis> is one which provides nested typedefs <computeroutput>result_type</computeroutput> and either <computeroutput>argument_type</computeroutput> (for a unary function) or <computeroutput>first_argument_type</computeroutput> and <computeroutput>second_argument_type</computeroutput> (for a binary function). Those typedefs are used by function object adaptors such as <computeroutput>bind2nd</computeroutput>. The standard library provides two class templates, <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>, which define those typedefs and so can be used as base classes of adaptable function objects.</para>

<para>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <computeroutput>function&lt;&gt;</computeroutput>, and more powerful type deduction (using <computeroutput>auto</computeroutput> and <computeroutput>decltype</computeroutput>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</para>

<para>Function objects, or <emphasis>functors</emphasis>, are objects with an <computeroutput>operator()</computeroutput> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <emphasis>functors</emphasis>, then, generally we include function pointers in the description as well.</para>

<para>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</para>

<para>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput> containing <computeroutput>double</computeroutput>, and put the result in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a6eba317e3cf44d6d26c04a5a8f197dcb">b</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;plus&lt;double&gt;());
</computeroutput></literallayout> To negate every element in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;negate&lt;double&gt;());
</computeroutput></literallayout> The addition and negation functions will usually be inlined directly.</para>

<para>An <emphasis>adaptable function object</emphasis> is one which provides nested typedefs <computeroutput>result_type</computeroutput> and either <computeroutput>argument_type</computeroutput> (for a unary function) or <computeroutput>first_argument_type</computeroutput> and <computeroutput>second_argument_type</computeroutput> (for a binary function). Those typedefs are used by function object adaptors such as <computeroutput>bind2nd</computeroutput>. The standard library provides two class templates, <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>, which define those typedefs and so can be used as base classes of adaptable function objects.</para>

<para>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <computeroutput>function&lt;&gt;</computeroutput>, and more powerful type deduction (using <computeroutput>auto</computeroutput> and <computeroutput>decltype</computeroutput>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</para>

<para>Function objects, or <emphasis>functors</emphasis>, are objects with an <computeroutput>operator()</computeroutput> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <emphasis>functors</emphasis>, then, generally we include function pointers in the description as well.</para>

<para>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</para>

<para>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <computeroutput>a</computeroutput> and <computeroutput>b</computeroutput> containing <computeroutput>double</computeroutput>, and put the result in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a6eba317e3cf44d6d26c04a5a8f197dcb">b</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;plus&lt;double&gt;());
</computeroutput></literallayout> To negate every element in <computeroutput>a</computeroutput>, use <literallayout><computeroutput><link linkend="_namespacestd_1a83797c5677d80005911de218c819adab">transform</link>(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.end(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1ac8729153468b5dcf13f971b21d84d4e5">a</link>.begin(),&#32;negate&lt;double&gt;());
</computeroutput></literallayout> The addition and negation functions will usually be inlined directly.</para>

<para>An <emphasis>adaptable function object</emphasis> is one which provides nested typedefs <computeroutput>result_type</computeroutput> and either <computeroutput>argument_type</computeroutput> (for a unary function) or <computeroutput>first_argument_type</computeroutput> and <computeroutput>second_argument_type</computeroutput> (for a binary function). Those typedefs are used by function object adaptors such as <computeroutput>bind2nd</computeroutput>. The standard library provides two class templates, <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>, which define those typedefs and so can be used as base classes of adaptable function objects.</para>

<para>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <computeroutput>function&lt;&gt;</computeroutput>, and more powerful type deduction (using <computeroutput>auto</computeroutput> and <computeroutput>decltype</computeroutput>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</para>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_group__functors_1ga544d74b2d5d0dd2197f5fd6f02691de0"/><section>
    <title>_GLIBCXX_VISIBILITY()</title>
<indexterm><primary>_GLIBCXX_VISIBILITY</primary><secondary>Function Objects</secondary></indexterm>
<indexterm><primary>Function Objects</primary><secondary>_GLIBCXX_VISIBILITY</secondary></indexterm>
<para><computeroutput>namespace std _GLIBCXX_VISIBILITY (default )</computeroutput></para>
<para>Polymorphic function wrapper.</para>

<para><formalpara><title>Since</title>

<para>C++23</para>
</formalpara>
The <computeroutput>std::move_only_function</computeroutput> class template is a call wrapper similar to * <computeroutput>std::function</computeroutput>, but does not require the stored target function to be copyable.</para>

<para>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <computeroutput>move_only_function::operator()</computeroutput> member function are respected when invoking the target function.</para>

<para>Creates an empty object.</para>

<para>Creates an empty object.</para>

<para>Moves the target object, leaving the source empty.</para>

<para>Stores a target object initialized from the argument.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a new target object, leaving <computeroutput>x</computeroutput> empty.</para>

<para>Destroys the target object (if any).</para>

<para>Stores a new target object, initialized from the argument.</para>

<para>True if a target object is present, false otherwise.</para>

<para>Invoke the target object.</para>

<para>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <computeroutput>move_only_function</computeroutput> specialization.</para>

<para><formalpara><title>Precondition</title>

<para>Must not be empty.</para>
</formalpara>
Exchange the target objects (if any).</para>

<para>Exchange the target objects (if any).</para>

<para>Check for emptiness by comparing with <computeroutput>nullptr</computeroutput>.</para>

<para>Polymorphic function wrapper.</para>

<para><formalpara><title>Since</title>

<para>C++23</para>
</formalpara>
The <computeroutput>std::move_only_function</computeroutput> class template is a call wrapper similar to * <computeroutput>std::function</computeroutput>, but does not require the stored target function to be copyable.</para>

<para>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <computeroutput>move_only_function::operator()</computeroutput> member function are respected when invoking the target function.</para>

<para>Creates an empty object.</para>

<para>Creates an empty object.</para>

<para>Moves the target object, leaving the source empty.</para>

<para>Stores a target object initialized from the argument.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a new target object, leaving <computeroutput>x</computeroutput> empty.</para>

<para>Destroys the target object (if any).</para>

<para>Stores a new target object, initialized from the argument.</para>

<para>True if a target object is present, false otherwise.</para>

<para>Invoke the target object.</para>

<para>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <computeroutput>move_only_function</computeroutput> specialization.</para>

<para><formalpara><title>Precondition</title>

<para>Must not be empty.</para>
</formalpara>
Exchange the target objects (if any).</para>

<para>Exchange the target objects (if any).</para>

<para>Check for emptiness by comparing with <computeroutput>nullptr</computeroutput>.</para>

<para>Polymorphic function wrapper.</para>

<para><formalpara><title>Since</title>

<para>C++23</para>
</formalpara>
The <computeroutput>std::move_only_function</computeroutput> class template is a call wrapper similar to * <computeroutput>std::function</computeroutput>, but does not require the stored target function to be copyable.</para>

<para>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <computeroutput>move_only_function::operator()</computeroutput> member function are respected when invoking the target function.</para>

<para>Creates an empty object.</para>

<para>Creates an empty object.</para>

<para>Moves the target object, leaving the source empty.</para>

<para>Stores a target object initialized from the argument.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a target object initialized from the arguments.</para>

<para>Stores a new target object, leaving <computeroutput>x</computeroutput> empty.</para>

<para>Destroys the target object (if any).</para>

<para>Stores a new target object, initialized from the argument.</para>

<para>True if a target object is present, false otherwise.</para>

<para>Invoke the target object.</para>

<para>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <computeroutput>move_only_function</computeroutput> specialization.</para>

<para><formalpara><title>Precondition</title>

<para>Must not be empty.</para>
</formalpara>
Exchange the target objects (if any).</para>

<para>Exchange the target objects (if any).</para>

<para>Check for emptiness by comparing with <computeroutput>nullptr</computeroutput>.</para>
Here is the call graph for this function:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__functors_ga544d74b2d5d0dd2197f5fd6f02691de0_cgraph.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
</section>
</section>
    <xi:include href="group__binders.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
    <xi:include href="group__hashes.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
    <xi:include href="group__arithmetic__functors.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
</section>
