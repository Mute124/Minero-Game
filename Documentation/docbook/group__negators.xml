<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__negators" xml:lang="en-US">
<title>Negators</title>
<indexterm><primary>Negators</primary></indexterm>
Collaboration diagram for Negators:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__negators.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Modules    </title>
        <itemizedlist>
            <listitem><para><link linkend="_group__pointer__adaptors">Adaptors for pointers to functions</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para><?linebreak?></para>

<para>The function templates <computeroutput>not1</computeroutput> and <computeroutput>not2</computeroutput> are function object adaptors, which each take a predicate functor and wrap it in an instance of <computeroutput>unary_negate</computeroutput> or <computeroutput>binary_negate</computeroutput>, respectively. Those classes are functors whose <computeroutput>operator()</computeroutput> evaluates the wrapped predicate function and then returns the negation of the result.</para>

<para>For example, given a vector of integers and a trivial predicate, <literallayout><computeroutput><emphasis role="keyword">struct&#32;</emphasis>IntGreaterThanThree
&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;std::unary_function&lt;int,&#32;bool&gt;
{
&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;operator()&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>)<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>&#32;&gt;&#32;3;&#32;}
};

<link linkend="_namespacestd_1a12540b98a8b3f5862173e50b92f1de81">std::find_if</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.end(),&#32;not1(IntGreaterThanThree()));
</computeroutput></literallayout> The call to <computeroutput>find_if</computeroutput> will locate the first index (i) of <computeroutput>v</computeroutput> for which <computeroutput>!(v[i] &gt; 3)</computeroutput> is true.</para>

<para>The not1/unary_negate combination works on predicates taking a single argument. The not2/binary_negate combination works on predicates taking two arguments.</para>

<para><para><link linkend="_deprecated_1_deprecated000011">Deprecated</link> 
<para>Deprecated in C++17, no longer in the standard since C++20. Use <computeroutput>not_fn</computeroutput> instead.</para>
</para></para>

<para><?linebreak?></para>

<para>The function templates <computeroutput>not1</computeroutput> and <computeroutput>not2</computeroutput> are function object adaptors, which each take a predicate functor and wrap it in an instance of <computeroutput>unary_negate</computeroutput> or <computeroutput>binary_negate</computeroutput>, respectively. Those classes are functors whose <computeroutput>operator()</computeroutput> evaluates the wrapped predicate function and then returns the negation of the result.</para>

<para>For example, given a vector of integers and a trivial predicate, <literallayout><computeroutput><emphasis role="keyword">struct&#32;</emphasis>IntGreaterThanThree
&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;std::unary_function&lt;int,&#32;bool&gt;
{
&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;operator()&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>)<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>&#32;&gt;&#32;3;&#32;}
};

<link linkend="_namespacestd_1a12540b98a8b3f5862173e50b92f1de81">std::find_if</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.end(),&#32;not1(IntGreaterThanThree()));
</computeroutput></literallayout> The call to <computeroutput>find_if</computeroutput> will locate the first index (i) of <computeroutput>v</computeroutput> for which <computeroutput>!(v[i] &gt; 3)</computeroutput> is true.</para>

<para>The not1/unary_negate combination works on predicates taking a single argument. The not2/binary_negate combination works on predicates taking two arguments.</para>

<para><para><link linkend="_deprecated_1_deprecated000027">Deprecated</link> 
<para>Deprecated in C++17, no longer in the standard since C++20. Use <computeroutput>not_fn</computeroutput> instead.</para>
</para></para>

<para><?linebreak?></para>

<para>The function templates <computeroutput>not1</computeroutput> and <computeroutput>not2</computeroutput> are function object adaptors, which each take a predicate functor and wrap it in an instance of <computeroutput>unary_negate</computeroutput> or <computeroutput>binary_negate</computeroutput>, respectively. Those classes are functors whose <computeroutput>operator()</computeroutput> evaluates the wrapped predicate function and then returns the negation of the result.</para>

<para>For example, given a vector of integers and a trivial predicate, <literallayout><computeroutput><emphasis role="keyword">struct&#32;</emphasis>IntGreaterThanThree
&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;std::unary_function&lt;int,&#32;bool&gt;
{
&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;operator()&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>)<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_1ac916c0825494ac3acd4457effd2823d2">x</link>&#32;&gt;&#32;3;&#32;}
};

<link linkend="_namespacestd_1a12540b98a8b3f5862173e50b92f1de81">std::find_if</link>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.begin(),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a14cfbe2fc2234f5504618905b69d1e06">v</link>.end(),&#32;not1(IntGreaterThanThree()));
</computeroutput></literallayout> The call to <computeroutput>find_if</computeroutput> will locate the first index (i) of <computeroutput>v</computeroutput> for which <computeroutput>!(v[i] &gt; 3)</computeroutput> is true.</para>

<para>The not1/unary_negate combination works on predicates taking a single argument. The not2/binary_negate combination works on predicates taking two arguments.</para>

<para><para><link linkend="_deprecated_1_deprecated000041">Deprecated</link> 
<para>Deprecated in C++17, no longer in the standard since C++20. Use <computeroutput>not_fn</computeroutput> instead.</para>
</para></para>
</section>
    <xi:include href="group__pointer__adaptors.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
</section>
