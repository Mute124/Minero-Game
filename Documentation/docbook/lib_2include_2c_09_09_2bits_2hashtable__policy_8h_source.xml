<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_lib_2include_2c_09_09_2bits_2hashtable__policy_8h_source" xml:lang="en-US">
<title>hashtable_policy.h</title>
<indexterm><primary>C:/Users/HP/Documents/GitHub/Minero-Game/lib/include/c++/bits/hashtable_policy.h</primary></indexterm>
Go to the documentation of this file.<programlisting linenumbering="unnumbered">1 <emphasis role="comment">//&#32;Internal&#32;policy&#32;header&#32;for&#32;unordered_set&#32;and&#32;unordered_map&#32;-*-&#32;C++&#32;-*-</emphasis>
2 
3 <emphasis role="comment">//&#32;Copyright&#32;(C)&#32;2010-2022&#32;Free&#32;Software&#32;Foundation,&#32;Inc.</emphasis>
4 <emphasis role="comment">//</emphasis>
5 <emphasis role="comment">//&#32;This&#32;file&#32;is&#32;part&#32;of&#32;the&#32;GNU&#32;ISO&#32;C++&#32;Library.&#32;&#32;This&#32;library&#32;is&#32;free</emphasis>
6 <emphasis role="comment">//&#32;software;&#32;you&#32;can&#32;redistribute&#32;it&#32;and/or&#32;modify&#32;it&#32;under&#32;the</emphasis>
7 <emphasis role="comment">//&#32;terms&#32;of&#32;the&#32;GNU&#32;General&#32;Public&#32;License&#32;as&#32;published&#32;by&#32;the</emphasis>
8 <emphasis role="comment">//&#32;Free&#32;Software&#32;Foundation;&#32;either&#32;version&#32;3,&#32;or&#32;(at&#32;your&#32;option)</emphasis>
9 <emphasis role="comment">//&#32;any&#32;later&#32;version.</emphasis>
10 
11 <emphasis role="comment">//&#32;This&#32;library&#32;is&#32;distributed&#32;in&#32;the&#32;hope&#32;that&#32;it&#32;will&#32;be&#32;useful,</emphasis>
12 <emphasis role="comment">//&#32;but&#32;WITHOUT&#32;ANY&#32;WARRANTY;&#32;without&#32;even&#32;the&#32;implied&#32;warranty&#32;of</emphasis>
13 <emphasis role="comment">//&#32;MERCHANTABILITY&#32;or&#32;FITNESS&#32;FOR&#32;A&#32;PARTICULAR&#32;PURPOSE.&#32;&#32;See&#32;the</emphasis>
14 <emphasis role="comment">//&#32;GNU&#32;General&#32;Public&#32;License&#32;for&#32;more&#32;details.</emphasis>
15 
16 <emphasis role="comment">//&#32;Under&#32;Section&#32;7&#32;of&#32;GPL&#32;version&#32;3,&#32;you&#32;are&#32;granted&#32;additional</emphasis>
17 <emphasis role="comment">//&#32;permissions&#32;described&#32;in&#32;the&#32;GCC&#32;Runtime&#32;Library&#32;Exception,&#32;version</emphasis>
18 <emphasis role="comment">//&#32;3.1,&#32;as&#32;published&#32;by&#32;the&#32;Free&#32;Software&#32;Foundation.</emphasis>
19 
20 <emphasis role="comment">//&#32;You&#32;should&#32;have&#32;received&#32;a&#32;copy&#32;of&#32;the&#32;GNU&#32;General&#32;Public&#32;License&#32;and</emphasis>
21 <emphasis role="comment">//&#32;a&#32;copy&#32;of&#32;the&#32;GCC&#32;Runtime&#32;Library&#32;Exception&#32;along&#32;with&#32;this&#32;program;</emphasis>
22 <emphasis role="comment">//&#32;see&#32;the&#32;files&#32;COPYING3&#32;and&#32;COPYING.RUNTIME&#32;respectively.&#32;&#32;If&#32;not,&#32;see</emphasis>
23 <emphasis role="comment">//&#32;&lt;http://www.gnu.org/licenses/&gt;.</emphasis>
24 
31 <emphasis role="preprocessor">#ifndef&#32;_HASHTABLE_POLICY_H</emphasis>
32 <emphasis role="preprocessor">#define&#32;_HASHTABLE_POLICY_H&#32;1</emphasis>
33 
34 <emphasis role="preprocessor">#include&#32;&lt;tuple&gt;</emphasis>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;for&#32;std::tuple,&#32;std::forward_as_tuple</emphasis>
35 <emphasis role="preprocessor">#include&#32;&lt;bits/stl_algobase.h&gt;</emphasis>&#32;&#32;<emphasis role="comment">//&#32;for&#32;std::min,&#32;std::is_permutation.</emphasis>
36 <emphasis role="preprocessor">#include&#32;&lt;ext/aligned_buffer.h&gt;</emphasis>&#32;<emphasis role="comment">//&#32;for&#32;__gnu_cxx::__aligned_buffer</emphasis>
37 <emphasis role="preprocessor">#include&#32;&lt;ext/alloc_traits.h&gt;</emphasis>&#32;&#32;&#32;<emphasis role="comment">//&#32;for&#32;std::__alloc_rebind</emphasis>
38 <emphasis role="preprocessor">#include&#32;&lt;ext/numeric_traits.h&gt;</emphasis>&#32;<emphasis role="comment">//&#32;for&#32;__gnu_cxx::__int_traits</emphasis>
39 
40 <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespacestd">std</link>&#32;<link linkend="__classes_2lib_2include_2c_09_09_2x86__64-w64-mingw32_2bits_2c_09_09config_8h_1a44377df0d3503f0b3d9ab316dd8ddf8b">_GLIBCXX_VISIBILITY</link>(default)
41 {
42 _GLIBCXX_BEGIN_NAMESPACE_VERSION
44 
45 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
46 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
47 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
48 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
49 &#32;&#32;&#32;&#32;<emphasis role="keyword">class&#32;</emphasis>_Hashtable;
50 
51 <emphasis role="keyword">namespace&#32;</emphasis>__detail
52 {
58 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
59 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,
60 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
61 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_base;
62 
63 &#32;&#32;<emphasis role="comment">//&#32;Helper&#32;function:&#32;return&#32;distance(first,&#32;last)&#32;for&#32;forward</emphasis>
64 &#32;&#32;<emphasis role="comment">//&#32;iterators,&#32;or&#32;0/1&#32;for&#32;input&#32;iterators.</emphasis>
65 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Iterator&gt;
66 &#32;&#32;&#32;&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;std::iterator_traits&lt;_Iterator&gt;::difference_type
67 &#32;&#32;&#32;&#32;__distance_fw(_Iterator&#32;__first,&#32;_Iterator&#32;__last,
68 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::input_iterator_tag)
69 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__first&#32;!=&#32;__last&#32;?&#32;1&#32;:&#32;0;&#32;}
70 
71 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Iterator&gt;
72 &#32;&#32;&#32;&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;std::iterator_traits&lt;_Iterator&gt;::difference_type
73 &#32;&#32;&#32;&#32;__distance_fw(_Iterator&#32;__first,&#32;_Iterator&#32;__last,
74 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward_iterator_tag)
75 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::distance(__first,&#32;__last);&#32;}
76 
77 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Iterator&gt;
78 &#32;&#32;&#32;&#32;<emphasis role="keyword">inline</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;std::iterator_traits&lt;_Iterator&gt;::difference_type
79 &#32;&#32;&#32;&#32;__distance_fw(_Iterator&#32;__first,&#32;_Iterator&#32;__last)
80 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__distance_fw(__first,&#32;__last,
81 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::__iterator_category(__first));&#32;}
82 
83 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Identity
84 &#32;&#32;{
85 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
86 &#32;&#32;&#32;&#32;&#32;&#32;_Tp&amp;&amp;
87 &#32;&#32;&#32;&#32;&#32;&#32;operator()(_Tp&amp;&amp;&#32;__x)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
88 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::forward&lt;_Tp&gt;(__x);&#32;}
89 &#32;&#32;};
90 
91 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Select1st
92 &#32;&#32;{
93 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair&gt;
94 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__1st_type;
95 
96 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Up&gt;
97 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__1st_type&lt;pair&lt;_Tp,&#32;_Up&gt;&gt;
98 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2_gameobj_8h_1a890efa53b3d7deeeced6f3a0d6653ed3">type</link>&#32;=&#32;_Tp;&#32;};
99 
100 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Up&gt;
101 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__1st_type&lt;const&#32;pair&lt;_Tp,&#32;_Up&gt;&gt;
102 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2_gameobj_8h_1a890efa53b3d7deeeced6f3a0d6653ed3">type</link>&#32;=&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp;&#32;};
103 
104 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair&gt;
105 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__1st_type&lt;_Pair&amp;&gt;
106 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2_gameobj_8h_1a890efa53b3d7deeeced6f3a0d6653ed3">type</link>&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__1st_type&lt;_Pair&gt;::type&amp;;&#32;};
107 
108 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
109 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__1st_type&lt;_Tp&gt;::type&amp;&amp;
110 &#32;&#32;&#32;&#32;&#32;&#32;operator()(_Tp&amp;&amp;&#32;__x)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
111 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::forward&lt;_Tp&gt;(__x).first;&#32;}
112 &#32;&#32;};
113 
114 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_ExKey&gt;
115 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_NodeBuilder;
116 
117 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;&gt;
118 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_NodeBuilder&lt;_Select1st&gt;
119 &#32;&#32;&#32;&#32;{
120 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
121 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">auto</emphasis>
122 &#32;&#32;&#32;&#32;_S_build(_Kt&amp;&amp;&#32;__k,&#32;_Arg&amp;&amp;&#32;__arg,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen)
123 &#32;&#32;&#32;&#32;-&gt;&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator::__node_type*
124 &#32;&#32;&#32;&#32;{
125 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node_gen(std::forward&lt;_Kt&gt;(__k),
126 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Arg&gt;(__arg).second);
127 &#32;&#32;&#32;&#32;}
128 &#32;&#32;&#32;&#32;};
129 
130 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;&gt;
131 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_NodeBuilder&lt;_Identity&gt;
132 &#32;&#32;&#32;&#32;{
133 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
134 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">auto</emphasis>
135 &#32;&#32;&#32;&#32;_S_build(_Kt&amp;&amp;&#32;__k,&#32;_Arg&amp;&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen)
136 &#32;&#32;&#32;&#32;-&gt;&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator::__node_type*
137 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node_gen(std::forward&lt;_Kt&gt;(__k));&#32;}
138 &#32;&#32;&#32;&#32;};
139 
140 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
141 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_alloc;
142 
143 &#32;&#32;<emphasis role="comment">//&#32;Functor&#32;recycling&#32;a&#32;pool&#32;of&#32;nodes&#32;and&#32;using&#32;allocation&#32;once&#32;the&#32;pool&#32;is</emphasis>
144 &#32;&#32;<emphasis role="comment">//&#32;empty.</emphasis>
145 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
146 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_ReuseOrAllocNode
147 &#32;&#32;&#32;&#32;{
148 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
149 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_type&#32;=&#32;_NodeAlloc;
150 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_alloc&#32;=&#32;_Hashtable_alloc&lt;__node_alloc_type&gt;;
151 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_traits&#32;=
152 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_alloc_traits;
153 
154 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
155 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_type;
156 
157 &#32;&#32;&#32;&#32;&#32;&#32;_ReuseOrAllocNode(__node_type*&#32;__nodes,&#32;__hashtable_alloc&amp;&#32;__h)
158 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_M_nodes(__nodes),&#32;_M_h(__h)&#32;{&#32;}
159 &#32;&#32;&#32;&#32;&#32;&#32;_ReuseOrAllocNode(<emphasis role="keyword">const</emphasis>&#32;_ReuseOrAllocNode&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
160 
161 &#32;&#32;&#32;&#32;&#32;&#32;~_ReuseOrAllocNode()
162 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;_M_h._M_deallocate_nodes(_M_nodes);&#32;}
163 
164 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
165 &#32;&#32;&#32;&#32;__node_type*
166 &#32;&#32;&#32;&#32;operator()(_Args&amp;&amp;...&#32;__args)<emphasis role="keyword">&#32;const</emphasis>
167 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
168 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_nodes)
169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_type*&#32;__node&#32;=&#32;_M_nodes;
171 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_nodes&#32;=&#32;_M_nodes-&gt;_M_next();
172 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node-&gt;_M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
173 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&amp;&#32;__a&#32;=&#32;_M_h._M_node_allocator();
174 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::destroy(__a,&#32;__node-&gt;_M_valptr());
175 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
176 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
177 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::construct(__a,&#32;__node-&gt;_M_valptr(),
178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Args&gt;(__args)...);
179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
180 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
181 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
182 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_h._M_deallocate_node_ptr(__node);
183 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
185 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node;
186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
187 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_h._M_allocate_node(std::forward&lt;_Args&gt;(__args)...);
188 &#32;&#32;&#32;&#32;}
189 
190 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
191 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">mutable</emphasis>&#32;__node_type*&#32;_M_nodes;
192 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc&amp;&#32;_M_h;
193 &#32;&#32;&#32;&#32;};
194 
195 &#32;&#32;<emphasis role="comment">//&#32;Functor&#32;similar&#32;to&#32;the&#32;previous&#32;one&#32;but&#32;without&#32;any&#32;pool&#32;of&#32;nodes&#32;to</emphasis>
196 &#32;&#32;<emphasis role="comment">//&#32;recycle.</emphasis>
197 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
198 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_AllocNode
199 &#32;&#32;&#32;&#32;{
200 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
201 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_alloc&#32;=&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;;
202 
203 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
204 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_type;
205 
206 &#32;&#32;&#32;&#32;&#32;&#32;_AllocNode(__hashtable_alloc&amp;&#32;__h)
207 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_M_h(__h)&#32;{&#32;}
208 
209 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
210 &#32;&#32;&#32;&#32;__node_type*
211 &#32;&#32;&#32;&#32;operator()(_Args&amp;&amp;...&#32;__args)<emphasis role="keyword">&#32;const</emphasis>
212 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_h._M_allocate_node(std::forward&lt;_Args&gt;(__args)...);&#32;}
213 
214 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
215 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc&amp;&#32;_M_h;
216 &#32;&#32;&#32;&#32;};
217 
218 &#32;&#32;<emphasis role="comment">//&#32;Auxiliary&#32;types&#32;used&#32;for&#32;all&#32;instantiations&#32;of&#32;_Hashtable&#32;nodes</emphasis>
219 &#32;&#32;<emphasis role="comment">//&#32;and&#32;iterators.</emphasis>
220 
243 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Constant_iterators,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Unique_keys&gt;
244 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_traits
245 &#32;&#32;&#32;&#32;{
246 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_cached&#32;=&#32;__bool_constant&lt;_Cache_hash_code&gt;;
247 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__constant_iterators&#32;=&#32;__bool_constant&lt;_Constant_iterators&gt;;
248 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__unique_keys&#32;=&#32;__bool_constant&lt;_Unique_keys&gt;;
249 &#32;&#32;&#32;&#32;};
250 
257 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Hash&gt;
258 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_hash_traits
259 &#32;&#32;&#32;&#32;{
260 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;std::size_t
261 &#32;&#32;&#32;&#32;&#32;&#32;__small_size_threshold()&#32;<emphasis role="keyword">noexcept</emphasis>
262 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::__is_fast_hash&lt;_Hash&gt;::value&#32;?&#32;0&#32;:&#32;20;&#32;}
263 &#32;&#32;&#32;&#32;};
264 
273 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node_base
274 &#32;&#32;{
275 &#32;&#32;&#32;&#32;_Hash_node_base*&#32;_M_nxt;
276 
277 &#32;&#32;&#32;&#32;_Hash_node_base()&#32;noexcept&#32;:&#32;_M_nxt()&#32;{&#32;}
278 
279 &#32;&#32;&#32;&#32;_Hash_node_base(_Hash_node_base*&#32;__next)&#32;noexcept&#32;:&#32;_M_nxt(__next)&#32;{&#32;}
280 &#32;&#32;};
281 
287 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value&gt;
288 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node_value_base
289 &#32;&#32;&#32;&#32;{
290 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Value&#32;value_type;
291 
292 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_struct____gnu__cxx_1_1____aligned__buffer">__gnu_cxx::__aligned_buffer&lt;_Value&gt;</link>&#32;_M_storage;
293 
294 &#32;&#32;&#32;&#32;&#32;&#32;_Value*
295 &#32;&#32;&#32;&#32;&#32;&#32;_M_valptr()&#32;<emphasis role="keyword">noexcept</emphasis>
296 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_storage.<link linkend="_struct____gnu__cxx_1_1____aligned__buffer_1a4f7396ec827253c1af249edad1c67b06">_M_ptr</link>();&#32;}
297 
298 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Value*
299 &#32;&#32;&#32;&#32;&#32;&#32;_M_valptr()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
300 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_storage.<link linkend="_struct____gnu__cxx_1_1____aligned__buffer_1a4f7396ec827253c1af249edad1c67b06">_M_ptr</link>();&#32;}
301 
302 &#32;&#32;&#32;&#32;&#32;&#32;_Value&amp;
303 &#32;&#32;&#32;&#32;&#32;&#32;_M_v()&#32;<emphasis role="keyword">noexcept</emphasis>
304 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;*_M_valptr();&#32;}
305 
306 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Value&amp;
307 &#32;&#32;&#32;&#32;&#32;&#32;_M_v()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
308 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;*_M_valptr();&#32;}
309 &#32;&#32;&#32;&#32;};
310 
314 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code&gt;
315 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node_code_cache
316 &#32;&#32;&#32;&#32;{&#32;};
317 
321 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;&gt;
322 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node_code_cache&lt;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
323 &#32;&#32;&#32;&#32;{&#32;std::size_t&#32;&#32;_M_hash_code;&#32;};
324 
325 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code&gt;
326 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node_value
327 &#32;&#32;&#32;&#32;:&#32;_Hash_node_value_base&lt;_Value&gt;
328 &#32;&#32;&#32;&#32;,&#32;_Hash_node_code_cache&lt;_Cache_hash_code&gt;
329 &#32;&#32;&#32;&#32;{&#32;};
330 
334 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code&gt;
335 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_node
336 &#32;&#32;&#32;&#32;:&#32;_Hash_node_base
337 &#32;&#32;&#32;&#32;,&#32;_Hash_node_value&lt;_Value,&#32;_Cache_hash_code&gt;
338 &#32;&#32;&#32;&#32;{
339 &#32;&#32;&#32;&#32;&#32;&#32;_Hash_node*
340 &#32;&#32;&#32;&#32;&#32;&#32;_M_next()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
341 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>_Hash_node*<emphasis role="keyword">&gt;</emphasis>(this-&gt;_M_nxt);&#32;}
342 &#32;&#32;&#32;&#32;};
343 
345 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code&gt;
346 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Node_iterator_base
347 &#32;&#32;&#32;&#32;{
348 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;_Hash_node&lt;_Value,&#32;_Cache_hash_code&gt;;
349 
350 &#32;&#32;&#32;&#32;&#32;&#32;__node_type*&#32;_M_cur;
351 
352 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator_base()&#32;:&#32;_M_cur(<emphasis role="keyword">nullptr</emphasis>)&#32;{&#32;}
353 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator_base(__node_type*&#32;__p)&#32;noexcept
354 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_M_cur(__p)&#32;{&#32;}
355 
356 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
357 &#32;&#32;&#32;&#32;&#32;&#32;_M_incr()&#32;<emphasis role="keyword">noexcept</emphasis>
358 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;_M_cur&#32;=&#32;_M_cur-&gt;_M_next();&#32;}
359 
360 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
361 &#32;&#32;&#32;&#32;&#32;&#32;operator==(<emphasis role="keyword">const</emphasis>&#32;_Node_iterator_base&amp;&#32;__x,&#32;<emphasis role="keyword">const</emphasis>&#32;_Node_iterator_base&amp;&#32;__y)
362 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>
363 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__x._M_cur&#32;==&#32;__y._M_cur;&#32;}
364 
365 <emphasis role="preprocessor">#if&#32;__cpp_impl_three_way_comparison&#32;&lt;&#32;201907L</emphasis>
366 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
367 &#32;&#32;&#32;&#32;&#32;&#32;operator!=(<emphasis role="keyword">const</emphasis>&#32;_Node_iterator_base&amp;&#32;__x,&#32;<emphasis role="keyword">const</emphasis>&#32;_Node_iterator_base&amp;&#32;__y)
368 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>
369 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__x._M_cur&#32;!=&#32;__y._M_cur;&#32;}
370 <emphasis role="preprocessor">#endif</emphasis>
371 &#32;&#32;&#32;&#32;};
372 
374 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__constant_iterators,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache&gt;
375 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Node_iterator
376 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Node_iterator_base&lt;_Value,&#32;__cache&gt;
377 &#32;&#32;&#32;&#32;{
378 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
379 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Node_iterator_base&lt;_Value,&#32;__cache&gt;;
380 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__node_type;
381 
382 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
383 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>value_type&#32;=&#32;_Value;
384 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>difference_type&#32;=&#32;std::ptrdiff_t;
385 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator_category&#32;=&#32;std::forward_iterator_tag;
386 
387 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>&#32;=&#32;__conditional_t&lt;__constant_iterators,
388 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;value_type*,&#32;value_type*&gt;;
389 
390 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>reference&#32;=&#32;__conditional_t&lt;__constant_iterators,
391 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;,&#32;value_type&amp;&gt;;
392 
393 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
394 
395 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">explicit</emphasis>
396 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator(__node_type*&#32;__p)&#32;noexcept
397 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__p)&#32;{&#32;}
398 
399 &#32;&#32;&#32;&#32;&#32;&#32;reference
400 &#32;&#32;&#32;&#32;&#32;&#32;operator*()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
401 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_v();&#32;}
402 
403 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>
404 &#32;&#32;&#32;&#32;&#32;&#32;operator-&gt;()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
405 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_valptr();&#32;}
406 
407 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator&amp;
408 &#32;&#32;&#32;&#32;&#32;&#32;operator++()&#32;<emphasis role="keyword">noexcept</emphasis>
409 &#32;&#32;&#32;&#32;&#32;&#32;{
410 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
411 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
412 &#32;&#32;&#32;&#32;&#32;&#32;}
413 
414 &#32;&#32;&#32;&#32;&#32;&#32;_Node_iterator
415 &#32;&#32;&#32;&#32;&#32;&#32;operator++(<emphasis role="keywordtype">int</emphasis>)&#32;<emphasis role="keyword">noexcept</emphasis>
416 &#32;&#32;&#32;&#32;&#32;&#32;{
417 &#32;&#32;&#32;&#32;_Node_iterator&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>(*<emphasis role="keyword">this</emphasis>);
418 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
419 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>;
420 &#32;&#32;&#32;&#32;&#32;&#32;}
421 &#32;&#32;&#32;&#32;};
422 
424 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__constant_iterators,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache&gt;
425 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Node_const_iterator
426 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Node_iterator_base&lt;_Value,&#32;__cache&gt;
427 &#32;&#32;&#32;&#32;{
428 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
429 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Node_iterator_base&lt;_Value,&#32;__cache&gt;;
430 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__node_type;
431 
432 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
433 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Value&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value_type;
434 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::ptrdiff_t&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;difference_type;
435 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::forward_iterator_tag&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;iterator_category;
436 
437 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;value_type*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>;
438 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reference;
439 
440 &#32;&#32;&#32;&#32;&#32;&#32;_Node_const_iterator()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
441 
442 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">explicit</emphasis>
443 &#32;&#32;&#32;&#32;&#32;&#32;_Node_const_iterator(__node_type*&#32;__p)&#32;noexcept
444 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__p)&#32;{&#32;}
445 
446 &#32;&#32;&#32;&#32;&#32;&#32;_Node_const_iterator(<emphasis role="keyword">const</emphasis>&#32;_Node_iterator&lt;_Value,&#32;__constant_iterators,
447 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__cache&gt;&amp;&#32;__x)&#32;noexcept
448 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__x._M_cur)&#32;{&#32;}
449 
450 &#32;&#32;&#32;&#32;&#32;&#32;reference
451 &#32;&#32;&#32;&#32;&#32;&#32;operator*()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
452 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_v();&#32;}
453 
454 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>
455 &#32;&#32;&#32;&#32;&#32;&#32;operator-&gt;()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
456 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_valptr();&#32;}
457 
458 &#32;&#32;&#32;&#32;&#32;&#32;_Node_const_iterator&amp;
459 &#32;&#32;&#32;&#32;&#32;&#32;operator++()&#32;<emphasis role="keyword">noexcept</emphasis>
460 &#32;&#32;&#32;&#32;&#32;&#32;{
461 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
462 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
463 &#32;&#32;&#32;&#32;&#32;&#32;}
464 
465 &#32;&#32;&#32;&#32;&#32;&#32;_Node_const_iterator
466 &#32;&#32;&#32;&#32;&#32;&#32;operator++(<emphasis role="keywordtype">int</emphasis>)&#32;<emphasis role="keyword">noexcept</emphasis>
467 &#32;&#32;&#32;&#32;&#32;&#32;{
468 &#32;&#32;&#32;&#32;_Node_const_iterator&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>(*<emphasis role="keyword">this</emphasis>);
469 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
470 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>;
471 &#32;&#32;&#32;&#32;&#32;&#32;}
472 &#32;&#32;&#32;&#32;};
473 
474 &#32;&#32;<emphasis role="comment">//&#32;Many&#32;of&#32;class&#32;template&#32;_Hashtable&apos;s&#32;template&#32;parameters&#32;are&#32;policy</emphasis>
475 &#32;&#32;<emphasis role="comment">//&#32;classes.&#32;&#32;These&#32;are&#32;defaults&#32;for&#32;the&#32;policies.</emphasis>
476 
479 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Mod_range_hashing
480 &#32;&#32;{
481 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;first_argument_type;
482 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;second_argument_type;
483 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;result_type;
484 
485 &#32;&#32;&#32;&#32;result_type
486 &#32;&#32;&#32;&#32;operator()(first_argument_type&#32;__num,
487 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;second_argument_type&#32;__den)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
488 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__num&#32;%&#32;__den;&#32;}
489 &#32;&#32;};
490 
496 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Default_ranged_hash&#32;{&#32;};
497 
500 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Prime_rehash_policy
501 &#32;&#32;{
502 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__has_load_factor&#32;=&#32;true_type;
503 
504 &#32;&#32;&#32;&#32;_Prime_rehash_policy(<emphasis role="keywordtype">float</emphasis>&#32;__z&#32;=&#32;1.0)&#32;noexcept
505 &#32;&#32;&#32;&#32;:&#32;_M_max_load_factor(__z),&#32;_M_next_resize(0)&#32;{&#32;}
506 
507 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>
508 &#32;&#32;&#32;&#32;max_load_factor()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
509 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_max_load_factor;&#32;}
510 
511 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Return&#32;a&#32;bucket&#32;size&#32;no&#32;smaller&#32;than&#32;n.</emphasis>
512 &#32;&#32;&#32;&#32;std::size_t
513 &#32;&#32;&#32;&#32;_M_next_bkt(std::size_t&#32;__n)&#32;<emphasis role="keyword">const</emphasis>;
514 
515 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Return&#32;a&#32;bucket&#32;count&#32;appropriate&#32;for&#32;n&#32;elements</emphasis>
516 &#32;&#32;&#32;&#32;std::size_t
517 &#32;&#32;&#32;&#32;_M_bkt_for_elements(std::size_t&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
518 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__builtin_ceil(__n&#32;/&#32;(<emphasis role="keywordtype">double</emphasis>)_M_max_load_factor);&#32;}
519 
520 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;__n_bkt&#32;is&#32;current&#32;bucket&#32;count,&#32;__n_elt&#32;is&#32;current&#32;element&#32;count,</emphasis>
521 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;and&#32;__n_ins&#32;is&#32;number&#32;of&#32;elements&#32;to&#32;be&#32;inserted.&#32;&#32;Do&#32;we&#32;need&#32;to</emphasis>
522 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;increase&#32;bucket&#32;count?&#32;&#32;If&#32;so,&#32;return&#32;make_pair(true,&#32;n),&#32;where&#32;n</emphasis>
523 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;is&#32;the&#32;new&#32;bucket&#32;count.&#32;&#32;If&#32;not,&#32;return&#32;make_pair(false,&#32;0).</emphasis>
524 &#32;&#32;&#32;&#32;std::pair&lt;bool,&#32;std::size_t&gt;
525 &#32;&#32;&#32;&#32;_M_need_rehash(std::size_t&#32;__n_bkt,&#32;std::size_t&#32;__n_elt,
526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__n_ins)&#32;<emphasis role="keyword">const</emphasis>;
527 
528 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;_State;
529 
530 &#32;&#32;&#32;&#32;_State
531 &#32;&#32;&#32;&#32;_M_state()<emphasis role="keyword">&#32;const</emphasis>
532 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_next_resize;&#32;}
533 
534 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
535 &#32;&#32;&#32;&#32;_M_reset()&#32;<emphasis role="keyword">noexcept</emphasis>
536 &#32;&#32;&#32;&#32;{&#32;_M_next_resize&#32;=&#32;0;&#32;}
537 
538 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
539 &#32;&#32;&#32;&#32;_M_reset(_State&#32;__state)
540 &#32;&#32;&#32;&#32;{&#32;_M_next_resize&#32;=&#32;__state;&#32;}
541 
542 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;std::size_t&#32;_S_growth_factor&#32;=&#32;2;
543 
544 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_max_load_factor;
545 &#32;&#32;&#32;&#32;<emphasis role="keyword">mutable</emphasis>&#32;std::size_t&#32;_M_next_resize;
546 &#32;&#32;};
547 
549 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Mask_range_hashing
550 &#32;&#32;{
551 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;first_argument_type;
552 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;second_argument_type;
553 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;result_type;
554 
555 &#32;&#32;&#32;&#32;result_type
556 &#32;&#32;&#32;&#32;operator()(first_argument_type&#32;__num,
557 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;second_argument_type&#32;__den)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
558 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__num&#32;&amp;&#32;(__den&#32;-&#32;1);&#32;}
559 &#32;&#32;};
560 
562 &#32;&#32;<emphasis role="keyword">inline</emphasis>&#32;std::size_t
563 &#32;&#32;__clp2(std::size_t&#32;__n)&#32;<emphasis role="keyword">noexcept</emphasis>
564 &#32;&#32;{
565 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__gnu_cxx::__int_traits;
566 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Equivalent&#32;to&#32;return&#32;__n&#32;?&#32;std::bit_ceil(__n)&#32;:&#32;0;</emphasis>
567 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n&#32;&lt;&#32;2)
568 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__n;
569 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">unsigned</emphasis>&#32;__lz&#32;=&#32;<emphasis role="keyword">sizeof</emphasis>(<link linkend="__classes_2lib_2include_2stddef_8h_1aa9d55e2f20e580b7445617d0d12fff6e">size_t</link>)&#32;&gt;&#32;<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">long</emphasis>)
570 &#32;&#32;&#32;&#32;&#32;&#32;?&#32;__builtin_clzll(__n&#32;-&#32;1ull)
571 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__builtin_clzl(__n&#32;-&#32;1ul);
572 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Doing&#32;two&#32;shifts&#32;avoids&#32;undefined&#32;behaviour&#32;when&#32;__lz&#32;==&#32;0.</emphasis>
573 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>(1)&#32;&lt;&lt;&#32;(__int_traits&lt;size_t&gt;::__digits&#32;-&#32;__lz&#32;-&#32;1))&#32;&lt;&lt;&#32;1;
574 &#32;&#32;}
575 
578 &#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Power2_rehash_policy
579 &#32;&#32;{
580 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__has_load_factor&#32;=&#32;true_type;
581 
582 &#32;&#32;&#32;&#32;_Power2_rehash_policy(<emphasis role="keywordtype">float</emphasis>&#32;__z&#32;=&#32;1.0)&#32;noexcept
583 &#32;&#32;&#32;&#32;:&#32;_M_max_load_factor(__z),&#32;_M_next_resize(0)&#32;{&#32;}
584 
585 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>
586 &#32;&#32;&#32;&#32;max_load_factor()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
587 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_max_load_factor;&#32;}
588 
589 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Return&#32;a&#32;bucket&#32;size&#32;no&#32;smaller&#32;than&#32;n&#32;(as&#32;long&#32;as&#32;n&#32;is&#32;not&#32;above&#32;the</emphasis>
590 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;highest&#32;power&#32;of&#32;2).</emphasis>
591 &#32;&#32;&#32;&#32;std::size_t
592 &#32;&#32;&#32;&#32;_M_next_bkt(std::size_t&#32;__n)&#32;<emphasis role="keyword">noexcept</emphasis>
593 &#32;&#32;&#32;&#32;{
594 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n&#32;==&#32;0)
595 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Special&#32;case&#32;on&#32;container&#32;1st&#32;initialization&#32;with&#32;0&#32;bucket&#32;count</emphasis>
596 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;hint.&#32;We&#32;keep&#32;_M_next_resize&#32;to&#32;0&#32;to&#32;make&#32;sure&#32;that&#32;next&#32;time&#32;we</emphasis>
597 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;want&#32;to&#32;add&#32;an&#32;element&#32;allocation&#32;will&#32;take&#32;place.</emphasis>
598 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;1;
599 
600 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;__max_width&#32;=&#32;std::min&lt;size_t&gt;(<emphasis role="keyword">sizeof</emphasis>(<emphasis role="keywordtype">size_t</emphasis>),&#32;8);
601 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;__max_bkt&#32;=&#32;<link linkend="__classes_2lib_2include_2stddef_8h_1aa9d55e2f20e580b7445617d0d12fff6e">size_t</link>(1)&#32;&lt;&lt;&#32;(__max_width&#32;*&#32;__CHAR_BIT__&#32;-&#32;1);
602 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__res&#32;=&#32;__clp2(__n);
603 
604 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__res&#32;==&#32;0)
605 &#32;&#32;&#32;&#32;__res&#32;=&#32;__max_bkt;
606 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__res&#32;==&#32;1)
607 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;If&#32;__res&#32;is&#32;1&#32;we&#32;force&#32;it&#32;to&#32;2&#32;to&#32;make&#32;sure&#32;there&#32;will&#32;be&#32;an</emphasis>
608 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;allocation&#32;so&#32;that&#32;nothing&#32;need&#32;to&#32;be&#32;stored&#32;in&#32;the&#32;initial</emphasis>
609 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;single&#32;bucket</emphasis>
610 &#32;&#32;&#32;&#32;__res&#32;=&#32;2;
611 
612 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__res&#32;==&#32;__max_bkt)
613 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Set&#32;next&#32;resize&#32;to&#32;the&#32;max&#32;value&#32;so&#32;that&#32;we&#32;never&#32;try&#32;to&#32;rehash&#32;again</emphasis>
614 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;as&#32;we&#32;already&#32;reach&#32;the&#32;biggest&#32;possible&#32;bucket&#32;number.</emphasis>
615 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Note&#32;that&#32;it&#32;might&#32;result&#32;in&#32;max_load_factor&#32;not&#32;being&#32;respected.</emphasis>
616 &#32;&#32;&#32;&#32;_M_next_resize&#32;=&#32;<link linkend="__classes_2lib_2include_2stddef_8h_1aa9d55e2f20e580b7445617d0d12fff6e">size_t</link>(-1);
617 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
618 &#32;&#32;&#32;&#32;_M_next_resize
619 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;__builtin_floor(__res&#32;*&#32;(<emphasis role="keywordtype">double</emphasis>)_M_max_load_factor);
620 
621 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__res;
622 &#32;&#32;&#32;&#32;}
623 
624 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Return&#32;a&#32;bucket&#32;count&#32;appropriate&#32;for&#32;n&#32;elements</emphasis>
625 &#32;&#32;&#32;&#32;std::size_t
626 &#32;&#32;&#32;&#32;_M_bkt_for_elements(std::size_t&#32;__n)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
627 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__builtin_ceil(__n&#32;/&#32;(<emphasis role="keywordtype">double</emphasis>)_M_max_load_factor);&#32;}
628 
629 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;__n_bkt&#32;is&#32;current&#32;bucket&#32;count,&#32;__n_elt&#32;is&#32;current&#32;element&#32;count,</emphasis>
630 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;and&#32;__n_ins&#32;is&#32;number&#32;of&#32;elements&#32;to&#32;be&#32;inserted.&#32;&#32;Do&#32;we&#32;need&#32;to</emphasis>
631 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;increase&#32;bucket&#32;count?&#32;&#32;If&#32;so,&#32;return&#32;make_pair(true,&#32;n),&#32;where&#32;n</emphasis>
632 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;is&#32;the&#32;new&#32;bucket&#32;count.&#32;&#32;If&#32;not,&#32;return&#32;make_pair(false,&#32;0).</emphasis>
633 &#32;&#32;&#32;&#32;std::pair&lt;bool,&#32;std::size_t&gt;
634 &#32;&#32;&#32;&#32;_M_need_rehash(std::size_t&#32;__n_bkt,&#32;std::size_t&#32;__n_elt,
635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__n_ins)&#32;<emphasis role="keyword">noexcept</emphasis>
636 &#32;&#32;&#32;&#32;{
637 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n_elt&#32;+&#32;__n_ins&#32;&gt;&#32;_M_next_resize)
638 &#32;&#32;&#32;&#32;{
639 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;If&#32;_M_next_resize&#32;is&#32;0&#32;it&#32;means&#32;that&#32;we&#32;have&#32;nothing&#32;allocated&#32;so</emphasis>
640 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;far&#32;and&#32;that&#32;we&#32;start&#32;inserting&#32;elements.&#32;In&#32;this&#32;case&#32;we&#32;start</emphasis>
641 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;with&#32;an&#32;initial&#32;bucket&#32;size&#32;of&#32;11.</emphasis>
642 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;__min_bkts
643 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;std::max&lt;std::size_t&gt;(__n_elt&#32;+&#32;__n_ins,&#32;_M_next_resize&#32;?&#32;0&#32;:&#32;11)
644 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;/&#32;(<emphasis role="keywordtype">double</emphasis>)_M_max_load_factor;
645 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__min_bkts&#32;&gt;=&#32;__n_bkt)
646 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;<emphasis role="keyword">true</emphasis>,
647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_next_bkt(std::max&lt;std::size_t&gt;(__builtin_floor(__min_bkts)&#32;+&#32;1,
648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n_bkt&#32;*&#32;_S_growth_factor))&#32;};
649 
650 &#32;&#32;&#32;&#32;&#32;&#32;_M_next_resize
651 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__builtin_floor(__n_bkt&#32;*&#32;(<emphasis role="keywordtype">double</emphasis>)_M_max_load_factor);
652 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;<emphasis role="keyword">false</emphasis>,&#32;0&#32;};
653 &#32;&#32;&#32;&#32;}
654 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
655 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;<emphasis role="keyword">false</emphasis>,&#32;0&#32;};
656 &#32;&#32;&#32;&#32;}
657 
658 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;_State;
659 
660 &#32;&#32;&#32;&#32;_State
661 &#32;&#32;&#32;&#32;_M_state()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
662 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_next_resize;&#32;}
663 
664 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
665 &#32;&#32;&#32;&#32;_M_reset()&#32;<emphasis role="keyword">noexcept</emphasis>
666 &#32;&#32;&#32;&#32;{&#32;_M_next_resize&#32;=&#32;0;&#32;}
667 
668 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
669 &#32;&#32;&#32;&#32;_M_reset(_State&#32;__state)&#32;<emphasis role="keyword">noexcept</emphasis>
670 &#32;&#32;&#32;&#32;{&#32;_M_next_resize&#32;=&#32;__state;&#32;}
671 
672 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;std::size_t&#32;_S_growth_factor&#32;=&#32;2;
673 
674 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>&#32;&#32;&#32;_M_max_load_factor;
675 &#32;&#32;&#32;&#32;std::size_t&#32;_M_next_resize;
676 &#32;&#32;};
677 
678 &#32;&#32;<emphasis role="comment">//&#32;Base&#32;classes&#32;for&#32;std::_Hashtable.&#32;&#32;We&#32;define&#32;these&#32;base&#32;classes</emphasis>
679 &#32;&#32;<emphasis role="comment">//&#32;because&#32;in&#32;some&#32;cases&#32;we&#32;want&#32;to&#32;do&#32;different&#32;things&#32;depending&#32;on</emphasis>
680 &#32;&#32;<emphasis role="comment">//&#32;the&#32;value&#32;of&#32;a&#32;policy&#32;class.&#32;&#32;In&#32;some&#32;cases&#32;the&#32;policy&#32;class</emphasis>
681 &#32;&#32;<emphasis role="comment">//&#32;affects&#32;which&#32;member&#32;functions&#32;and&#32;nested&#32;typedefs&#32;are&#32;defined;</emphasis>
682 &#32;&#32;<emphasis role="comment">//&#32;we&#32;handle&#32;that&#32;by&#32;specializing&#32;base&#32;class&#32;templates.&#32;&#32;Several&#32;of</emphasis>
683 &#32;&#32;<emphasis role="comment">//&#32;the&#32;base&#32;class&#32;templates&#32;need&#32;to&#32;access&#32;other&#32;members&#32;of&#32;class</emphasis>
684 &#32;&#32;<emphasis role="comment">//&#32;template&#32;_Hashtable,&#32;so&#32;we&#32;use&#32;a&#32;variant&#32;of&#32;the&#32;&quot;Curiously</emphasis>
685 &#32;&#32;<emphasis role="comment">//&#32;Recurring&#32;Template&#32;Pattern&quot;&#32;(CRTP)&#32;technique.</emphasis>
686 
696 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
697 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
698 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
699 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits,
700 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Unique_keys&#32;=&#32;_Traits::__unique_keys::value&gt;
701 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Map_base&#32;{&#32;};
702 
704 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
705 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
707 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Map_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,&#32;_Select1st,&#32;_Equal,
708 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;
709 &#32;&#32;&#32;&#32;{
710 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>mapped_type&#32;=&#32;_Val;
711 &#32;&#32;&#32;&#32;};
712 
714 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
715 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
716 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
717 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Map_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,&#32;_Select1st,&#32;_Equal,
718 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
719 &#32;&#32;&#32;&#32;{
720 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
721 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_base&#32;=&#32;_Hashtable_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,
722 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Select1st,&#32;_Equal,&#32;_Hash,
723 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RangeHash,&#32;_Unused,
724 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Traits&gt;;
725 
726 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;_Hashtable&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,
727 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Select1st,&#32;_Equal,&#32;_Hash,&#32;_RangeHash,
728 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;;
729 
730 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::__hash_code;
731 
732 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
733 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>key_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::key_type;
734 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>mapped_type&#32;=&#32;_Val;
735 
736 &#32;&#32;&#32;&#32;&#32;&#32;mapped_type&amp;
737 &#32;&#32;&#32;&#32;&#32;&#32;operator[](<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k);
738 
739 &#32;&#32;&#32;&#32;&#32;&#32;mapped_type&amp;
740 &#32;&#32;&#32;&#32;&#32;&#32;operator[](key_type&amp;&amp;&#32;__k);
741 
742 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_GLIBCXX_RESOLVE_LIB_DEFECTS</emphasis>
743 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;DR&#32;761.&#32;unordered_map&#32;needs&#32;an&#32;at()&#32;member&#32;function.</emphasis>
744 &#32;&#32;&#32;&#32;&#32;&#32;mapped_type&amp;
745 &#32;&#32;&#32;&#32;&#32;&#32;at(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
746 &#32;&#32;&#32;&#32;&#32;&#32;{
747 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ite&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>)-&gt;<link linkend="_toml_8hpp_1a334e40fb57f310a5de10f332f1914bf4">find</link>(__k);
748 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ite._M_cur)
749 &#32;&#32;&#32;&#32;&#32;&#32;__throw_out_of_range(<link linkend="__classes_2lib_2include_2c_09_09_2x86__64-w64-mingw32_2bits_2c_09_09config_8h_1ad90b1fa000da1666f104c4dd9c0d7f9b">__N</link>(<emphasis role="stringliteral">&quot;unordered_map::at&quot;</emphasis>));
750 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ite-&gt;second;
751 &#32;&#32;&#32;&#32;&#32;&#32;}
752 
753 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;mapped_type&amp;
754 &#32;&#32;&#32;&#32;&#32;&#32;at(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)<emphasis role="keyword">&#32;const</emphasis>
755 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
756 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ite&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>)-&gt;<link linkend="_toml_8hpp_1a334e40fb57f310a5de10f332f1914bf4">find</link>(__k);
757 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ite._M_cur)
758 &#32;&#32;&#32;&#32;&#32;&#32;__throw_out_of_range(<link linkend="__classes_2lib_2include_2c_09_09_2x86__64-w64-mingw32_2bits_2c_09_09config_8h_1ad90b1fa000da1666f104c4dd9c0d7f9b">__N</link>(<emphasis role="stringliteral">&quot;unordered_map::at&quot;</emphasis>));
759 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ite-&gt;second;
760 &#32;&#32;&#32;&#32;&#32;&#32;}
761 &#32;&#32;&#32;&#32;};
762 
763 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
764 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
765 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
766 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
767 &#32;&#32;&#32;&#32;_Map_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,&#32;_Select1st,&#32;_Equal,
768 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<emphasis role="keyword">true</emphasis>&gt;::
769 &#32;&#32;&#32;&#32;operator[](<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
770 &#32;&#32;&#32;&#32;-&gt;&#32;mapped_type&amp;
771 &#32;&#32;&#32;&#32;{
772 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable*&#32;__h&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
773 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;__h-&gt;_M_hash_code(__k);
774 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;__h-&gt;_M_bucket_index(__code);
775 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__node&#32;=&#32;__h-&gt;_M_find_node(__bkt,&#32;__k,&#32;__code))
776 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node-&gt;_M_v().second;
777 
778 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::_Scoped_node&#32;__node&#32;{
779 &#32;&#32;&#32;&#32;__h,
780 &#32;&#32;&#32;&#32;std::piecewise_construct,
781 &#32;&#32;&#32;&#32;std::tuple&lt;const&#32;key_type&amp;&gt;(__k),
782 &#32;&#32;&#32;&#32;std::tuple&lt;&gt;()
783 &#32;&#32;&#32;&#32;&#32;&#32;};
784 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos
785 &#32;&#32;&#32;&#32;=&#32;__h-&gt;_M_insert_unique_node(__bkt,&#32;__code,&#32;__node._M_node);
786 &#32;&#32;&#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
787 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__pos-&gt;second;
788 &#32;&#32;&#32;&#32;}
789 
790 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
791 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
792 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
793 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
794 &#32;&#32;&#32;&#32;_Map_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,&#32;_Select1st,&#32;_Equal,
795 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<emphasis role="keyword">true</emphasis>&gt;::
796 &#32;&#32;&#32;&#32;operator[](key_type&amp;&amp;&#32;__k)
797 &#32;&#32;&#32;&#32;-&gt;&#32;mapped_type&amp;
798 &#32;&#32;&#32;&#32;{
799 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable*&#32;__h&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
800 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;__h-&gt;_M_hash_code(__k);
801 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;__h-&gt;_M_bucket_index(__code);
802 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__node&#32;=&#32;__h-&gt;_M_find_node(__bkt,&#32;__k,&#32;__code))
803 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node-&gt;_M_v().second;
804 
805 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::_Scoped_node&#32;__node&#32;{
806 &#32;&#32;&#32;&#32;__h,
807 &#32;&#32;&#32;&#32;std::piecewise_construct,
808 &#32;&#32;&#32;&#32;std::forward_as_tuple(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__k)),
809 &#32;&#32;&#32;&#32;std::tuple&lt;&gt;()
810 &#32;&#32;&#32;&#32;&#32;&#32;};
811 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos
812 &#32;&#32;&#32;&#32;=&#32;__h-&gt;_M_insert_unique_node(__bkt,&#32;__code,&#32;__node._M_node);
813 &#32;&#32;&#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
814 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__pos-&gt;second;
815 &#32;&#32;&#32;&#32;}
816 
817 &#32;&#32;<emphasis role="comment">//&#32;Partial&#32;specialization&#32;for&#32;unordered_map&lt;const&#32;T,&#32;U&gt;,&#32;see&#32;PR&#32;104174.</emphasis>
818 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
819 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
820 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__uniq&gt;
821 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Map_base&lt;const&#32;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,
822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Alloc,&#32;_Select1st,&#32;_Equal,&#32;_Hash,
823 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;__uniq&gt;
824 &#32;&#32;&#32;&#32;:&#32;_Map_base&lt;_Key,&#32;pair&lt;const&#32;_Key,&#32;_Val&gt;,&#32;_Alloc,&#32;_Select1st,&#32;_Equal,&#32;_Hash,
825 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;__uniq&gt;
826 &#32;&#32;&#32;&#32;{&#32;};
827 
833 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
834 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
835 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
836 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
837 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Insert_base
838 &#32;&#32;&#32;&#32;{
839 &#32;&#32;&#32;&#32;<emphasis role="keyword">protected</emphasis>:
840 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_base&#32;=&#32;_Hashtable_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
841 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,
842 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Unused,&#32;_Traits&gt;;
843 
844 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
845 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,
846 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;;
847 
848 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_cached&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits::__hash_cached;
849 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__constant_iterators&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits::__constant_iterators;
850 
851 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_alloc&#32;=&#32;_Hashtable_alloc&lt;
852 &#32;&#32;&#32;&#32;__alloc_rebind&lt;_Alloc,&#32;_Hash_node&lt;_Value,
853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;&gt;&gt;;
854 
855 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>value_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::value_type;
856 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>size_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::size_type;
857 
858 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__unique_keys&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits::__unique_keys;
859 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_alloc_type;
860 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_gen_type&#32;=&#32;_AllocNode&lt;__node_alloc_type&gt;;
861 
862 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable&amp;
863 &#32;&#32;&#32;&#32;&#32;&#32;_M_conjure_hashtable()
864 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;*(<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>));&#32;}
865 
866 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGetter&gt;
867 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
868 &#32;&#32;&#32;&#32;_M_insert_range(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
869 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGetter&amp;,&#32;true_type&#32;__uks);
870 
871 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGetter&gt;
872 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
873 &#32;&#32;&#32;&#32;_M_insert_range(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
874 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGetter&amp;,&#32;false_type&#32;__uks);
875 
876 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
877 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator&#32;=&#32;_Node_iterator&lt;_Value,&#32;__constant_iterators::value,
878 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;;
879 
880 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>const_iterator&#32;=&#32;_Node_const_iterator&lt;_Value,
881 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__constant_iterators::value,
882 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;;
883 
884 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ireturn_type&#32;=&#32;__conditional_t&lt;__unique_keys::value,
885 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;bool&gt;,
886 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;iterator&gt;;
887 
888 &#32;&#32;&#32;&#32;&#32;&#32;__ireturn_type
889 &#32;&#32;&#32;&#32;&#32;&#32;insert(<emphasis role="keyword">const</emphasis>&#32;value_type&amp;&#32;__v)
890 &#32;&#32;&#32;&#32;&#32;&#32;{
891 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
892 &#32;&#32;&#32;&#32;__node_gen_type&#32;__node_gen(__h);
893 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_insert(__v,&#32;__node_gen,&#32;__unique_keys{});
894 &#32;&#32;&#32;&#32;&#32;&#32;}
895 
896 &#32;&#32;&#32;&#32;&#32;&#32;iterator
897 &#32;&#32;&#32;&#32;&#32;&#32;insert(const_iterator&#32;__hint,&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;&#32;__v)
898 &#32;&#32;&#32;&#32;&#32;&#32;{
899 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
900 &#32;&#32;&#32;&#32;__node_gen_type&#32;__node_gen(__h);&#32;&#32;&#32;&#32;
901 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_insert(__hint,&#32;__v,&#32;__node_gen,&#32;__unique_keys{});
902 &#32;&#32;&#32;&#32;&#32;&#32;}
903 
904 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_KType,&#32;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
905 &#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;bool&gt;
906 &#32;&#32;&#32;&#32;try_emplace(const_iterator,&#32;_KType&amp;&amp;&#32;__k,&#32;_Args&amp;&amp;...&#32;__args)
907 &#32;&#32;&#32;&#32;{
908 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
909 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__code&#32;=&#32;__h._M_hash_code(__k);
910 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;__h._M_bucket_index(__code);
911 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__node&#32;=&#32;__h._M_find_node(__bkt,&#32;__k,&#32;__code))
912 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;iterator(__node),&#32;<emphasis role="keyword">false</emphasis>&#32;};
913 
914 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::_Scoped_node&#32;__node&#32;{
915 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;__h,
916 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::piecewise_construct,
917 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward_as_tuple(std::forward&lt;_KType&gt;(__k)),
918 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward_as_tuple(std::forward&lt;_Args&gt;(__args)...)
919 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;};
920 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__it
921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__h._M_insert_unique_node(__bkt,&#32;__code,&#32;__node._M_node);
922 &#32;&#32;&#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
923 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__it,&#32;<emphasis role="keyword">true</emphasis>&#32;};
924 &#32;&#32;&#32;&#32;}
925 
926 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
927 &#32;&#32;&#32;&#32;&#32;&#32;insert(initializer_list&lt;value_type&gt;&#32;__l)
928 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;this-&gt;insert(__l.begin(),&#32;__l.end());&#32;}
929 
930 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
931 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
932 &#32;&#32;&#32;&#32;insert(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last)
933 &#32;&#32;&#32;&#32;{
934 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
935 &#32;&#32;&#32;&#32;&#32;&#32;__node_gen_type&#32;__node_gen(__h);
936 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_insert_range(__first,&#32;__last,&#32;__node_gen,&#32;__unique_keys{});
937 &#32;&#32;&#32;&#32;}
938 &#32;&#32;&#32;&#32;};
939 
940 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
942 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
943 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
944 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGetter&gt;
945 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
946 &#32;&#32;&#32;&#32;&#32;&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
947 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
948 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;::
949 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_range(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
950 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGetter&amp;&#32;__node_gen,&#32;true_type&#32;__uks)
951 &#32;&#32;&#32;&#32;&#32;&#32;{
952 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
953 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;&#32;__first&#32;!=&#32;__last;&#32;++__first)
954 &#32;&#32;&#32;&#32;&#32;&#32;__h._M_insert(*__first,&#32;__node_gen,&#32;__uks);
955 &#32;&#32;&#32;&#32;&#32;&#32;}
956 
957 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
958 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
959 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
960 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
961 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGetter&gt;
962 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
963 &#32;&#32;&#32;&#32;&#32;&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
964 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
965 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;::
966 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_range(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
967 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGetter&amp;&#32;__node_gen,&#32;false_type&#32;__uks)
968 &#32;&#32;&#32;&#32;&#32;&#32;{
969 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__rehash_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::__rehash_type;
970 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__rehash_state&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::__rehash_state;
971 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>pair_type&#32;=&#32;std::pair&lt;bool,&#32;std::size_t&gt;;
972 
973 &#32;&#32;&#32;&#32;size_type&#32;__n_elt&#32;=&#32;__detail::__distance_fw(__first,&#32;__last);
974 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n_elt&#32;==&#32;0)
975 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
976 
977 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;_M_conjure_hashtable();
978 &#32;&#32;&#32;&#32;__rehash_type&amp;&#32;__rehash&#32;=&#32;__h._M_rehash_policy;
979 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__saved_state&#32;=&#32;__rehash._M_state();
980 &#32;&#32;&#32;&#32;pair_type&#32;__do_rehash&#32;=&#32;__rehash._M_need_rehash(__h._M_bucket_count,
981 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__h._M_element_count,
982 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n_elt);
983 
984 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__do_rehash.first)
985 &#32;&#32;&#32;&#32;&#32;&#32;__h._M_rehash(__do_rehash.second,&#32;__saved_state);
986 
987 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;&#32;__first&#32;!=&#32;__last;&#32;++__first)
988 &#32;&#32;&#32;&#32;&#32;&#32;__h._M_insert(*__first,&#32;__node_gen,&#32;__uks);
989 &#32;&#32;&#32;&#32;&#32;&#32;}
990 
997 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
998 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
999 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1000 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits,
1001 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Constant_iterators&#32;=&#32;_Traits::__constant_iterators::value&gt;
1002 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Insert;
1003 
1005 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1007 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1008 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1009 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Insert&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1010 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1011 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
1012 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;
1014 &#32;&#32;&#32;&#32;{
1015 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
1016 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
1018 
1019 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>value_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::value_type;
1020 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::iterator;
1021 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>const_iterator&#32;=&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::const_iterator;
1022 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ireturn_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__ireturn_type;
1023 
1024 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__unique_keys&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__unique_keys;
1025 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__hashtable;
1026 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_gen_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__node_gen_type;
1027 
1028 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type::insert;
1029 
1030 &#32;&#32;&#32;&#32;&#32;&#32;__ireturn_type
1031 &#32;&#32;&#32;&#32;&#32;&#32;insert(value_type&amp;&amp;&#32;__v)
1032 &#32;&#32;&#32;&#32;&#32;&#32;{
1033 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;this-&gt;_M_conjure_hashtable();
1034 &#32;&#32;&#32;&#32;__node_gen_type&#32;__node_gen(__h);
1035 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_insert(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__v),&#32;__node_gen,&#32;__unique_keys{});
1036 &#32;&#32;&#32;&#32;&#32;&#32;}
1037 
1038 &#32;&#32;&#32;&#32;&#32;&#32;iterator
1039 &#32;&#32;&#32;&#32;&#32;&#32;insert(const_iterator&#32;__hint,&#32;value_type&amp;&amp;&#32;__v)
1040 &#32;&#32;&#32;&#32;&#32;&#32;{
1041 &#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;this-&gt;_M_conjure_hashtable();
1042 &#32;&#32;&#32;&#32;__node_gen_type&#32;__node_gen(__h);
1043 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_insert(__hint,&#32;<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__v),&#32;__node_gen,
1044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__unique_keys{});
1045 &#32;&#32;&#32;&#32;&#32;&#32;}
1046 &#32;&#32;&#32;&#32;};
1047 
1049 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1050 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1051 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1052 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1053 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Insert&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;
1055 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1056 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;
1057 &#32;&#32;&#32;&#32;{
1058 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Insert_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
1059 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1060 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
1061 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>value_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::value_type;
1062 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::iterator;
1063 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>const_iterator&#32;=&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::const_iterator;
1064 
1065 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__unique_keys&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__unique_keys;
1066 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__hashtable;
1067 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ireturn_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__ireturn_type;
1068 
1069 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type::insert;
1070 
1071 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair&gt;
1072 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__is_cons&#32;=&#32;std::is_constructible&lt;value_type,&#32;_Pair&amp;&amp;&gt;;
1073 
1074 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair&gt;
1075 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_IFcons&#32;=&#32;std::enable_if&lt;__is_cons&lt;_Pair&gt;::value&gt;;
1076 
1077 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair&gt;
1078 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_IFconsp&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_IFcons&lt;_Pair&gt;::type;
1079 
1080 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair,&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;_IFconsp&lt;_Pair&gt;&gt;
1081 &#32;&#32;&#32;&#32;__ireturn_type
1082 &#32;&#32;&#32;&#32;insert(_Pair&amp;&amp;&#32;__v)
1083 &#32;&#32;&#32;&#32;{
1084 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;this-&gt;_M_conjure_hashtable();
1085 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_emplace(__unique_keys{},&#32;std::forward&lt;_Pair&gt;(__v));
1086 &#32;&#32;&#32;&#32;}
1087 
1088 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Pair,&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;_IFconsp&lt;_Pair&gt;&gt;
1089 &#32;&#32;&#32;&#32;iterator
1090 &#32;&#32;&#32;&#32;insert(const_iterator&#32;__hint,&#32;_Pair&amp;&amp;&#32;__v)
1091 &#32;&#32;&#32;&#32;{
1092 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable&amp;&#32;__h&#32;=&#32;this-&gt;_M_conjure_hashtable();
1093 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__h._M_emplace(__hint,&#32;__unique_keys{},
1094 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Pair&gt;(__v));
1095 &#32;&#32;&#32;&#32;}
1096 &#32;&#32;&#32;};
1097 
1098 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Policy&gt;
1099 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__has_load_factor&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_Policy::__has_load_factor;
1100 
1107 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1108 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1109 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1110 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits,
1111 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=
1112 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__detected_or_t&lt;false_type,&#32;__has_load_factor,&#32;_RehashPolicy&gt;&gt;
1113 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Rehash_base;
1114 
1116 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1117 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1118 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1119 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1120 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Rehash_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1121 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,
1122 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;<emphasis role="comment">/*&#32;Has&#32;load&#32;factor&#32;*/</emphasis>&gt;
1123 &#32;&#32;&#32;&#32;{
1124 &#32;&#32;&#32;&#32;};
1125 
1127 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1128 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1129 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1131 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Rehash_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1132 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,
1133 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type&#32;<emphasis role="comment">/*&#32;Has&#32;load&#32;factor&#32;*/</emphasis>&gt;
1134 &#32;&#32;&#32;&#32;{
1135 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1136 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
1137 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
1139 
1140 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1141 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>
1142 &#32;&#32;&#32;&#32;&#32;&#32;max_load_factor()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
1143 &#32;&#32;&#32;&#32;&#32;&#32;{
1144 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__hashtable*&#32;__this&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
1145 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__this-&gt;__rehash_policy().max_load_factor();
1146 &#32;&#32;&#32;&#32;&#32;&#32;}
1147 
1148 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1149 &#32;&#32;&#32;&#32;&#32;&#32;max_load_factor(<emphasis role="keywordtype">float</emphasis>&#32;__z)
1150 &#32;&#32;&#32;&#32;&#32;&#32;{
1151 &#32;&#32;&#32;&#32;__hashtable*&#32;__this&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
1152 &#32;&#32;&#32;&#32;__this-&gt;__rehash_policy(_RehashPolicy(__z));
1153 &#32;&#32;&#32;&#32;&#32;&#32;}
1154 
1155 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1156 &#32;&#32;&#32;&#32;&#32;&#32;reserve(std::size_t&#32;__n)
1157 &#32;&#32;&#32;&#32;&#32;&#32;{
1158 &#32;&#32;&#32;&#32;__hashtable*&#32;__this&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
1159 &#32;&#32;&#32;&#32;__this-&gt;rehash(__this-&gt;__rehash_policy()._M_bkt_for_elements(__n));
1160 &#32;&#32;&#32;&#32;&#32;&#32;}
1161 &#32;&#32;&#32;&#32;};
1162 
1169 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">int</emphasis>&#32;_Nm,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Tp,
1170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__use_ebo&#32;=&#32;!__is_final(_Tp)&#32;&amp;&amp;&#32;__is_empty(_Tp)&gt;
1171 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_ebo_helper;
1172 
1174 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">int</emphasis>&#32;_Nm,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1175 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_ebo_helper&lt;_Nm,&#32;_Tp,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
1176 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">private</emphasis>&#32;_Tp
1177 &#32;&#32;&#32;&#32;{
1178 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_ebo_helper()&#32;<emphasis role="keyword">noexcept</emphasis>(<emphasis role="keyword">noexcept</emphasis>(_Tp()))&#32;:&#32;_Tp()&#32;{&#32;}
1179 
1180 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_OtherTp&gt;
1181 &#32;&#32;&#32;&#32;_Hashtable_ebo_helper(_OtherTp&amp;&amp;&#32;__tp)
1182 &#32;&#32;&#32;&#32;:&#32;_Tp(std::forward&lt;_OtherTp&gt;(__tp))
1183 &#32;&#32;&#32;&#32;{&#32;}
1184 
1185 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&amp;&#32;_M_cget()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>_Tp&amp;<emphasis role="keyword">&gt;</emphasis>(*this);&#32;}
1186 &#32;&#32;&#32;&#32;&#32;&#32;_Tp&amp;&#32;_M_get()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>_Tp&amp;<emphasis role="keyword">&gt;</emphasis>(*this);&#32;}
1187 &#32;&#32;&#32;&#32;};
1188 
1190 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">int</emphasis>&#32;_Nm,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1191 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_ebo_helper&lt;_Nm,&#32;_Tp,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;
1192 &#32;&#32;&#32;&#32;{
1193 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_ebo_helper()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1194 
1195 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_OtherTp&gt;
1196 &#32;&#32;&#32;&#32;_Hashtable_ebo_helper(_OtherTp&amp;&amp;&#32;__tp)
1197 &#32;&#32;&#32;&#32;:&#32;_M_tp(std::forward&lt;_OtherTp&gt;(__tp))
1198 &#32;&#32;&#32;&#32;{&#32;}
1199 
1200 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp&amp;&#32;_M_cget()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_tp;&#32;}
1201 &#32;&#32;&#32;&#32;&#32;&#32;_Tp&amp;&#32;_M_get()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_tp;&#32;}
1202 
1203 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1204 &#32;&#32;&#32;&#32;&#32;&#32;_Tp&#32;_M_tp{};
1205 &#32;&#32;&#32;&#32;};
1206 
1213 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1214 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1215 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache_hash_code&gt;
1216 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_iterator_base;
1217 
1236 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1237 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1238 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache_hash_code&gt;
1239 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_code_base
1240 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">private</emphasis>&#32;_Hashtable_ebo_helper&lt;1,&#32;_Hash&gt;
1241 &#32;&#32;&#32;&#32;{
1242 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1243 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ebo_hash&#32;=&#32;_Hashtable_ebo_helper&lt;1,&#32;_Hash&gt;;
1244 
1245 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Gives&#32;the&#32;local&#32;iterator&#32;implementation&#32;access&#32;to&#32;_M_bucket_index().</emphasis>
1246 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1247 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;;
1248 
1249 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1250 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Hash&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;hasher;
1251 
1252 &#32;&#32;&#32;&#32;&#32;&#32;hasher
1253 &#32;&#32;&#32;&#32;&#32;&#32;hash_function()<emphasis role="keyword">&#32;const</emphasis>
1254 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_hash();&#32;}
1255 
1256 &#32;&#32;&#32;&#32;<emphasis role="keyword">protected</emphasis>:
1257 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code;
1258 
1259 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;need&#32;the&#32;default&#32;constructor&#32;for&#32;the&#32;local&#32;iterators&#32;and&#32;_Hashtable</emphasis>
1260 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;default&#32;constructor.</emphasis>
1261 &#32;&#32;&#32;&#32;&#32;&#32;_Hash_code_base()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1262 
1263 &#32;&#32;&#32;&#32;&#32;&#32;_Hash_code_base(<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__hash)&#32;:&#32;__ebo_hash(__hash)&#32;{&#32;}
1264 
1265 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code
1266 &#32;&#32;&#32;&#32;&#32;&#32;_M_hash_code(<emphasis role="keyword">const</emphasis>&#32;_Key&amp;&#32;__k)<emphasis role="keyword">&#32;const</emphasis>
1267 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
1268 &#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(__is_invocable&lt;const&#32;_Hash&amp;,&#32;const&#32;_Key&amp;&gt;{},
1269 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;hash&#32;function&#32;must&#32;be&#32;invocable&#32;with&#32;an&#32;argument&#32;of&#32;key&#32;type&quot;</emphasis>);
1270 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_hash()(__k);
1271 &#32;&#32;&#32;&#32;&#32;&#32;}
1272 
1273 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
1274 &#32;&#32;&#32;&#32;__hash_code
1275 &#32;&#32;&#32;&#32;_M_hash_code_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)<emphasis role="keyword">&#32;const</emphasis>
1276 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
1277 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(__is_invocable&lt;const&#32;_Hash&amp;,&#32;const&#32;_Kt&amp;&gt;{},
1278 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;hash&#32;function&#32;must&#32;be&#32;invocable&#32;with&#32;an&#32;argument&#32;of&#32;key&#32;type&quot;</emphasis>);
1279 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_hash()(__k);
1280 &#32;&#32;&#32;&#32;}
1281 
1282 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code
1283 &#32;&#32;&#32;&#32;&#32;&#32;_M_hash_code(<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;,
1284 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;true&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1285 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__n._M_hash_code;&#32;}
1286 
1287 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Compute&#32;hash&#32;code&#32;using&#32;_Hash&#32;as&#32;__n&#32;_M_hash_code,&#32;if&#32;present,&#32;was</emphasis>
1288 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;computed&#32;using&#32;_H2.</emphasis>
1289 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_H2&gt;
1290 &#32;&#32;&#32;&#32;__hash_code
1291 &#32;&#32;&#32;&#32;_M_hash_code(<emphasis role="keyword">const</emphasis>&#32;_H2&amp;,
1292 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;__cache_hash_code&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1293 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_hash_code(_ExtractKey{}(__n._M_v()));&#32;}
1294 
1295 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code
1296 &#32;&#32;&#32;&#32;&#32;&#32;_M_hash_code(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;false&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1297 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_hash_code(_ExtractKey{}(__n._M_v()));&#32;}
1298 
1299 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code
1300 &#32;&#32;&#32;&#32;&#32;&#32;_M_hash_code(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;true&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1301 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__n._M_hash_code;&#32;}
1302 
1303 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t
1304 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_index(__hash_code&#32;__c,&#32;std::size_t&#32;__bkt_count)<emphasis role="keyword">&#32;const</emphasis>
1305 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_RangeHash{}(__c,&#32;__bkt_count);&#32;}
1306 
1307 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t
1308 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_index(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;false&gt;&amp;&#32;__n,
1309 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt_count)&#32;<emphasis role="keyword">const</emphasis>
1310 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(&#32;<emphasis role="keyword">noexcept</emphasis>(declval&lt;const&#32;_Hash&amp;&gt;()(declval&lt;const&#32;_Key&amp;&gt;()))
1311 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;<emphasis role="keyword">noexcept</emphasis>(declval&lt;const&#32;_RangeHash&amp;&gt;()((__hash_code)0,
1312 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(std::size_t)0))&#32;)
1313 &#32;&#32;&#32;&#32;&#32;&#32;{
1314 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
1315 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt_count);
1316 &#32;&#32;&#32;&#32;&#32;&#32;}
1317 
1318 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t
1319 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_index(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;true&gt;&amp;&#32;__n,
1320 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt_count)&#32;<emphasis role="keyword">const</emphasis>
1321 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(&#32;<emphasis role="keyword">noexcept</emphasis>(declval&lt;const&#32;_RangeHash&amp;&gt;()((__hash_code)0,
1322 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(std::size_t)0))&#32;)
1323 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_RangeHash{}(__n._M_hash_code,&#32;__bkt_count);&#32;}
1324 
1325 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1326 &#32;&#32;&#32;&#32;&#32;&#32;_M_store_code(_Hash_node_code_cache&lt;false&gt;&amp;,&#32;__hash_code)<emphasis role="keyword">&#32;const</emphasis>
1327 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;}
1328 
1329 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1330 &#32;&#32;&#32;&#32;&#32;&#32;_M_copy_code(_Hash_node_code_cache&lt;false&gt;&amp;,
1331 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;false&gt;&amp;)<emphasis role="keyword">&#32;const</emphasis>
1332 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;}
1333 
1334 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1335 &#32;&#32;&#32;&#32;&#32;&#32;_M_store_code(_Hash_node_code_cache&lt;true&gt;&amp;&#32;__n,&#32;__hash_code&#32;__c)<emphasis role="keyword">&#32;const</emphasis>
1336 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;__n._M_hash_code&#32;=&#32;__c;&#32;}
1337 
1338 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1339 &#32;&#32;&#32;&#32;&#32;&#32;_M_copy_code(_Hash_node_code_cache&lt;true&gt;&amp;&#32;__to,
1340 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;true&gt;&amp;&#32;__from)<emphasis role="keyword">&#32;const</emphasis>
1341 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;__to._M_hash_code&#32;=&#32;__from._M_hash_code;&#32;}
1342 
1343 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1344 &#32;&#32;&#32;&#32;&#32;&#32;_M_swap(_Hash_code_base&amp;&#32;__x)
1345 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(__ebo_hash::_M_get(),&#32;__x.__ebo_hash::_M_get());&#32;}
1346 
1347 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;
1348 &#32;&#32;&#32;&#32;&#32;&#32;_M_hash()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ebo_hash::_M_cget();&#32;}
1349 &#32;&#32;&#32;&#32;};
1350 
1352 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1353 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused&gt;
1354 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1355 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
1356 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Node_iterator_base&lt;_Value,&#32;true&gt;
1357 &#32;&#32;&#32;&#32;{
1358 &#32;&#32;&#32;&#32;<emphasis role="keyword">protected</emphasis>:
1359 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_node_iter&#32;=&#32;_Node_iterator_base&lt;_Value,&#32;true&gt;;
1360 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;_Hash_code_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<emphasis role="keyword">true</emphasis>&gt;;
1362 
1363 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1364 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base(<emphasis role="keyword">const</emphasis>&#32;__hash_code_base&amp;,
1365 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash_node&lt;_Value,&#32;true&gt;*&#32;__p,
1366 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt,&#32;std::size_t&#32;__bkt_count)
1367 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_node_iter(__p),&#32;_M_bucket(__bkt),&#32;_M_bucket_count(__bkt_count)
1368 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
1369 
1370 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1371 &#32;&#32;&#32;&#32;&#32;&#32;_M_incr()
1372 &#32;&#32;&#32;&#32;&#32;&#32;{
1373 &#32;&#32;&#32;&#32;__base_node_iter::_M_incr();
1374 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_cur)
1375 &#32;&#32;&#32;&#32;&#32;&#32;{
1376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt
1377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;_RangeHash{}(this-&gt;_M_cur-&gt;_M_hash_code,&#32;_M_bucket_count);
1378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__bkt&#32;!=&#32;_M_bucket)
1379 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_cur&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1380 &#32;&#32;&#32;&#32;&#32;&#32;}
1381 &#32;&#32;&#32;&#32;&#32;&#32;}
1382 
1383 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;_M_bucket;
1384 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;_M_bucket_count;
1385 
1386 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1387 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t
1388 &#32;&#32;&#32;&#32;&#32;&#32;_M_get_bucket()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_bucket;&#32;}&#32;&#32;<emphasis role="comment">//&#32;for&#32;debug&#32;mode</emphasis>
1389 &#32;&#32;&#32;&#32;};
1390 
1391 &#32;&#32;<emphasis role="comment">//&#32;Uninitialized&#32;storage&#32;for&#32;a&#32;_Hash_code_base.</emphasis>
1392 &#32;&#32;<emphasis role="comment">//&#32;This&#32;type&#32;is&#32;DefaultConstructible&#32;and&#32;Assignable&#32;even&#32;if&#32;the</emphasis>
1393 &#32;&#32;<emphasis role="comment">//&#32;_Hash_code_base&#32;type&#32;isn&apos;t,&#32;so&#32;that&#32;_Local_iterator_base&lt;...,&#32;false&gt;</emphasis>
1394 &#32;&#32;<emphasis role="comment">//&#32;can&#32;be&#32;DefaultConstructible&#32;and&#32;Assignable.</emphasis>
1395 &#32;&#32;template&lt;typename&#32;_Tp,&#32;bool&#32;_IsEmpty&#32;=&#32;std::is_empty&lt;_Tp&gt;::value&gt;
1396 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_code_storage
1397 &#32;&#32;&#32;&#32;{
1398 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_struct____gnu__cxx_1_1____aligned__buffer">__gnu_cxx::__aligned_buffer&lt;_Tp&gt;</link>&#32;_M_storage;
1399 
1400 &#32;&#32;&#32;&#32;&#32;&#32;_Tp*
1401 &#32;&#32;&#32;&#32;&#32;&#32;_M_h()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_storage.<link linkend="_struct____gnu__cxx_1_1____aligned__buffer_1a4f7396ec827253c1af249edad1c67b06">_M_ptr</link>();&#32;}
1402 
1403 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp*
1404 &#32;&#32;&#32;&#32;&#32;&#32;_M_h()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_storage._M_ptr();&#32;}
1405 &#32;&#32;&#32;&#32;};
1406 
1407 &#32;&#32;<emphasis role="comment">//&#32;Empty&#32;partial&#32;specialization&#32;for&#32;empty&#32;_Hash_code_base&#32;types.</emphasis>
1408 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp&gt;
1409 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hash_code_storage&lt;_Tp,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
1410 &#32;&#32;&#32;&#32;{
1411 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(&#32;std::is_empty&lt;_Tp&gt;::value,&#32;<emphasis role="stringliteral">&quot;Type&#32;must&#32;be&#32;empty&quot;</emphasis>&#32;);
1412 
1413 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;As&#32;_Tp&#32;is&#32;an&#32;empty&#32;type&#32;there&#32;will&#32;be&#32;no&#32;bytes&#32;written/read&#32;through</emphasis>
1414 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;the&#32;cast&#32;pointer,&#32;so&#32;no&#32;strict-aliasing&#32;violation.</emphasis>
1415 &#32;&#32;&#32;&#32;&#32;&#32;_Tp*
1416 &#32;&#32;&#32;&#32;&#32;&#32;_M_h()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">reinterpret_cast&lt;</emphasis>_Tp*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);&#32;}
1417 
1418 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Tp*
1419 &#32;&#32;&#32;&#32;&#32;&#32;_M_h()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">reinterpret_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>_Tp*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);&#32;}
1420 &#32;&#32;&#32;&#32;};
1421 
1422 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1423 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused&gt;
1424 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_for_local_iter
1425 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_Hash_code_storage&lt;_Hash_code_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1426 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<emphasis role="keyword">false</emphasis>&gt;&gt;;
1427 
1428 &#32;&#32;<emphasis role="comment">//&#32;Partial&#32;specialization&#32;used&#32;when&#32;hash&#32;codes&#32;are&#32;not&#32;cached</emphasis>
1429 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1430 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused&gt;
1431 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1432 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;
1433 &#32;&#32;&#32;&#32;:&#32;__hash_code_for_local_iter&lt;_Key,&#32;_Value,&#32;_ExtractKey,&#32;_Hash,&#32;_RangeHash,
1434 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Unused&gt;
1435 &#32;&#32;&#32;&#32;,&#32;_Node_iterator_base&lt;_Value,&#32;false&gt;
1436 &#32;&#32;&#32;&#32;{
1437 &#32;&#32;&#32;&#32;<emphasis role="keyword">protected</emphasis>:
1438 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;_Hash_code_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1439 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;<emphasis role="keyword">false</emphasis>&gt;;
1440 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_iter_base&#32;=&#32;_Node_iterator_base&lt;_Value,&#32;false&gt;;
1441 
1442 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base()&#32;:&#32;_M_bucket_count(-1)&#32;{&#32;}
1443 
1444 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base(<emphasis role="keyword">const</emphasis>&#32;__hash_code_base&amp;&#32;__base,
1445 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash_node&lt;_Value,&#32;false&gt;*&#32;__p,
1446 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt,&#32;std::size_t&#32;__bkt_count)
1447 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__node_iter_base(__p),&#32;_M_bucket(__bkt),&#32;_M_bucket_count(__bkt_count)
1448 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;_M_init(__base);&#32;}
1449 
1450 &#32;&#32;&#32;&#32;&#32;&#32;~_Local_iterator_base()
1451 &#32;&#32;&#32;&#32;&#32;&#32;{
1452 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;!=&#32;<emphasis role="keywordtype">size_t</emphasis>(-1))
1453 &#32;&#32;&#32;&#32;&#32;&#32;_M_destroy();
1454 &#32;&#32;&#32;&#32;&#32;&#32;}
1455 
1456 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base(<emphasis role="keyword">const</emphasis>&#32;_Local_iterator_base&amp;&#32;__iter)
1457 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__node_iter_base(__iter._M_cur),&#32;_M_bucket(__iter._M_bucket)
1458 &#32;&#32;&#32;&#32;&#32;&#32;,&#32;_M_bucket_count(__iter._M_bucket_count)
1459 &#32;&#32;&#32;&#32;&#32;&#32;{
1460 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;!=&#32;<emphasis role="keywordtype">size_t</emphasis>(-1))
1461 &#32;&#32;&#32;&#32;&#32;&#32;_M_init(*__iter._M_h());
1462 &#32;&#32;&#32;&#32;&#32;&#32;}
1463 
1464 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator_base&amp;
1465 &#32;&#32;&#32;&#32;&#32;&#32;operator=(<emphasis role="keyword">const</emphasis>&#32;_Local_iterator_base&amp;&#32;__iter)
1466 &#32;&#32;&#32;&#32;&#32;&#32;{
1467 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;!=&#32;-1)
1468 &#32;&#32;&#32;&#32;&#32;&#32;_M_destroy();
1469 &#32;&#32;&#32;&#32;this-&gt;_M_cur&#32;=&#32;__iter._M_cur;
1470 &#32;&#32;&#32;&#32;_M_bucket&#32;=&#32;__iter._M_bucket;
1471 &#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__iter._M_bucket_count;
1472 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;!=&#32;-1)
1473 &#32;&#32;&#32;&#32;&#32;&#32;_M_init(*__iter._M_h());
1474 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1475 &#32;&#32;&#32;&#32;&#32;&#32;}
1476 
1477 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1478 &#32;&#32;&#32;&#32;&#32;&#32;_M_incr()
1479 &#32;&#32;&#32;&#32;&#32;&#32;{
1480 &#32;&#32;&#32;&#32;__node_iter_base::_M_incr();
1481 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_cur)
1482 &#32;&#32;&#32;&#32;&#32;&#32;{
1483 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;this-&gt;_M_h()-&gt;_M_bucket_index(*this-&gt;_M_cur,
1484 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count);
1485 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__bkt&#32;!=&#32;_M_bucket)
1486 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_cur&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1487 &#32;&#32;&#32;&#32;&#32;&#32;}
1488 &#32;&#32;&#32;&#32;&#32;&#32;}
1489 
1490 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;_M_bucket;
1491 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;_M_bucket_count;
1492 
1493 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1494 &#32;&#32;&#32;&#32;&#32;&#32;_M_init(<emphasis role="keyword">const</emphasis>&#32;__hash_code_base&amp;&#32;__base)
1495 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;::new(this-&gt;_M_h())&#32;__hash_code_base(__base);&#32;}
1496 
1497 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1498 &#32;&#32;&#32;&#32;&#32;&#32;_M_destroy()&#32;{&#32;this-&gt;_M_h()-&gt;~__hash_code_base();&#32;}
1499 
1500 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1501 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t
1502 &#32;&#32;&#32;&#32;&#32;&#32;_M_get_bucket()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_bucket;&#32;}&#32;&#32;<emphasis role="comment">//&#32;for&#32;debug&#32;mode</emphasis>
1503 &#32;&#32;&#32;&#32;};
1504 
1506 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1507 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1508 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__constant_iterators,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache&gt;
1509 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_iterator
1510 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;__cache&gt;
1512 &#32;&#32;&#32;&#32;{
1513 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1514 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1515 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;__cache&gt;;
1516 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__hash_code_base;
1517 
1518 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1519 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>value_type&#32;=&#32;_Value;
1520 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>&#32;=&#32;__conditional_t&lt;__constant_iterators,
1521 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;value_type*,&#32;value_type*&gt;;
1522 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>reference&#32;=&#32;__conditional_t&lt;__constant_iterators,
1523 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;,&#32;value_type&amp;&gt;;
1524 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>difference_type&#32;=&#32;<link linkend="__classes_2lib_2include_2stddef_8h_1a6d26a0475a6d6c897e655cdc5d8019d2">ptrdiff_t</link>;
1525 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator_category&#32;=&#32;forward_iterator_tag;
1526 
1527 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1528 
1529 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator(<emphasis role="keyword">const</emphasis>&#32;__hash_code_base&amp;&#32;__base,
1530 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash_node&lt;_Value,&#32;__cache&gt;*&#32;__n,
1531 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt,&#32;std::size_t&#32;__bkt_count)
1532 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__base,&#32;__n,&#32;__bkt,&#32;__bkt_count)
1533 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
1534 
1535 &#32;&#32;&#32;&#32;&#32;&#32;reference
1536 &#32;&#32;&#32;&#32;&#32;&#32;operator*()<emphasis role="keyword">&#32;const</emphasis>
1537 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_v();&#32;}
1538 
1539 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>
1540 &#32;&#32;&#32;&#32;&#32;&#32;operator-&gt;()<emphasis role="keyword">&#32;const</emphasis>
1541 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_valptr();&#32;}
1542 
1543 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator&amp;
1544 &#32;&#32;&#32;&#32;&#32;&#32;operator++()
1545 &#32;&#32;&#32;&#32;&#32;&#32;{
1546 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
1547 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1548 &#32;&#32;&#32;&#32;&#32;&#32;}
1549 
1550 &#32;&#32;&#32;&#32;&#32;&#32;_Local_iterator
1551 &#32;&#32;&#32;&#32;&#32;&#32;operator++(<emphasis role="keywordtype">int</emphasis>)
1552 &#32;&#32;&#32;&#32;&#32;&#32;{
1553 &#32;&#32;&#32;&#32;_Local_iterator&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>(*<emphasis role="keyword">this</emphasis>);
1554 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
1555 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>;
1556 &#32;&#32;&#32;&#32;&#32;&#32;}
1557 &#32;&#32;&#32;&#32;};
1558 
1560 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1562 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__constant_iterators,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__cache&gt;
1563 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Local_const_iterator
1564 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1565 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;__cache&gt;
1566 &#32;&#32;&#32;&#32;{
1567 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1568 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__base_type&#32;=&#32;_Local_iterator_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;__cache&gt;;
1570 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__base_type::__hash_code_base;
1571 
1572 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1573 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Value&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value_type;
1574 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;value_type*&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>;
1575 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reference;
1576 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::ptrdiff_t&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;difference_type;
1577 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::forward_iterator_tag&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;iterator_category;
1578 
1579 &#32;&#32;&#32;&#32;&#32;&#32;_Local_const_iterator()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1580 
1581 &#32;&#32;&#32;&#32;&#32;&#32;_Local_const_iterator(<emphasis role="keyword">const</emphasis>&#32;__hash_code_base&amp;&#32;__base,
1582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash_node&lt;_Value,&#32;__cache&gt;*&#32;__n,
1583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt,&#32;std::size_t&#32;__bkt_count)
1584 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__base,&#32;__n,&#32;__bkt,&#32;__bkt_count)
1585 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
1586 
1587 &#32;&#32;&#32;&#32;&#32;&#32;_Local_const_iterator(<emphasis role="keyword">const</emphasis>&#32;_Local_iterator&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1589 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__constant_iterators,
1590 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__cache&gt;&amp;&#32;__x)
1591 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__base_type(__x)
1592 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
1593 
1594 &#32;&#32;&#32;&#32;&#32;&#32;reference
1595 &#32;&#32;&#32;&#32;&#32;&#32;operator*()<emphasis role="keyword">&#32;const</emphasis>
1596 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_v();&#32;}
1597 
1598 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>
1599 &#32;&#32;&#32;&#32;&#32;&#32;operator-&gt;()<emphasis role="keyword">&#32;const</emphasis>
1600 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_cur-&gt;_M_valptr();&#32;}
1601 
1602 &#32;&#32;&#32;&#32;&#32;&#32;_Local_const_iterator&amp;
1603 &#32;&#32;&#32;&#32;&#32;&#32;operator++()
1604 &#32;&#32;&#32;&#32;&#32;&#32;{
1605 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
1606 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1607 &#32;&#32;&#32;&#32;&#32;&#32;}
1608 
1609 &#32;&#32;&#32;&#32;&#32;&#32;_Local_const_iterator
1610 &#32;&#32;&#32;&#32;&#32;&#32;operator++(<emphasis role="keywordtype">int</emphasis>)
1611 &#32;&#32;&#32;&#32;&#32;&#32;{
1612 &#32;&#32;&#32;&#32;_Local_const_iterator&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>(*<emphasis role="keyword">this</emphasis>);
1613 &#32;&#32;&#32;&#32;this-&gt;_M_incr();
1614 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>;
1615 &#32;&#32;&#32;&#32;&#32;&#32;}
1616 &#32;&#32;&#32;&#32;};
1617 
1628 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,
1629 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,
1630 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1631 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_base
1632 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;_Hash_code_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,&#32;_Hash,&#32;_RangeHash,
1633 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Unused,&#32;_Traits::__hash_cached::value&gt;,
1634 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;_Hashtable_ebo_helper&lt;0,&#32;_Equal&gt;
1635 &#32;&#32;&#32;&#32;{
1636 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1637 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Key&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key_type;
1638 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Value&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value_type;
1639 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Equal&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key_equal;
1640 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::size_t&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type;
1641 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::ptrdiff_t&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;difference_type;
1642 
1643 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__traits_type&#32;=&#32;_Traits;
1644 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_cached&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__traits_type::__hash_cached;
1645 
1646 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;_Hash_code_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
1647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;;
1649 
1650 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hash_code_base::__hash_code;
1651 
1652 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1653 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_EqualEBO&#32;=&#32;_Hashtable_ebo_helper&lt;0,&#32;_Equal&gt;;
1654 
1655 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
1656 &#32;&#32;&#32;&#32;&#32;&#32;_S_equals(__hash_code,&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;false&gt;&amp;)
1657 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;&#32;}
1658 
1659 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
1660 &#32;&#32;&#32;&#32;&#32;&#32;_S_node_equals(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;false&gt;&amp;,
1661 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;false&gt;&amp;)
1662 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;&#32;}
1663 
1664 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
1665 &#32;&#32;&#32;&#32;&#32;&#32;_S_equals(__hash_code&#32;__c,&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;true&gt;&amp;&#32;__n)
1666 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__c&#32;==&#32;__n._M_hash_code;&#32;}
1667 
1668 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
1669 &#32;&#32;&#32;&#32;&#32;&#32;_S_node_equals(<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;true&gt;&amp;&#32;__lhn,
1670 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_code_cache&lt;true&gt;&amp;&#32;__rhn)
1671 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__lhn._M_hash_code&#32;==&#32;__rhn._M_hash_code;&#32;}
1672 
1673 &#32;&#32;&#32;&#32;<emphasis role="keyword">protected</emphasis>:
1674 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_base()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1675 
1676 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_base(<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__hash,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;&#32;__eq)
1677 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__hash_code_base(__hash),&#32;_EqualEBO(__eq)
1678 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
1679 
1680 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1681 &#32;&#32;&#32;&#32;&#32;&#32;_M_key_equals(<emphasis role="keyword">const</emphasis>&#32;_Key&amp;&#32;__k,
1682 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,
1683 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1684 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
1685 &#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(__is_invocable&lt;const&#32;_Equal&amp;,&#32;const&#32;_Key&amp;,&#32;const&#32;_Key&amp;&gt;{},
1686 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;key&#32;equality&#32;predicate&#32;must&#32;be&#32;invocable&#32;with&#32;two&#32;arguments&#32;of&#32;&quot;</emphasis>
1687 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;key&#32;type&quot;</emphasis>);
1688 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_eq()(__k,&#32;_ExtractKey{}(__n._M_v()));
1689 &#32;&#32;&#32;&#32;&#32;&#32;}
1690 
1691 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
1692 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1693 &#32;&#32;&#32;&#32;_M_key_equals_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k,
1694 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,
1695 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1696 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
1697 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(
1698 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__is_invocable&lt;const&#32;_Equal&amp;,&#32;const&#32;_Kt&amp;,&#32;const&#32;_Key&amp;&gt;{},
1699 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;key&#32;equality&#32;predicate&#32;must&#32;be&#32;invocable&#32;with&#32;two&#32;arguments&#32;of&#32;&quot;</emphasis>
1700 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;key&#32;type&quot;</emphasis>);
1701 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_eq()(__k,&#32;_ExtractKey{}(__n._M_v()));
1702 &#32;&#32;&#32;&#32;}
1703 
1704 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1705 &#32;&#32;&#32;&#32;&#32;&#32;_M_equals(<emphasis role="keyword">const</emphasis>&#32;_Key&amp;&#32;__k,&#32;__hash_code&#32;__c,
1706 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;__hash_cached::value&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1707 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_S_equals(__c,&#32;__n)&#32;&amp;&amp;&#32;_M_key_equals(__k,&#32;__n);&#32;}
1708 
1709 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
1710 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1711 &#32;&#32;&#32;&#32;_M_equals_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k,&#32;__hash_code&#32;__c,
1712 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,
1713 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;&amp;&#32;__n)<emphasis role="keyword">&#32;const</emphasis>
1714 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_S_equals(__c,&#32;__n)&#32;&amp;&amp;&#32;_M_key_equals_tr(__k,&#32;__n);&#32;}
1715 
1716 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1717 &#32;&#32;&#32;&#32;&#32;&#32;_M_node_equals(
1718 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;__hash_cached::value&gt;&amp;&#32;__lhn,
1719 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash_node_value&lt;_Value,&#32;__hash_cached::value&gt;&amp;&#32;__rhn)<emphasis role="keyword">&#32;const</emphasis>
1720 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
1721 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_S_node_equals(__lhn,&#32;__rhn)
1722 &#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;_M_key_equals(_ExtractKey{}(__lhn._M_v()),&#32;__rhn);
1723 &#32;&#32;&#32;&#32;&#32;&#32;}
1724 
1725 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1726 &#32;&#32;&#32;&#32;&#32;&#32;_M_swap(_Hashtable_base&amp;&#32;__x)
1727 &#32;&#32;&#32;&#32;&#32;&#32;{
1728 &#32;&#32;&#32;&#32;__hash_code_base::_M_swap(__x);
1729 &#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_EqualEBO::_M_get(),&#32;__x._EqualEBO::_M_get());
1730 &#32;&#32;&#32;&#32;&#32;&#32;}
1731 
1732 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;
1733 &#32;&#32;&#32;&#32;&#32;&#32;_M_eq()<emphasis role="keyword">&#32;const&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_EqualEBO::_M_cget();&#32;}
1734 &#32;&#32;&#32;&#32;};
1735 
1744 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1745 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1746 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1747 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits,
1748 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Unique_keys&#32;=&#32;_Traits::__unique_keys::value&gt;
1749 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Equality;
1750 
1752 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1753 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1754 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1755 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1756 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1757 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</link>&gt;
1758 &#32;&#32;&#32;&#32;{
1759 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1760 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1761 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
1762 
1763 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1764 &#32;&#32;&#32;&#32;&#32;&#32;_M_equal(<emphasis role="keyword">const</emphasis>&#32;__hashtable&amp;)&#32;<emphasis role="keyword">const</emphasis>;
1765 &#32;&#32;&#32;&#32;};
1766 
1767 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1768 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1769 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1770 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1771 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1772 &#32;&#32;&#32;&#32;_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1773 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<emphasis role="keyword">true</emphasis>&gt;::
1774 &#32;&#32;&#32;&#32;_M_equal(<emphasis role="keyword">const</emphasis>&#32;__hashtable&amp;&#32;__other)<emphasis role="keyword">&#32;const</emphasis>
1775 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
1776 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::__node_type;
1777 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__hashtable*&#32;__this&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
1778 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__this-&gt;size()&#32;!=&#32;__other.size())
1779 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1780 
1781 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__itx&#32;=&#32;__this-&gt;begin();&#32;__itx&#32;!=&#32;__this-&gt;end();&#32;++__itx)
1782 &#32;&#32;&#32;&#32;{
1783 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__ybkt&#32;=&#32;__other._M_bucket_index(*__itx._M_cur);
1784 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__prev_n&#32;=&#32;__other._M_buckets[__ybkt];
1785 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_n)
1786 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1787 
1788 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__node_type*&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_type*<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);;
1789 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;__n-&gt;_M_next())
1790 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1791 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n-&gt;_M_v()&#32;==&#32;*__itx)
1792 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1793 
1794 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__n-&gt;_M_nxt
1795 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;||&#32;__other._M_bucket_index(*__n-&gt;_M_next())&#32;!=&#32;__ybkt)
1796 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1797 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1798 &#32;&#32;&#32;&#32;}
1799 
1800 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1801 &#32;&#32;&#32;&#32;}
1802 
1804 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1805 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1807 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1808 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1809 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<link linkend="__classes_2lib_2include_2stdbool_8h_1a65e9886d74aaee76545e83dd09011727">false</link>&gt;
1810 &#32;&#32;&#32;&#32;{
1811 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable&#32;=&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1812 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
1813 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
1814 
1815 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1816 &#32;&#32;&#32;&#32;&#32;&#32;_M_equal(<emphasis role="keyword">const</emphasis>&#32;__hashtable&amp;)&#32;<emphasis role="keyword">const</emphasis>;
1817 &#32;&#32;&#32;&#32;};
1818 
1819 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1820 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1821 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1822 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1823 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
1824 &#32;&#32;&#32;&#32;_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1825 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits,&#32;<emphasis role="keyword">false</emphasis>&gt;::
1826 &#32;&#32;&#32;&#32;_M_equal(<emphasis role="keyword">const</emphasis>&#32;__hashtable&amp;&#32;__other)<emphasis role="keyword">&#32;const</emphasis>
1827 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
1828 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::__node_type;
1829 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__hashtable*&#32;__this&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keyword">const&#32;</emphasis>__hashtable*<emphasis role="keyword">&gt;</emphasis>(<emphasis role="keyword">this</emphasis>);
1830 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__this-&gt;size()&#32;!=&#32;__other.size())
1831 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1832 
1833 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__itx&#32;=&#32;__this-&gt;begin();&#32;__itx&#32;!=&#32;__this-&gt;end();)
1834 &#32;&#32;&#32;&#32;{
1835 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__x_count&#32;=&#32;1;
1836 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__itx_end&#32;=&#32;__itx;
1837 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(++__itx_end;&#32;__itx_end&#32;!=&#32;__this-&gt;end()
1838 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;__this-&gt;key_eq()(_ExtractKey{}(*__itx),
1839 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_ExtractKey{}(*__itx_end));
1840 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;++__itx_end)
1841 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;++__x_count;
1842 
1843 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__ybkt&#32;=&#32;__other._M_bucket_index(*__itx._M_cur);
1844 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__y_prev_n&#32;=&#32;__other._M_buckets[__ybkt];
1845 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__y_prev_n)
1846 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1847 
1848 &#32;&#32;&#32;&#32;&#32;&#32;__node_type*&#32;__y_n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_type*<emphasis role="keyword">&gt;</emphasis>(__y_prev_n-&gt;_M_nxt);
1849 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;;)
1850 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1851 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__this-&gt;key_eq()(_ExtractKey{}(__y_n-&gt;_M_v()),
1852 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_ExtractKey{}(*__itx)))
1853 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1854 
1855 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__y_ref_n&#32;=&#32;__y_n;
1856 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__y_n&#32;=&#32;__y_n-&gt;_M_next();&#32;__y_n;&#32;__y_n&#32;=&#32;__y_n-&gt;_M_next())
1857 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__other._M_node_equals(*__y_ref_n,&#32;*__y_n))
1858 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1859 
1860 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__y_n&#32;||&#32;__other._M_bucket_index(*__y_n)&#32;!=&#32;__ybkt)
1861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1863 
1864 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable::const_iterator&#32;__ity(__y_n);
1865 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__ity_end&#32;=&#32;__ity;&#32;__ity_end&#32;!=&#32;__other.end();&#32;++__ity_end)
1866 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(--__x_count&#32;==&#32;0)
1867 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1868 
1869 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__x_count&#32;!=&#32;0)
1870 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1871 
1872 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!std::is_permutation(__itx,&#32;__itx_end,&#32;__ity))
1873 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1874 
1875 &#32;&#32;&#32;&#32;&#32;&#32;__itx&#32;=&#32;__itx_end;
1876 &#32;&#32;&#32;&#32;}
1877 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1878 &#32;&#32;&#32;&#32;}
1879 
1884 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
1885 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Hashtable_alloc&#32;:&#32;<emphasis role="keyword">private</emphasis>&#32;_Hashtable_ebo_helper&lt;0,&#32;_NodeAlloc&gt;
1886 &#32;&#32;&#32;&#32;{
1887 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1888 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ebo_node_alloc&#32;=&#32;_Hashtable_ebo_helper&lt;0,&#32;_NodeAlloc&gt;;
1889 
1890 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&gt;
1891 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__get_value_type;
1892 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Val,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Cache_hash_code&gt;
1893 &#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__get_value_type&lt;_Hash_node&lt;_Val,&#32;_Cache_hash_code&gt;&gt;
1894 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keyword">using&#32;</emphasis><link linkend="__classes_2_gameobj_8h_1a890efa53b3d7deeeced6f3a0d6653ed3">type</link>&#32;=&#32;_Val;&#32;};
1895 
1896 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1897 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc::value_type;
1898 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_type&#32;=&#32;_NodeAlloc;
1899 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Use&#32;__gnu_cxx&#32;to&#32;benefit&#32;from&#32;_S_always_equal&#32;and&#32;al.</emphasis>
1900 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_traits&#32;=&#32;__gnu_cxx::__alloc_traits&lt;__node_alloc_type&gt;;
1901 
1902 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__value_alloc_traits&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__node_alloc_traits::template
1903 &#32;&#32;&#32;&#32;rebind_traits&lt;typename&#32;__get_value_type&lt;__node_type&gt;::type&gt;;
1904 
1905 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_ptr&#32;=&#32;__node_type*;
1906 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_base&#32;=&#32;_Hash_node_base;
1907 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_base_ptr&#32;=&#32;__node_base*;
1908 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__buckets_alloc_type&#32;=
1909 &#32;&#32;&#32;&#32;__alloc_rebind&lt;__node_alloc_type,&#32;__node_base_ptr&gt;;
1910 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__buckets_alloc_traits&#32;=&#32;std::allocator_traits&lt;__buckets_alloc_type&gt;;
1911 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__buckets_ptr&#32;=&#32;__node_base_ptr*;
1912 
1913 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_alloc()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1914 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_alloc(<emphasis role="keyword">const</emphasis>&#32;_Hashtable_alloc&amp;)&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1915 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_alloc(_Hashtable_alloc&amp;&amp;)&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
1916 
1917 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Alloc&gt;
1918 &#32;&#32;&#32;&#32;_Hashtable_alloc(_Alloc&amp;&amp;&#32;__a)
1919 &#32;&#32;&#32;&#32;:&#32;__ebo_node_alloc(std::forward&lt;_Alloc&gt;(__a))
1920 &#32;&#32;&#32;&#32;{&#32;}
1921 
1922 &#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_type&amp;
1923 &#32;&#32;&#32;&#32;&#32;&#32;_M_node_allocator()
1924 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ebo_node_alloc::_M_get();&#32;}
1925 
1926 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__node_alloc_type&amp;
1927 &#32;&#32;&#32;&#32;&#32;&#32;_M_node_allocator()<emphasis role="keyword">&#32;const</emphasis>
1928 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ebo_node_alloc::_M_cget();&#32;}
1929 
1930 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Allocate&#32;a&#32;node&#32;and&#32;construct&#32;an&#32;element&#32;within&#32;it.</emphasis>
1931 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
1932 &#32;&#32;&#32;&#32;__node_ptr
1933 &#32;&#32;&#32;&#32;_M_allocate_node(_Args&amp;&amp;...&#32;__args);
1934 
1935 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Destroy&#32;the&#32;element&#32;within&#32;a&#32;node&#32;and&#32;deallocate&#32;the&#32;node.</emphasis>
1936 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1937 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_node(__node_ptr&#32;__n);
1938 
1939 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Deallocate&#32;a&#32;node.</emphasis>
1940 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1941 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_node_ptr(__node_ptr&#32;__n);
1942 
1943 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Deallocate&#32;the&#32;linked&#32;list&#32;of&#32;nodes&#32;pointed&#32;to&#32;by&#32;__n.</emphasis>
1944 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;elements&#32;within&#32;the&#32;nodes&#32;are&#32;destroyed.</emphasis>
1945 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1946 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_nodes(__node_ptr&#32;__n);
1947 
1948 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr
1949 &#32;&#32;&#32;&#32;&#32;&#32;_M_allocate_buckets(std::size_t&#32;__bkt_count);
1950 
1951 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1952 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets(__buckets_ptr,&#32;std::size_t&#32;__bkt_count);
1953 &#32;&#32;&#32;&#32;};
1954 
1955 &#32;&#32;<emphasis role="comment">//&#32;Definitions&#32;of&#32;class&#32;template&#32;_Hashtable_alloc&apos;s&#32;out-of-line&#32;member</emphasis>
1956 &#32;&#32;<emphasis role="comment">//&#32;functions.</emphasis>
1957 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
1958 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
1959 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1960 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::_M_allocate_node(_Args&amp;&amp;...&#32;__args)
1961 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;__node_ptr
1962 &#32;&#32;&#32;&#32;&#32;&#32;{
1963 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__nptr&#32;=&#32;__node_alloc_traits::allocate(_M_node_allocator(),&#32;1);
1964 &#32;&#32;&#32;&#32;__node_ptr&#32;__n&#32;=&#32;std::__to_address(__nptr);
1965 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
1966 &#32;&#32;&#32;&#32;&#32;&#32;{
1967 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;::new&#32;((<emphasis role="keywordtype">void</emphasis>*)__n)&#32;__node_type;
1968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::construct(_M_node_allocator(),
1969 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n-&gt;_M_valptr(),
1970 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Args&gt;(__args)...);
1971 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__n;
1972 &#32;&#32;&#32;&#32;&#32;&#32;}
1973 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
1974 &#32;&#32;&#32;&#32;&#32;&#32;{
1975 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::deallocate(_M_node_allocator(),&#32;__nptr,&#32;1);
1976 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
1977 &#32;&#32;&#32;&#32;&#32;&#32;}
1978 &#32;&#32;&#32;&#32;&#32;&#32;}
1979 
1980 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
1981 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1982 &#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_node(__node_ptr&#32;__n)
1983 &#32;&#32;&#32;&#32;{
1984 &#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::destroy(_M_node_allocator(),&#32;__n-&gt;_M_valptr());
1985 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_node_ptr(__n);
1986 &#32;&#32;&#32;&#32;}
1987 
1988 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
1989 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1990 &#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_node_ptr(__node_ptr&#32;__n)
1991 &#32;&#32;&#32;&#32;{
1992 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;__node_alloc_traits::pointer&#32;_Ptr;
1993 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ptr&#32;=&#32;std::pointer_traits&lt;_Ptr&gt;::pointer_to(*__n);
1994 &#32;&#32;&#32;&#32;&#32;&#32;__n-&gt;~__node_type();
1995 &#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::deallocate(_M_node_allocator(),&#32;__ptr,&#32;1);
1996 &#32;&#32;&#32;&#32;}
1997 
1998 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
1999 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2000 &#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::_M_deallocate_nodes(__node_ptr&#32;__n)
2001 &#32;&#32;&#32;&#32;{
2002 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__n)
2003 &#32;&#32;&#32;&#32;{
2004 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>&#32;=&#32;__n;
2005 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;__n-&gt;_M_next();
2006 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_node(<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>);
2007 &#32;&#32;&#32;&#32;}
2008 &#32;&#32;&#32;&#32;}
2009 
2010 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
2011 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2012 &#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::_M_allocate_buckets(std::size_t&#32;__bkt_count)
2013 &#32;&#32;&#32;&#32;-&gt;&#32;__buckets_ptr
2014 &#32;&#32;&#32;&#32;{
2015 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_alloc_type&#32;__alloc(_M_node_allocator());
2016 
2017 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ptr&#32;=&#32;__buckets_alloc_traits::allocate(__alloc,&#32;__bkt_count);
2018 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr&#32;__p&#32;=&#32;std::__to_address(__ptr);
2019 &#32;&#32;&#32;&#32;&#32;&#32;__builtin_memset(__p,&#32;0,&#32;__bkt_count&#32;*&#32;<emphasis role="keyword">sizeof</emphasis>(__node_base_ptr));
2020 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__p;
2021 &#32;&#32;&#32;&#32;}
2022 
2023 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_NodeAlloc&gt;
2024 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2025 &#32;&#32;&#32;&#32;_Hashtable_alloc&lt;_NodeAlloc&gt;::
2026 &#32;&#32;&#32;&#32;_M_deallocate_buckets(__buckets_ptr&#32;__bkts,
2027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt_count)
2028 &#32;&#32;&#32;&#32;{
2029 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;__buckets_alloc_traits::pointer&#32;_Ptr;
2030 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ptr&#32;=&#32;std::pointer_traits&lt;_Ptr&gt;::pointer_to(*__bkts);
2031 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_alloc_type&#32;__alloc(_M_node_allocator());
2032 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_alloc_traits::deallocate(__alloc,&#32;__ptr,&#32;__bkt_count);
2033 &#32;&#32;&#32;&#32;}
2034 
2036 }&#32;<emphasis role="comment">//&#32;namespace&#32;__detail</emphasis>
2038 _GLIBCXX_END_NAMESPACE_VERSION
2039 }&#32;<emphasis role="comment">//&#32;namespace&#32;std</emphasis>
2040 
2041 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;_HASHTABLE_POLICY_H</emphasis>
</programlisting></section>
