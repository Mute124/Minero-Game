<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__pointer__adaptors" xml:lang="en-US">
<title>Adaptors for pointers to functions</title>
<indexterm><primary>Adaptors for pointers to functions</primary></indexterm>
Collaboration diagram for Adaptors for pointers to functions:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__pointer__adaptors.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Modules    </title>
        <itemizedlist>
            <listitem><para><link linkend="_group__ptrmem__adaptors">Adaptors for pointers to members</link></para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para><?linebreak?></para>

<para>The advantage of function objects over pointers to functions is that the objects in the standard library declare nested typedefs describing their argument and result types with uniform names (e.g., <computeroutput>result_type</computeroutput> from the base classes <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>). Sometimes those typedefs are required, not just optional.</para>

<para>Adaptors are provided to turn pointers to unary (single-argument) and binary (double-argument) functions into function objects. The long-winded functor <computeroutput>pointer_to_unary_function</computeroutput> is constructed with a function pointer <computeroutput>f</computeroutput>, and its <computeroutput>operator()</computeroutput> called with argument <computeroutput>x</computeroutput> returns <computeroutput><link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a0fdda94b8b7e64884690244028f455ba">f(x)</link></computeroutput>. The functor <computeroutput>pointer_to_binary_function</computeroutput> does the same thing, but with a double-argument <computeroutput>f</computeroutput> and <computeroutput>operator()</computeroutput>.</para>

<para>The function <computeroutput>ptr_fun</computeroutput> takes a pointer-to-function <computeroutput>f</computeroutput> and constructs an instance of the appropriate functor.</para>

<para><para><link linkend="_deprecated_1_deprecated000012">Deprecated</link> 
<para>Deprecated in C++11, no longer in the standard since C++17.</para>
</para></para>

<para><?linebreak?></para>

<para>The advantage of function objects over pointers to functions is that the objects in the standard library declare nested typedefs describing their argument and result types with uniform names (e.g., <computeroutput>result_type</computeroutput> from the base classes <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>). Sometimes those typedefs are required, not just optional.</para>

<para>Adaptors are provided to turn pointers to unary (single-argument) and binary (double-argument) functions into function objects. The long-winded functor <computeroutput>pointer_to_unary_function</computeroutput> is constructed with a function pointer <computeroutput>f</computeroutput>, and its <computeroutput>operator()</computeroutput> called with argument <computeroutput>x</computeroutput> returns <computeroutput><link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a0fdda94b8b7e64884690244028f455ba">f(x)</link></computeroutput>. The functor <computeroutput>pointer_to_binary_function</computeroutput> does the same thing, but with a double-argument <computeroutput>f</computeroutput> and <computeroutput>operator()</computeroutput>.</para>

<para>The function <computeroutput>ptr_fun</computeroutput> takes a pointer-to-function <computeroutput>f</computeroutput> and constructs an instance of the appropriate functor.</para>

<para><para><link linkend="_deprecated_1_deprecated000028">Deprecated</link> 
<para>Deprecated in C++11, no longer in the standard since C++17.</para>
</para></para>

<para><?linebreak?></para>

<para>The advantage of function objects over pointers to functions is that the objects in the standard library declare nested typedefs describing their argument and result types with uniform names (e.g., <computeroutput>result_type</computeroutput> from the base classes <computeroutput>unary_function</computeroutput> and <computeroutput>binary_function</computeroutput>). Sometimes those typedefs are required, not just optional.</para>

<para>Adaptors are provided to turn pointers to unary (single-argument) and binary (double-argument) functions into function objects. The long-winded functor <computeroutput>pointer_to_unary_function</computeroutput> is constructed with a function pointer <computeroutput>f</computeroutput>, and its <computeroutput>operator()</computeroutput> called with argument <computeroutput>x</computeroutput> returns <computeroutput><link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a0fdda94b8b7e64884690244028f455ba">f(x)</link></computeroutput>. The functor <computeroutput>pointer_to_binary_function</computeroutput> does the same thing, but with a double-argument <computeroutput>f</computeroutput> and <computeroutput>operator()</computeroutput>.</para>

<para>The function <computeroutput>ptr_fun</computeroutput> takes a pointer-to-function <computeroutput>f</computeroutput> and constructs an instance of the appropriate functor.</para>

<para><para><link linkend="_deprecated_1_deprecated000042">Deprecated</link> 
<para>Deprecated in C++11, no longer in the standard since C++17.</para>
</para></para>
</section>
    <xi:include href="group__ptrmem__adaptors.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
</section>
