<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="__old_2_classes_2lib_2include_2c_09_09_2bits_2hashtable_8h_source" xml:lang="en-US">
<title>hashtable.h</title>
<indexterm><primary>C:/Users/HP/Documents/GitHub/Minero-Game/Old/Classes/lib/include/c++/bits/hashtable.h</primary></indexterm>
Go to the documentation of this file.<programlisting linenumbering="unnumbered">1 <emphasis role="comment">//&#32;hashtable.h&#32;header&#32;-*-&#32;C++&#32;-*-</emphasis>
2 
3 <emphasis role="comment">//&#32;Copyright&#32;(C)&#32;2007-2022&#32;Free&#32;Software&#32;Foundation,&#32;Inc.</emphasis>
4 <emphasis role="comment">//</emphasis>
5 <emphasis role="comment">//&#32;This&#32;file&#32;is&#32;part&#32;of&#32;the&#32;GNU&#32;ISO&#32;C++&#32;Library.&#32;&#32;This&#32;library&#32;is&#32;free</emphasis>
6 <emphasis role="comment">//&#32;software;&#32;you&#32;can&#32;redistribute&#32;it&#32;and/or&#32;modify&#32;it&#32;under&#32;the</emphasis>
7 <emphasis role="comment">//&#32;terms&#32;of&#32;the&#32;GNU&#32;General&#32;Public&#32;License&#32;as&#32;published&#32;by&#32;the</emphasis>
8 <emphasis role="comment">//&#32;Free&#32;Software&#32;Foundation;&#32;either&#32;version&#32;3,&#32;or&#32;(at&#32;your&#32;option)</emphasis>
9 <emphasis role="comment">//&#32;any&#32;later&#32;version.</emphasis>
10 
11 <emphasis role="comment">//&#32;This&#32;library&#32;is&#32;distributed&#32;in&#32;the&#32;hope&#32;that&#32;it&#32;will&#32;be&#32;useful,</emphasis>
12 <emphasis role="comment">//&#32;but&#32;WITHOUT&#32;ANY&#32;WARRANTY;&#32;without&#32;even&#32;the&#32;implied&#32;warranty&#32;of</emphasis>
13 <emphasis role="comment">//&#32;MERCHANTABILITY&#32;or&#32;FITNESS&#32;FOR&#32;A&#32;PARTICULAR&#32;PURPOSE.&#32;&#32;See&#32;the</emphasis>
14 <emphasis role="comment">//&#32;GNU&#32;General&#32;Public&#32;License&#32;for&#32;more&#32;details.</emphasis>
15 
16 <emphasis role="comment">//&#32;Under&#32;Section&#32;7&#32;of&#32;GPL&#32;version&#32;3,&#32;you&#32;are&#32;granted&#32;additional</emphasis>
17 <emphasis role="comment">//&#32;permissions&#32;described&#32;in&#32;the&#32;GCC&#32;Runtime&#32;Library&#32;Exception,&#32;version</emphasis>
18 <emphasis role="comment">//&#32;3.1,&#32;as&#32;published&#32;by&#32;the&#32;Free&#32;Software&#32;Foundation.</emphasis>
19 
20 <emphasis role="comment">//&#32;You&#32;should&#32;have&#32;received&#32;a&#32;copy&#32;of&#32;the&#32;GNU&#32;General&#32;Public&#32;License&#32;and</emphasis>
21 <emphasis role="comment">//&#32;a&#32;copy&#32;of&#32;the&#32;GCC&#32;Runtime&#32;Library&#32;Exception&#32;along&#32;with&#32;this&#32;program;</emphasis>
22 <emphasis role="comment">//&#32;see&#32;the&#32;files&#32;COPYING3&#32;and&#32;COPYING.RUNTIME&#32;respectively.&#32;&#32;If&#32;not,&#32;see</emphasis>
23 <emphasis role="comment">//&#32;&lt;http://www.gnu.org/licenses/&gt;.</emphasis>
24 
30 <emphasis role="preprocessor">#ifndef&#32;_HASHTABLE_H</emphasis>
31 <emphasis role="preprocessor">#define&#32;_HASHTABLE_H&#32;1</emphasis>
32 
33 <emphasis role="preprocessor">#pragma&#32;GCC&#32;system_header</emphasis>
34 
35 <emphasis role="preprocessor">#include&#32;&lt;bits/hashtable_policy.h&gt;</emphasis>
36 <emphasis role="preprocessor">#include&#32;&lt;bits/enable_special_members.h&gt;</emphasis>
37 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201402L</emphasis>
38 <emphasis role="preprocessor">#&#32;include&#32;&lt;bits/node_handle.h&gt;</emphasis>
39 <emphasis role="preprocessor">#endif</emphasis>
40 <emphasis role="preprocessor">#include&#32;&lt;bits/functional_hash.h&gt;</emphasis>
41 <emphasis role="preprocessor">#include&#32;&lt;bits/stl_function.h&gt;</emphasis>&#32;<emphasis role="comment">//&#32;equal_to,&#32;_Identity,&#32;_Select1st</emphasis>
42 
43 <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespacestd">std</link>&#32;<link linkend="__classes_2lib_2include_2c_09_09_2x86__64-w64-mingw32_2bits_2c_09_09config_8h_1a44377df0d3503f0b3d9ab316dd8ddf8b">_GLIBCXX_VISIBILITY</link>(default)
44 {
45 _GLIBCXX_BEGIN_NAMESPACE_VERSION
47 
48 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Tp,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash&gt;
49 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__cache_default
50 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;&#32;__not_&lt;__and_&lt;<emphasis role="comment">//&#32;Do&#32;not&#32;cache&#32;for&#32;fast&#32;hasher.</emphasis>
51 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__is_fast_hash&lt;_Hash&gt;,
52 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Mandatory&#32;to&#32;have&#32;erase&#32;not&#32;throwing.</emphasis>
53 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__is_nothrow_invocable&lt;const&#32;_Hash&amp;,&#32;const&#32;_Tp&amp;&gt;&gt;&gt;;
54 
55 &#32;&#32;<emphasis role="comment">//&#32;Helper&#32;to&#32;conditionally&#32;delete&#32;the&#32;default&#32;constructor.</emphasis>
56 &#32;&#32;<emphasis role="comment">//&#32;The&#32;_Hash_node_base&#32;type&#32;is&#32;used&#32;to&#32;distinguish&#32;this&#32;specialization</emphasis>
57 &#32;&#32;<emphasis role="comment">//&#32;from&#32;any&#32;other&#32;potentially-overlapping&#32;subobjects&#32;of&#32;the&#32;hashtable.</emphasis>
58 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Equal,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Allocator&gt;
59 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_Hashtable_enable_default_ctor
60 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_Enable_default_constructor&lt;__and_&lt;is_default_constructible&lt;_Equal&gt;,
61 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;is_default_constructible&lt;_Hash&gt;,
62 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;is_default_constructible&lt;_Allocator&gt;&gt;{},
63 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__detail::_Hash_node_base&gt;;
64 
178 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
180 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
181 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
182 &#32;&#32;&#32;&#32;<emphasis role="keyword">class&#32;</emphasis>_Hashtable
183 &#32;&#32;&#32;&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;__detail::_Hashtable_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,&#32;_Equal,
184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_Traits&gt;,
185 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;__detail::_Map_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
187 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;,
188 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;__detail::_Insert&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
189 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
190 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;,
191 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;__detail::_Rehash_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
192 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
193 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;,
194 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;__detail::_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
195 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
196 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;,
197 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;__detail::_Hashtable_alloc&lt;
198 &#32;&#32;&#32;&#32;__alloc_rebind&lt;_Alloc,
199 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__detail::_Hash_node&lt;_Value,
200 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Traits::__hash_cached::value&gt;&gt;&gt;,
201 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>&#32;_Hashtable_enable_default_ctor&lt;_Equal,&#32;_Hash,&#32;_Alloc&gt;
202 &#32;&#32;&#32;&#32;{
203 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_same&lt;typename&#32;remove_cv&lt;_Value&gt;::type,&#32;_Value&gt;<link linkend="_classvalue">::value</link>,
204 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;unordered&#32;container&#32;must&#32;have&#32;a&#32;non-const,&#32;non-volatile&#32;value_type&quot;</emphasis>);
205 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201703L&#32;||&#32;defined&#32;__STRICT_ANSI__</emphasis>
206 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_same&lt;typename&#32;_Alloc::value_type,&#32;_Value&gt;{},
207 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;unordered&#32;container&#32;must&#32;have&#32;the&#32;same&#32;value_type&#32;as&#32;its&#32;allocator&quot;</emphasis>);
208 <emphasis role="preprocessor">#endif</emphasis>
209 
210 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__traits_type&#32;=&#32;_Traits;
211 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_cached&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__traits_type::__hash_cached;
212 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__constant_iterators&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__traits_type::__constant_iterators;
213 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_type&#32;=&#32;__detail::_Hash_node&lt;_Value,&#32;__hash_cached::value&gt;;
214 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_type&#32;=&#32;__alloc_rebind&lt;_Alloc,&#32;__node_type&gt;;
215 
216 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_alloc&#32;=&#32;__detail::_Hashtable_alloc&lt;__node_alloc_type&gt;;
217 
218 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_value_type&#32;=
219 &#32;&#32;&#32;&#32;__detail::_Hash_node_value&lt;_Value,&#32;__hash_cached::value&gt;;
220 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_ptr&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_ptr;
221 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__value_alloc_traits&#32;=
222 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__value_alloc_traits;
223 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_alloc_traits&#32;=
224 &#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_alloc_traits;
225 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_base&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_base;
226 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_base_ptr&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__node_base_ptr;
227 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__buckets_ptr&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_alloc::__buckets_ptr;
228 
229 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__insert_base&#32;=&#32;__detail::_Insert&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
230 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,
231 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RangeHash,&#32;_Unused,
232 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
233 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__enable_default_ctor
234 &#32;&#32;&#32;&#32;=&#32;_Hashtable_enable_default_ctor&lt;_Equal,&#32;_Hash,&#32;_Alloc&gt;;
235 
236 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
237 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Key&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key_type;
238 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Value&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;value_type;
239 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Alloc&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;allocator_type;
240 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;_Equal&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key_equal;
241 
242 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;mapped_type,&#32;if&#32;present,&#32;comes&#32;from&#32;_Map_base.</emphasis>
243 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;hasher,&#32;if&#32;present,&#32;comes&#32;from&#32;_Hash_code_base/_Hashtable_base.</emphasis>
244 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;__value_alloc_traits::pointer&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1aca2093d4756bde9a55b94e9ff8d9c623">pointer</link>;
245 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">typename</emphasis>&#32;__value_alloc_traits::const_pointer&#32;&#32;const_pointer;
246 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;value_type&amp;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reference;
247 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;const_reference;
248 
249 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>iterator&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__insert_base::iterator;
250 
251 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>const_iterator&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__insert_base::const_iterator;
252 
253 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>local_iterator&#32;=&#32;__detail::_Local_iterator&lt;key_type,&#32;_Value,
254 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_ExtractKey,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
255 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__constant_iterators::value,
256 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_cached::value&gt;;
257 
258 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>const_local_iterator&#32;=&#32;__detail::_Local_const_iterator&lt;
259 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;key_type,&#32;_Value,
260 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_ExtractKey,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
261 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__constant_iterators::value,&#32;__hash_cached::value&gt;;
262 
263 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
264 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__rehash_type&#32;=&#32;_RehashPolicy;
265 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__rehash_state&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__rehash_type::_State;
266 
267 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__unique_keys&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__traits_type::__unique_keys;
268 
269 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hashtable_base&#32;=&#32;__detail::
270 &#32;&#32;&#32;&#32;_Hashtable_base&lt;_Key,&#32;_Value,&#32;_ExtractKey,
271 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_Traits&gt;;
272 
273 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base&#32;=&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::__hash_code_base;
274 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code&#32;=&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::__hash_code;
275 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__ireturn_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__insert_base::__ireturn_type;
276 
277 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__map_base&#32;=&#32;__detail::_Map_base&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
278 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
279 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
280 
281 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__rehash_base&#32;=&#32;__detail::_Rehash_base&lt;_Key,&#32;_Value,&#32;_Alloc,
282 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_ExtractKey,&#32;_Equal,
283 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
284 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
285 
286 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__eq_base&#32;=&#32;__detail::_Equality&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,
287 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Equal,&#32;_Hash,&#32;_RangeHash,&#32;_Unused,
288 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy,&#32;_Traits&gt;;
289 
290 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__reuse_or_alloc_node_gen_t&#32;=
291 &#32;&#32;&#32;&#32;__detail::_ReuseOrAllocNode&lt;__node_alloc_type&gt;;
292 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__alloc_node_gen_t&#32;=
293 &#32;&#32;&#32;&#32;__detail::_AllocNode&lt;__node_alloc_type&gt;;
294 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>__node_builder_t&#32;=
295 &#32;&#32;&#32;&#32;__detail::_NodeBuilder&lt;_ExtractKey&gt;;
296 
297 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Simple&#32;RAII&#32;type&#32;for&#32;managing&#32;a&#32;node&#32;containing&#32;an&#32;element</emphasis>
298 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>_Scoped_node
299 &#32;&#32;&#32;&#32;&#32;&#32;{
300 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Take&#32;ownership&#32;of&#32;a&#32;node&#32;with&#32;a&#32;constructed&#32;element.</emphasis>
301 &#32;&#32;&#32;&#32;_Scoped_node(__node_ptr&#32;__n,&#32;__hashtable_alloc*&#32;__h)
302 &#32;&#32;&#32;&#32;:&#32;_M_h(__h),&#32;_M_node(__n)&#32;{&#32;}
303 
304 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Allocate&#32;a&#32;node&#32;and&#32;construct&#32;an&#32;element&#32;within&#32;it.</emphasis>
305 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
306 &#32;&#32;&#32;&#32;&#32;&#32;_Scoped_node(__hashtable_alloc*&#32;__h,&#32;_Args&amp;&amp;...&#32;__args)
307 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_M_h(__h),
308 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_node(__h-&gt;_M_allocate_node(std::forward&lt;_Args&gt;(__args)...))
309 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
310 
311 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Destroy&#32;element&#32;and&#32;deallocate&#32;node.</emphasis>
312 &#32;&#32;&#32;&#32;~_Scoped_node()&#32;{&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_node)&#32;_M_h-&gt;_M_deallocate_node(_M_node);&#32;};
313 
314 &#32;&#32;&#32;&#32;_Scoped_node(<emphasis role="keyword">const</emphasis>&#32;_Scoped_node&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
315 &#32;&#32;&#32;&#32;_Scoped_node&amp;&#32;operator=(<emphasis role="keyword">const</emphasis>&#32;_Scoped_node&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
316 
317 &#32;&#32;&#32;&#32;__hashtable_alloc*&#32;_M_h;
318 &#32;&#32;&#32;&#32;__node_ptr&#32;_M_node;
319 &#32;&#32;&#32;&#32;&#32;&#32;};
320 
321 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Ht&gt;
322 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>
323 &#32;&#32;&#32;&#32;__conditional_t&lt;std::is_lvalue_reference&lt;_Ht&gt;::value,
324 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;value_type&amp;,&#32;value_type&amp;&amp;&gt;
325 &#32;&#32;&#32;&#32;__fwd_value_for(value_type&amp;&#32;<link linkend="__classes_2lib_2include_2stdatomic_8h_1a15181bfd16829c92971879064b9d8dbb">__val</link>)&#32;<emphasis role="keyword">noexcept</emphasis>
326 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(<link linkend="__classes_2lib_2include_2stdatomic_8h_1a15181bfd16829c92971879064b9d8dbb">__val</link>);&#32;}
327 
328 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Compile-time&#32;diagnostics.</emphasis>
329 
330 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_Hash_code_base&#32;has&#32;everything&#32;protected,&#32;so&#32;use&#32;this&#32;derived&#32;type&#32;to</emphasis>
331 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;access&#32;it.</emphasis>
332 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">struct&#32;</emphasis>__hash_code_base_access&#32;:&#32;__hash_code_base
333 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keyword">using&#32;</emphasis>__hash_code_base::_M_bucket_index;&#32;};
334 
335 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;To&#32;get&#32;bucket&#32;index&#32;we&#32;need&#32;_RangeHash&#32;not&#32;to&#32;throw.</emphasis>
336 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_nothrow_default_constructible&lt;_RangeHash&gt;::value,
337 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Functor&#32;used&#32;to&#32;map&#32;hash&#32;code&#32;to&#32;bucket&#32;index&quot;</emphasis>
338 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;must&#32;be&#32;nothrow&#32;default&#32;constructible&quot;</emphasis>);
339 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(<emphasis role="keyword">noexcept</emphasis>(
340 &#32;&#32;&#32;&#32;std::declval&lt;const&#32;_RangeHash&amp;&gt;()((std::size_t)0,&#32;(std::size_t)0)),
341 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Functor&#32;used&#32;to&#32;map&#32;hash&#32;code&#32;to&#32;bucket&#32;index&#32;must&#32;be&quot;</emphasis>
342 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;noexcept&quot;</emphasis>);
343 
344 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;To&#32;compute&#32;bucket&#32;index&#32;we&#32;also&#32;need&#32;_ExtratKey&#32;not&#32;to&#32;throw.</emphasis>
345 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_nothrow_default_constructible&lt;_ExtractKey&gt;::value,
346 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;_ExtractKey&#32;must&#32;be&#32;nothrow&#32;default&#32;constructible&quot;</emphasis>);
347 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(<emphasis role="keyword">noexcept</emphasis>(
348 &#32;&#32;&#32;&#32;std::declval&lt;const&#32;_ExtractKey&amp;&gt;()(std::declval&lt;_Value&gt;())),
349 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;_ExtractKey&#32;functor&#32;must&#32;be&#32;noexcept&#32;invocable&quot;</emphasis>);
350 
351 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Keya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Valuea,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloca,
352 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKeya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equala,
353 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unuseda,
354 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traitsa,
355 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Unique_keysa&gt;
356 &#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keyword">struct&#32;</emphasis>__detail::_Map_base;
357 
358 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Keya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Valuea,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloca,
359 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKeya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equala,
360 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unuseda,
361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traitsa&gt;
362 &#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keyword">struct&#32;</emphasis>__detail::_Insert_base;
363 
364 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Keya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Valuea,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloca,
365 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKeya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equala,
366 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unuseda,
367 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traitsa,
368 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Constant_iteratorsa&gt;
369 &#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keyword">struct&#32;</emphasis>__detail::_Insert;
370 
371 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Keya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Valuea,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloca,
372 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKeya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equala,
373 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHasha,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unuseda,
374 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicya,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traitsa,
375 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;_Unique_keysa&gt;
376 &#32;&#32;&#32;&#32;<emphasis role="keyword">friend</emphasis>&#32;<emphasis role="keyword">struct&#32;</emphasis>__detail::_Equality;
377 
378 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
379 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>size_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::size_type;
380 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>difference_type&#32;=&#32;<emphasis role="keyword">typename</emphasis>&#32;__hashtable_base::difference_type;
381 
382 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201402L</emphasis>
383 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>node_type&#32;=&#32;_Node_handle&lt;_Key,&#32;_Value,&#32;__node_alloc_type&gt;;
384 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>insert_return_type&#32;=&#32;_Node_insert_return&lt;iterator,&#32;node_type&gt;;
385 <emphasis role="preprocessor">#endif</emphasis>
386 
387 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
388 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;&#32;&#32;&#32;&#32;&#32;=&#32;&amp;_M_single_bucket;
389 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;&#32;&#32;&#32;&#32;=&#32;1;
390 &#32;&#32;&#32;&#32;&#32;&#32;__node_base&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin;
391 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;&#32;&#32;&#32;=&#32;0;
392 &#32;&#32;&#32;&#32;&#32;&#32;_RehashPolicy&#32;&#32;&#32;&#32;&#32;_M_rehash_policy;
393 
394 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;A&#32;single&#32;bucket&#32;used&#32;when&#32;only&#32;need&#32;for&#32;1&#32;bucket.&#32;Especially</emphasis>
395 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;interesting&#32;in&#32;move&#32;semantic&#32;to&#32;leave&#32;hashtable&#32;with&#32;only&#32;1&#32;bucket</emphasis>
396 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;which&#32;is&#32;not&#32;allocated&#32;so&#32;that&#32;we&#32;can&#32;have&#32;those&#32;operations&#32;noexcept</emphasis>
397 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;qualified.</emphasis>
398 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Note&#32;that&#32;we&#32;can&apos;t&#32;leave&#32;hashtable&#32;with&#32;0&#32;bucket&#32;without&#32;adding</emphasis>
399 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;numerous&#32;checks&#32;in&#32;the&#32;code&#32;to&#32;avoid&#32;0&#32;modulus.</emphasis>
400 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;&#32;&#32;&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
401 
402 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
403 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin()
404 &#32;&#32;&#32;&#32;&#32;&#32;{
405 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_begin())
406 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[_M_bucket_index(*_M_begin())]&#32;=&#32;&amp;_M_before_begin;
407 &#32;&#32;&#32;&#32;&#32;&#32;}
408 
409 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
410 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin(__node_ptr&#32;__n)
411 &#32;&#32;&#32;&#32;&#32;&#32;{
412 &#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__n;
413 &#32;&#32;&#32;&#32;_M_update_bbegin();
414 &#32;&#32;&#32;&#32;&#32;&#32;}
415 
416 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
417 &#32;&#32;&#32;&#32;&#32;&#32;_M_uses_single_bucket(__buckets_ptr&#32;__bkts)<emphasis role="keyword">&#32;const</emphasis>
418 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__builtin_expect(__bkts&#32;==&#32;&amp;_M_single_bucket,&#32;<emphasis role="keyword">false</emphasis>);&#32;}
419 
420 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>
421 &#32;&#32;&#32;&#32;&#32;&#32;_M_uses_single_bucket()<emphasis role="keyword">&#32;const</emphasis>
422 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_uses_single_bucket(_M_buckets);&#32;}
423 
424 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>
425 &#32;&#32;&#32;&#32;&#32;&#32;__small_size_threshold()&#32;<emphasis role="keyword">noexcept</emphasis>
426 &#32;&#32;&#32;&#32;&#32;&#32;{
427 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>
428 &#32;&#32;&#32;&#32;&#32;&#32;__detail::_Hashtable_hash_traits&lt;_Hash&gt;::__small_size_threshold();
429 &#32;&#32;&#32;&#32;&#32;&#32;}
430 
431 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc&amp;
432 &#32;&#32;&#32;&#32;&#32;&#32;_M_base_alloc()&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;&#32;}
433 
434 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr
435 &#32;&#32;&#32;&#32;&#32;&#32;_M_allocate_buckets(size_type&#32;__bkt_count)
436 &#32;&#32;&#32;&#32;&#32;&#32;{
437 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__builtin_expect(__bkt_count&#32;==&#32;1,&#32;<emphasis role="keyword">false</emphasis>))
438 &#32;&#32;&#32;&#32;&#32;&#32;{
439 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
440 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;&amp;_M_single_bucket;
441 &#32;&#32;&#32;&#32;&#32;&#32;}
442 
443 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__hashtable_alloc::_M_allocate_buckets(__bkt_count);
444 &#32;&#32;&#32;&#32;&#32;&#32;}
445 
446 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
447 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets(__buckets_ptr&#32;__bkts,&#32;size_type&#32;__bkt_count)
448 &#32;&#32;&#32;&#32;&#32;&#32;{
449 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_uses_single_bucket(__bkts))
450 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
451 
452 &#32;&#32;&#32;&#32;__hashtable_alloc::_M_deallocate_buckets(__bkts,&#32;__bkt_count);
453 &#32;&#32;&#32;&#32;&#32;&#32;}
454 
455 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
456 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets()
457 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;_M_deallocate_buckets(_M_buckets,&#32;_M_bucket_count);&#32;}
458 
459 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Gets&#32;bucket&#32;begin,&#32;deals&#32;with&#32;the&#32;fact&#32;that&#32;non-empty&#32;buckets&#32;contain</emphasis>
460 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;their&#32;before&#32;begin&#32;node.</emphasis>
461 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr
462 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_begin(size_type&#32;__bkt)&#32;<emphasis role="keyword">const</emphasis>;
463 
464 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr
465 &#32;&#32;&#32;&#32;&#32;&#32;_M_begin()<emphasis role="keyword">&#32;const</emphasis>
466 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(_M_before_begin._M_nxt);&#32;}
467 
468 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Assign&#32;*this&#32;using&#32;another&#32;_Hashtable&#32;instance.&#32;Whether&#32;elements</emphasis>
469 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;are&#32;copied&#32;or&#32;moved&#32;depends&#32;on&#32;the&#32;_Ht&#32;reference.</emphasis>
470 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Ht&gt;
471 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
472 &#32;&#32;&#32;&#32;_M_assign_elements(_Ht&amp;&amp;);
473 
474 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Ht,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
475 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
476 &#32;&#32;&#32;&#32;_M_assign(_Ht&amp;&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;);
477 
478 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
479 &#32;&#32;&#32;&#32;&#32;&#32;_M_move_assign(_Hashtable&amp;&amp;,&#32;true_type);
480 
481 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
482 &#32;&#32;&#32;&#32;&#32;&#32;_M_move_assign(_Hashtable&amp;&amp;,&#32;false_type);
483 
484 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
485 &#32;&#32;&#32;&#32;&#32;&#32;_M_reset()&#32;<emphasis role="keyword">noexcept</emphasis>;
486 
487 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__h,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;&#32;__eq,
488 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a)
489 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__hashtable_base(__h,&#32;__eq),
490 &#32;&#32;&#32;&#32;__hashtable_alloc(__node_alloc_type(__a)),
491 &#32;&#32;&#32;&#32;__enable_default_ctor(_Enable_default_constructor_tag{})
492 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
493 
494 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keywordtype">bool</emphasis>&#32;_No_realloc&#32;=&#32;true&gt;
495 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>
496 &#32;&#32;&#32;&#32;_S_nothrow_move()
497 &#32;&#32;&#32;&#32;{
498 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&lt;=&#32;201402L</emphasis>
499 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__and_&lt;__bool_constant&lt;_No_realloc&gt;,
500 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;is_nothrow_copy_constructible&lt;_Hash&gt;,
501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;is_nothrow_copy_constructible&lt;_Equal&gt;&gt;<link linkend="_classvalue">::value</link>;
502 <emphasis role="preprocessor">#else</emphasis>
503 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;(_No_realloc)
504 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;<emphasis role="keyword">constexpr</emphasis>&#32;(is_nothrow_copy_constructible&lt;_Hash&gt;())
505 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;is_nothrow_copy_constructible&lt;_Equal&gt;();
506 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
507 <emphasis role="preprocessor">#endif</emphasis>
508 &#32;&#32;&#32;&#32;}
509 
510 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;&#32;__ht,&#32;__node_alloc_type&amp;&amp;&#32;__a,
511 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type&#32;<emphasis role="comment">/*&#32;alloc&#32;always&#32;equal&#32;*/</emphasis>)
512 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(_S_nothrow_move());
513 
514 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;,&#32;__node_alloc_type&amp;&amp;,
515 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;<emphasis role="comment">/*&#32;alloc&#32;always&#32;equal&#32;*/</emphasis>);
516 
517 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
518 &#32;&#32;&#32;&#32;_Hashtable(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
519 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint,
520 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;,
521 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type&#32;__uks);
522 
523 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
524 &#32;&#32;&#32;&#32;_Hashtable(_InputIterator&#32;__first,&#32;_InputIterator&#32;__last,
525 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint,
526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;,
527 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;__uks);
528 
529 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
530 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Constructor,&#32;destructor,&#32;assignment,&#32;swap</emphasis>
531 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
532 
533 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;);
534 
535 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;);
536 
537 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">explicit</emphasis>
538 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(size_type&#32;__bkt_count_hint,
539 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__hf&#32;=&#32;_Hash(),
540 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_equal&amp;&#32;__eql&#32;=&#32;key_equal(),
541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a&#32;=&#32;allocator_type());
542 
543 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Use&#32;delegating&#32;constructors.</emphasis>
544 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;&#32;__ht)
545 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(_S_nothrow_move())
546 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_Hashtable(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht),&#32;<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht._M_node_allocator()),
547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type{})
548 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
549 
550 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;&#32;__ht,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a)
551 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(_S_nothrow_move&lt;__node_alloc_traits::_S_always_equal()&gt;())
552 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_Hashtable(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht),&#32;__node_alloc_type(__a),
553 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;__node_alloc_traits::is_always_equal{})
554 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
555 
556 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">explicit</emphasis>
557 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a)
558 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;__hashtable_alloc(__node_alloc_type(__a)),
559 &#32;&#32;&#32;&#32;__enable_default_ctor(_Enable_default_constructor_tag{})
560 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
561 
562 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
563 &#32;&#32;&#32;&#32;_Hashtable(_InputIterator&#32;__f,&#32;_InputIterator&#32;__l,
564 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint&#32;=&#32;0,
565 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__hf&#32;=&#32;_Hash(),
566 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_equal&amp;&#32;__eql&#32;=&#32;key_equal(),
567 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a&#32;=&#32;allocator_type())
568 &#32;&#32;&#32;&#32;:&#32;_Hashtable(__f,&#32;__l,&#32;__bkt_count_hint,&#32;__hf,&#32;__eql,&#32;__a,
569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__unique_keys{})
570 &#32;&#32;&#32;&#32;{&#32;}
571 
572 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(initializer_list&lt;value_type&gt;&#32;__l,
573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint&#32;=&#32;0,
574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__hf&#32;=&#32;_Hash(),
575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_equal&amp;&#32;__eql&#32;=&#32;key_equal(),
576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a&#32;=&#32;allocator_type())
577 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_Hashtable(__l.begin(),&#32;__l.end(),&#32;__bkt_count_hint,
578 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hf,&#32;__eql,&#32;__a,&#32;__unique_keys{})
579 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;}
580 
581 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&amp;
582 &#32;&#32;&#32;&#32;&#32;&#32;operator=(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;&#32;__ht);
583 
584 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&amp;
585 &#32;&#32;&#32;&#32;&#32;&#32;operator=(_Hashtable&amp;&amp;&#32;__ht)
586 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(__node_alloc_traits::_S_nothrow_move()
587 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;is_nothrow_move_assignable&lt;_Hash&gt;::value
588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;is_nothrow_move_assignable&lt;_Equal&gt;::value)
589 &#32;&#32;&#32;&#32;&#32;&#32;{
590 &#32;&#32;&#32;&#32;<emphasis role="keyword">constexpr</emphasis>&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__move_storage&#32;=
591 &#32;&#32;&#32;&#32;&#32;&#32;__node_alloc_traits::_S_propagate_on_move_assign()
592 &#32;&#32;&#32;&#32;&#32;&#32;||&#32;__node_alloc_traits::_S_always_equal();
593 &#32;&#32;&#32;&#32;_M_move_assign(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht),&#32;__bool_constant&lt;__move_storage&gt;());
594 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
595 &#32;&#32;&#32;&#32;&#32;&#32;}
596 
597 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&amp;
598 &#32;&#32;&#32;&#32;&#32;&#32;operator=(initializer_list&lt;value_type&gt;&#32;__l)
599 &#32;&#32;&#32;&#32;&#32;&#32;{
600 &#32;&#32;&#32;&#32;__reuse_or_alloc_node_gen_t&#32;__roan(_M_begin(),&#32;*<emphasis role="keyword">this</emphasis>);
601 &#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
602 &#32;&#32;&#32;&#32;clear();
603 
604 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;consider&#32;that&#32;all&#32;elements&#32;of&#32;__l&#32;are&#32;going&#32;to&#32;be&#32;inserted.</emphasis>
605 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__l_bkt_count&#32;=&#32;_M_rehash_policy._M_bkt_for_elements(__l.size());
606 
607 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Do&#32;not&#32;shrink&#32;to&#32;keep&#32;potential&#32;user&#32;reservation.</emphasis>
608 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;&lt;&#32;__l_bkt_count)
609 &#32;&#32;&#32;&#32;&#32;&#32;rehash(__l_bkt_count);
610 
611 &#32;&#32;&#32;&#32;this-&gt;_M_insert_range(__l.begin(),&#32;__l.end(),&#32;__roan,&#32;__unique_keys{});
612 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
613 &#32;&#32;&#32;&#32;&#32;&#32;}
614 
615 &#32;&#32;&#32;&#32;&#32;&#32;~_Hashtable()&#32;<emphasis role="keyword">noexcept</emphasis>;
616 
617 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
618 &#32;&#32;&#32;&#32;&#32;&#32;swap(_Hashtable&amp;)
619 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(__and_&lt;__is_nothrow_swappable&lt;_Hash&gt;,
620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__is_nothrow_swappable&lt;_Equal&gt;&gt;<link linkend="_classvalue">::value</link>);
621 
622 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Basic&#32;container&#32;operations</emphasis>
623 &#32;&#32;&#32;&#32;&#32;&#32;iterator
624 &#32;&#32;&#32;&#32;&#32;&#32;begin()&#32;<emphasis role="keyword">noexcept</emphasis>
625 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(_M_begin());&#32;}
626 
627 &#32;&#32;&#32;&#32;&#32;&#32;const_iterator
628 &#32;&#32;&#32;&#32;&#32;&#32;begin()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
629 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(_M_begin());&#32;}
630 
631 &#32;&#32;&#32;&#32;&#32;&#32;iterator
632 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>()&#32;<emphasis role="keyword">noexcept</emphasis>
633 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(<emphasis role="keyword">nullptr</emphasis>);&#32;}
634 
635 &#32;&#32;&#32;&#32;&#32;&#32;const_iterator
636 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
637 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(<emphasis role="keyword">nullptr</emphasis>);&#32;}
638 
639 &#32;&#32;&#32;&#32;&#32;&#32;const_iterator
640 &#32;&#32;&#32;&#32;&#32;&#32;cbegin()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
641 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(_M_begin());&#32;}
642 
643 &#32;&#32;&#32;&#32;&#32;&#32;const_iterator
644 &#32;&#32;&#32;&#32;&#32;&#32;cend()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
645 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(<emphasis role="keyword">nullptr</emphasis>);&#32;}
646 
647 &#32;&#32;&#32;&#32;&#32;&#32;size_type
648 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
649 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_element_count;&#32;}
650 
651 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2x86__64-w64-mingw32_2bits_2c_09_09config_8h_1a56bc959ca1311889bcd1c5abb178ab59">_GLIBCXX_NODISCARD</link>&#32;<emphasis role="keywordtype">bool</emphasis>
652 &#32;&#32;&#32;&#32;&#32;&#32;empty()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
653 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;==&#32;0;&#32;}
654 
655 &#32;&#32;&#32;&#32;&#32;&#32;allocator_type
656 &#32;&#32;&#32;&#32;&#32;&#32;get_allocator()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
657 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;allocator_type(this-&gt;_M_node_allocator());&#32;}
658 
659 &#32;&#32;&#32;&#32;&#32;&#32;size_type
660 &#32;&#32;&#32;&#32;&#32;&#32;max_size()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
661 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__node_alloc_traits::max_size(this-&gt;_M_node_allocator());&#32;}
662 
663 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Observers</emphasis>
664 &#32;&#32;&#32;&#32;&#32;&#32;key_equal
665 &#32;&#32;&#32;&#32;&#32;&#32;key_eq()<emphasis role="keyword">&#32;const</emphasis>
666 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;this-&gt;_M_eq();&#32;}
667 
668 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;hash_function,&#32;if&#32;present,&#32;comes&#32;from&#32;_Hash_code_base.</emphasis>
669 
670 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Bucket&#32;operations</emphasis>
671 &#32;&#32;&#32;&#32;&#32;&#32;size_type
672 &#32;&#32;&#32;&#32;&#32;&#32;bucket_count()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
673 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_bucket_count;&#32;}
674 
675 &#32;&#32;&#32;&#32;&#32;&#32;size_type
676 &#32;&#32;&#32;&#32;&#32;&#32;max_bucket_count()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
677 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;max_size();&#32;}
678 
679 &#32;&#32;&#32;&#32;&#32;&#32;size_type
680 &#32;&#32;&#32;&#32;&#32;&#32;bucket_size(size_type&#32;__bkt)<emphasis role="keyword">&#32;const</emphasis>
681 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::distance(begin(__bkt),&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>(__bkt));&#32;}
682 
683 &#32;&#32;&#32;&#32;&#32;&#32;size_type
684 &#32;&#32;&#32;&#32;&#32;&#32;bucket(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)<emphasis role="keyword">&#32;const</emphasis>
685 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_bucket_index(this-&gt;_M_hash_code(__k));&#32;}
686 
687 &#32;&#32;&#32;&#32;&#32;&#32;local_iterator
688 &#32;&#32;&#32;&#32;&#32;&#32;begin(size_type&#32;__bkt)
689 &#32;&#32;&#32;&#32;&#32;&#32;{
690 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;_M_bucket_begin(__bkt),
691 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt,&#32;_M_bucket_count);
692 &#32;&#32;&#32;&#32;&#32;&#32;}
693 
694 &#32;&#32;&#32;&#32;&#32;&#32;local_iterator
695 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>(size_type&#32;__bkt)
696 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;__bkt,&#32;_M_bucket_count);&#32;}
697 
698 &#32;&#32;&#32;&#32;&#32;&#32;const_local_iterator
699 &#32;&#32;&#32;&#32;&#32;&#32;begin(size_type&#32;__bkt)<emphasis role="keyword">&#32;const</emphasis>
700 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
701 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;_M_bucket_begin(__bkt),
702 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt,&#32;_M_bucket_count);
703 &#32;&#32;&#32;&#32;&#32;&#32;}
704 
705 &#32;&#32;&#32;&#32;&#32;&#32;const_local_iterator
706 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>(size_type&#32;__bkt)<emphasis role="keyword">&#32;const</emphasis>
707 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;__bkt,&#32;_M_bucket_count);&#32;}
708 
709 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;DR&#32;691.</emphasis>
710 &#32;&#32;&#32;&#32;&#32;&#32;const_local_iterator
711 &#32;&#32;&#32;&#32;&#32;&#32;cbegin(size_type&#32;__bkt)<emphasis role="keyword">&#32;const</emphasis>
712 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
713 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;_M_bucket_begin(__bkt),
714 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt,&#32;_M_bucket_count);
715 &#32;&#32;&#32;&#32;&#32;&#32;}
716 
717 &#32;&#32;&#32;&#32;&#32;&#32;const_local_iterator
718 &#32;&#32;&#32;&#32;&#32;&#32;cend(size_type&#32;__bkt)<emphasis role="keyword">&#32;const</emphasis>
719 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_local_iterator(*<emphasis role="keyword">this</emphasis>,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;__bkt,&#32;_M_bucket_count);&#32;}
720 
721 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>
722 &#32;&#32;&#32;&#32;&#32;&#32;load_factor()&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
723 &#32;&#32;&#32;&#32;&#32;&#32;{
724 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis><emphasis role="keyword">&gt;</emphasis>(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>())&#32;/&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis><emphasis role="keyword">&gt;</emphasis>(bucket_count());
725 &#32;&#32;&#32;&#32;&#32;&#32;}
726 
727 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;max_load_factor,&#32;if&#32;present,&#32;comes&#32;from&#32;_Rehash_base.</emphasis>
728 
729 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Generalization&#32;of&#32;max_load_factor.&#32;&#32;Extension,&#32;not&#32;found&#32;in</emphasis>
730 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;TR1.&#32;&#32;Only&#32;useful&#32;if&#32;_RehashPolicy&#32;is&#32;something&#32;other&#32;than</emphasis>
731 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;the&#32;default.</emphasis>
732 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_RehashPolicy&amp;
733 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_policy()<emphasis role="keyword">&#32;const</emphasis>
734 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_rehash_policy;&#32;}
735 
736 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
737 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_policy(<emphasis role="keyword">const</emphasis>&#32;_RehashPolicy&amp;&#32;__pol)
738 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;_M_rehash_policy&#32;=&#32;__pol;&#32;}
739 
740 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Lookup.</emphasis>
741 &#32;&#32;&#32;&#32;&#32;&#32;iterator
742 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_toml_8hpp_1a334e40fb57f310a5de10f332f1914bf4">find</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k);
743 
744 &#32;&#32;&#32;&#32;&#32;&#32;const_iterator
745 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_toml_8hpp_1a334e40fb57f310a5de10f332f1914bf4">find</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
746 
747 &#32;&#32;&#32;&#32;&#32;&#32;size_type
748 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a22486c0c8d9f7d79a07bf22ecffeeb2f">count</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
749 
750 &#32;&#32;&#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;iterator&gt;
751 &#32;&#32;&#32;&#32;&#32;&#32;equal_range(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k);
752 
753 &#32;&#32;&#32;&#32;&#32;&#32;std::pair&lt;const_iterator,&#32;const_iterator&gt;
754 &#32;&#32;&#32;&#32;&#32;&#32;equal_range(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
755 
756 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;=&#32;202002L</emphasis>
757 <emphasis role="preprocessor">#define&#32;__cpp_lib_generic_unordered_lookup&#32;201811L</emphasis>
758 
759 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,
760 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Hash,&#32;_Kt&gt;,
761 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Equal,&#32;_Kt&gt;&gt;
762 &#32;&#32;&#32;&#32;iterator
763 &#32;&#32;&#32;&#32;_M_find_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k);
764 
765 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,
766 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Hash,&#32;_Kt&gt;,
767 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Equal,&#32;_Kt&gt;&gt;
768 &#32;&#32;&#32;&#32;const_iterator
769 &#32;&#32;&#32;&#32;_M_find_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
770 
771 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,
772 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Hash,&#32;_Kt&gt;,
773 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Equal,&#32;_Kt&gt;&gt;
774 &#32;&#32;&#32;&#32;size_type
775 &#32;&#32;&#32;&#32;_M_count_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
776 
777 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,
778 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Hash,&#32;_Kt&gt;,
779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Equal,&#32;_Kt&gt;&gt;
780 &#32;&#32;&#32;&#32;pair&lt;iterator,&#32;iterator&gt;
781 &#32;&#32;&#32;&#32;_M_equal_range_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k);
782 
783 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,
784 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Hash,&#32;_Kt&gt;,
785 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;=&#32;__has_is_transparent_t&lt;_Equal,&#32;_Kt&gt;&gt;
786 &#32;&#32;&#32;&#32;pair&lt;const_iterator,&#32;const_iterator&gt;
787 &#32;&#32;&#32;&#32;_M_equal_range_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
788 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;C++20</emphasis>
789 
790 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
791 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Bucket&#32;index&#32;computation&#32;helpers.</emphasis>
792 &#32;&#32;&#32;&#32;&#32;&#32;size_type
793 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_index(<emphasis role="keyword">const</emphasis>&#32;__node_value_type&amp;&#32;__n)&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">noexcept</emphasis>
794 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__hash_code_base::_M_bucket_index(__n,&#32;_M_bucket_count);&#32;}
795 
796 &#32;&#32;&#32;&#32;&#32;&#32;size_type
797 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_index(__hash_code&#32;__c)<emphasis role="keyword">&#32;const</emphasis>
798 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__hash_code_base::_M_bucket_index(__c,&#32;_M_bucket_count);&#32;}
799 
800 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr
801 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_before_node(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;);
802 
803 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Find&#32;and&#32;insert&#32;helper&#32;functions&#32;and&#32;types</emphasis>
804 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Find&#32;the&#32;node&#32;before&#32;the&#32;one&#32;matching&#32;the&#32;criteria.</emphasis>
805 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr
806 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_before_node(size_type,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;,&#32;__hash_code)&#32;<emphasis role="keyword">const</emphasis>;
807 
808 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
809 &#32;&#32;&#32;&#32;__node_base_ptr
810 &#32;&#32;&#32;&#32;_M_find_before_node_tr(size_type,&#32;<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;,&#32;__hash_code)&#32;<emphasis role="keyword">const</emphasis>;
811 
812 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr
813 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_node(size_type&#32;__bkt,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__key,
814 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__c)<emphasis role="keyword">&#32;const</emphasis>
815 <emphasis role="keyword">&#32;&#32;&#32;&#32;&#32;&#32;</emphasis>{
816 &#32;&#32;&#32;&#32;__node_base_ptr&#32;__before_n&#32;=&#32;_M_find_before_node(__bkt,&#32;__key,&#32;__c);
817 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__before_n)
818 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__before_n-&gt;_M_nxt);
819 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
820 &#32;&#32;&#32;&#32;&#32;&#32;}
821 
822 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
823 &#32;&#32;&#32;&#32;__node_ptr
824 &#32;&#32;&#32;&#32;_M_find_node_tr(size_type&#32;__bkt,&#32;<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__key,
825 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__c)<emphasis role="keyword">&#32;const</emphasis>
826 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
827 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__before_n&#32;=&#32;_M_find_before_node_tr(__bkt,&#32;__key,&#32;__c);
828 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__before_n)
829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__before_n-&gt;_M_nxt);
830 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
831 &#32;&#32;&#32;&#32;}
832 
833 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;a&#32;node&#32;at&#32;the&#32;beginning&#32;of&#32;a&#32;bucket.</emphasis>
834 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
835 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_bucket_begin(size_type,&#32;__node_ptr);
836 
837 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Remove&#32;the&#32;bucket&#32;first&#32;node</emphasis>
838 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
839 &#32;&#32;&#32;&#32;&#32;&#32;_M_remove_bucket_begin(size_type&#32;__bkt,&#32;__node_ptr&#32;__next_n,
840 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__next_bkt);
841 
842 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Get&#32;the&#32;node&#32;before&#32;__n&#32;in&#32;the&#32;bucket&#32;__bkt</emphasis>
843 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr
844 &#32;&#32;&#32;&#32;&#32;&#32;_M_get_previous_node(size_type&#32;__bkt,&#32;__node_ptr&#32;__n);
845 
846 &#32;&#32;&#32;&#32;&#32;&#32;pair&lt;const_iterator,&#32;__hash_code&gt;
847 &#32;&#32;&#32;&#32;&#32;&#32;_M_compute_hash_code(const_iterator&#32;__hint,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>;
848 
849 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;node&#32;__n&#32;with&#32;hash&#32;code&#32;__code,&#32;in&#32;bucket&#32;__bkt&#32;if&#32;no</emphasis>
850 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;rehash&#32;(assumes&#32;no&#32;element&#32;with&#32;same&#32;key&#32;already&#32;present).</emphasis>
851 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Takes&#32;ownership&#32;of&#32;__n&#32;if&#32;insertion&#32;succeeds,&#32;throws&#32;otherwise.</emphasis>
852 &#32;&#32;&#32;&#32;&#32;&#32;iterator
853 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_unique_node(size_type&#32;__bkt,&#32;__hash_code,
854 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n,&#32;size_type&#32;__n_elt&#32;=&#32;1);
855 
856 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;node&#32;__n&#32;with&#32;key&#32;__k&#32;and&#32;hash&#32;code&#32;__code.</emphasis>
857 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Takes&#32;ownership&#32;of&#32;__n&#32;if&#32;insertion&#32;succeeds,&#32;throws&#32;otherwise.</emphasis>
858 &#32;&#32;&#32;&#32;&#32;&#32;iterator
859 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_multi_node(__node_ptr&#32;__hint,
860 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code,&#32;__node_ptr&#32;__n);
861 
862 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
863 &#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;bool&gt;
864 &#32;&#32;&#32;&#32;_M_emplace(true_type&#32;__uks,&#32;_Args&amp;&amp;...&#32;__args);
865 
866 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
867 &#32;&#32;&#32;&#32;iterator
868 &#32;&#32;&#32;&#32;_M_emplace(false_type&#32;__uks,&#32;_Args&amp;&amp;...&#32;__args)
869 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_emplace(cend(),&#32;__uks,&#32;std::forward&lt;_Args&gt;(__args)...);&#32;}
870 
871 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Emplace&#32;with&#32;hint,&#32;useless&#32;when&#32;keys&#32;are&#32;unique.</emphasis>
872 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
873 &#32;&#32;&#32;&#32;iterator
874 &#32;&#32;&#32;&#32;_M_emplace(const_iterator,&#32;true_type&#32;__uks,&#32;_Args&amp;&amp;...&#32;__args)
875 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_emplace(__uks,&#32;std::forward&lt;_Args&gt;(__args)...).first;&#32;}
876 
877 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
878 &#32;&#32;&#32;&#32;iterator
879 &#32;&#32;&#32;&#32;_M_emplace(const_iterator,&#32;false_type&#32;__uks,&#32;_Args&amp;&amp;...&#32;__args);
880 
881 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
882 &#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;bool&gt;
883 &#32;&#32;&#32;&#32;_M_insert_unique(_Kt&amp;&amp;,&#32;_Arg&amp;&amp;,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;);
884 
885 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
886 &#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;__conditional_t&lt;
887 &#32;&#32;&#32;&#32;&#32;&#32;__and_&lt;__is_nothrow_invocable&lt;_Hash&amp;,&#32;const&#32;key_type&amp;&gt;,
888 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__not_&lt;__is_nothrow_invocable&lt;_Hash&amp;,&#32;_Kt&gt;&gt;&gt;<link linkend="_classvalue">::value</link>,
889 &#32;&#32;&#32;&#32;&#32;&#32;key_type,&#32;_Kt&amp;&amp;&gt;
890 &#32;&#32;&#32;&#32;_S_forward_key(_Kt&amp;&amp;&#32;__k)
891 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;std::forward&lt;_Kt&gt;(__k);&#32;}
892 
893 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;
894 &#32;&#32;&#32;&#32;&#32;&#32;_S_forward_key(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
895 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;__k;&#32;}
896 
897 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static</emphasis>&#32;key_type&amp;&amp;
898 &#32;&#32;&#32;&#32;&#32;&#32;_S_forward_key(key_type&amp;&amp;&#32;__k)
899 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__k);&#32;}
900 
901 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
902 &#32;&#32;&#32;&#32;std::pair&lt;iterator,&#32;bool&gt;
903 &#32;&#32;&#32;&#32;_M_insert(_Arg&amp;&amp;&#32;__arg,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen,
904 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
905 &#32;&#32;&#32;&#32;{
906 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_insert_unique(
907 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_S_forward_key(_ExtractKey{}(std::forward&lt;_Arg&gt;(__arg))),
908 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Arg&gt;(__arg),&#32;__node_gen);
909 &#32;&#32;&#32;&#32;}
910 
911 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
912 &#32;&#32;&#32;&#32;iterator
913 &#32;&#32;&#32;&#32;_M_insert(_Arg&amp;&amp;&#32;__arg,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen,
914 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;__uks)
915 &#32;&#32;&#32;&#32;{
916 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_insert(cend(),&#32;std::forward&lt;_Arg&gt;(__arg),&#32;__node_gen,
917 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__uks);
918 &#32;&#32;&#32;&#32;}
919 
920 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;with&#32;hint,&#32;not&#32;used&#32;when&#32;keys&#32;are&#32;unique.</emphasis>
921 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
922 &#32;&#32;&#32;&#32;iterator
923 &#32;&#32;&#32;&#32;_M_insert(const_iterator,&#32;_Arg&amp;&amp;&#32;__arg,
924 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen,&#32;true_type&#32;__uks)
925 &#32;&#32;&#32;&#32;{
926 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>
927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_insert(std::forward&lt;_Arg&gt;(__arg),&#32;__node_gen,&#32;__uks).first;
928 &#32;&#32;&#32;&#32;}
929 
930 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;with&#32;hint&#32;when&#32;keys&#32;are&#32;not&#32;unique.</emphasis>
931 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
932 &#32;&#32;&#32;&#32;iterator
933 &#32;&#32;&#32;&#32;_M_insert(const_iterator,&#32;_Arg&amp;&amp;,
934 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;,&#32;false_type&#32;__uks);
935 
936 &#32;&#32;&#32;&#32;&#32;&#32;size_type
937 &#32;&#32;&#32;&#32;&#32;&#32;_M_erase(true_type&#32;__uks,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;);
938 
939 &#32;&#32;&#32;&#32;&#32;&#32;size_type
940 &#32;&#32;&#32;&#32;&#32;&#32;_M_erase(false_type&#32;__uks,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;);
941 
942 &#32;&#32;&#32;&#32;&#32;&#32;iterator
943 &#32;&#32;&#32;&#32;&#32;&#32;_M_erase(size_type&#32;__bkt,&#32;__node_base_ptr&#32;__prev_n,&#32;__node_ptr&#32;__n);
944 
945 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
946 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Emplace</emphasis>
947 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
948 &#32;&#32;&#32;&#32;__ireturn_type
949 &#32;&#32;&#32;&#32;emplace(_Args&amp;&amp;...&#32;__args)
950 &#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_emplace(__unique_keys{},&#32;std::forward&lt;_Args&gt;(__args)...);&#32;}
951 
952 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
953 &#32;&#32;&#32;&#32;iterator
954 &#32;&#32;&#32;&#32;emplace_hint(const_iterator&#32;__hint,&#32;_Args&amp;&amp;...&#32;__args)
955 &#32;&#32;&#32;&#32;{
956 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_emplace(__hint,&#32;__unique_keys{},
957 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Args&gt;(__args)...);
958 &#32;&#32;&#32;&#32;}
959 
960 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;member&#32;functions&#32;via&#32;inheritance.</emphasis>
961 
962 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Erase</emphasis>
963 &#32;&#32;&#32;&#32;&#32;&#32;iterator
964 &#32;&#32;&#32;&#32;&#32;&#32;erase(const_iterator);
965 
966 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;LWG&#32;2059.</emphasis>
967 &#32;&#32;&#32;&#32;&#32;&#32;iterator
968 &#32;&#32;&#32;&#32;&#32;&#32;erase(iterator&#32;__it)
969 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;erase(const_iterator(__it));&#32;}
970 
971 &#32;&#32;&#32;&#32;&#32;&#32;size_type
972 &#32;&#32;&#32;&#32;&#32;&#32;erase(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
973 &#32;&#32;&#32;&#32;&#32;&#32;{&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_erase(__unique_keys{},&#32;__k);&#32;}
974 
975 &#32;&#32;&#32;&#32;&#32;&#32;iterator
976 &#32;&#32;&#32;&#32;&#32;&#32;erase(const_iterator,&#32;const_iterator);
977 
978 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
979 &#32;&#32;&#32;&#32;&#32;&#32;clear()&#32;<emphasis role="keyword">noexcept</emphasis>;
980 
981 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Set&#32;number&#32;of&#32;buckets&#32;keeping&#32;it&#32;appropriate&#32;for&#32;container&apos;s&#32;number</emphasis>
982 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;of&#32;elements.</emphasis>
983 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;rehash(size_type&#32;__bkt_count);
984 
985 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;DR&#32;1189.</emphasis>
986 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;reserve,&#32;if&#32;present,&#32;comes&#32;from&#32;_Rehash_base.</emphasis>
987 
988 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201402L</emphasis>
990 &#32;&#32;&#32;&#32;&#32;&#32;insert_return_type
991 &#32;&#32;&#32;&#32;&#32;&#32;_M_reinsert_node(node_type&amp;&amp;&#32;__nh)
992 &#32;&#32;&#32;&#32;&#32;&#32;{
993 &#32;&#32;&#32;&#32;insert_return_type&#32;__ret;
994 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__nh.empty())
995 &#32;&#32;&#32;&#32;&#32;&#32;__ret.position&#32;=&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();
996 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
997 &#32;&#32;&#32;&#32;&#32;&#32;{
998 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__glibcxx_assert(get_allocator()&#32;==&#32;__nh.get_allocator());
999 
1000 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;__nh._M_key();
1001 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
1002 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1003 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node_ptr&#32;__n&#32;=&#32;_M_find_node(__bkt,&#32;__k,&#32;__code))
1004 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1005 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__ret.node&#32;=&#32;<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__nh);
1006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__ret.position&#32;=&#32;iterator(__n);
1007 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__ret.inserted&#32;=&#32;<emphasis role="keyword">false</emphasis>;
1008 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1009 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1010 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1011 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__ret.position
1012 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;_M_insert_unique_node(__bkt,&#32;__code,&#32;__nh._M_ptr);
1013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__nh._M_ptr&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__ret.inserted&#32;=&#32;<emphasis role="keyword">true</emphasis>;
1015 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1016 &#32;&#32;&#32;&#32;&#32;&#32;}
1017 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ret;
1018 &#32;&#32;&#32;&#32;&#32;&#32;}
1019 
1021 &#32;&#32;&#32;&#32;&#32;&#32;iterator
1022 &#32;&#32;&#32;&#32;&#32;&#32;_M_reinsert_node_multi(const_iterator&#32;__hint,&#32;node_type&amp;&amp;&#32;__nh)
1023 &#32;&#32;&#32;&#32;&#32;&#32;{
1024 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__nh.empty())
1025 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();
1026 
1027 &#32;&#32;&#32;&#32;__glibcxx_assert(get_allocator()&#32;==&#32;__nh.get_allocator());
1028 
1029 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;__nh._M_key();
1030 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
1031 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ret
1032 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_M_insert_multi_node(__hint._M_cur,&#32;__code,&#32;__nh._M_ptr);
1033 &#32;&#32;&#32;&#32;__nh._M_ptr&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1034 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__ret;
1035 &#32;&#32;&#32;&#32;&#32;&#32;}
1036 
1037 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1038 &#32;&#32;&#32;&#32;&#32;&#32;node_type
1039 &#32;&#32;&#32;&#32;&#32;&#32;_M_extract_node(<emphasis role="keywordtype">size_t</emphasis>&#32;__bkt,&#32;__node_base_ptr&#32;__prev_n)
1040 &#32;&#32;&#32;&#32;&#32;&#32;{
1041 &#32;&#32;&#32;&#32;__node_ptr&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);
1042 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev_n&#32;==&#32;_M_buckets[__bkt])
1043 &#32;&#32;&#32;&#32;&#32;&#32;_M_remove_bucket_begin(__bkt,&#32;__n-&gt;_M_next(),
1044 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n-&gt;_M_nxt&#32;?&#32;_M_bucket_index(*__n-&gt;_M_next())&#32;:&#32;0);
1045 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n-&gt;_M_nxt)
1046 &#32;&#32;&#32;&#32;&#32;&#32;{
1047 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__next_bkt&#32;=&#32;_M_bucket_index(*__n-&gt;_M_next());
1048 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next_bkt&#32;!=&#32;__bkt)
1049 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__next_bkt]&#32;=&#32;__prev_n;
1050 &#32;&#32;&#32;&#32;&#32;&#32;}
1051 
1052 &#32;&#32;&#32;&#32;__prev_n-&gt;_M_nxt&#32;=&#32;__n-&gt;_M_nxt;
1053 &#32;&#32;&#32;&#32;__n-&gt;_M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1054 &#32;&#32;&#32;&#32;--_M_element_count;
1055 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__n,&#32;this-&gt;_M_node_allocator()&#32;};
1056 &#32;&#32;&#32;&#32;&#32;&#32;}
1057 
1058 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
1059 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Extract&#32;a&#32;node.</emphasis>
1060 &#32;&#32;&#32;&#32;&#32;&#32;node_type
1061 &#32;&#32;&#32;&#32;&#32;&#32;extract(const_iterator&#32;__pos)
1062 &#32;&#32;&#32;&#32;&#32;&#32;{
1063 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;__bkt&#32;=&#32;_M_bucket_index(*__pos._M_cur);
1064 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_extract_node(__bkt,
1065 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_get_previous_node(__bkt,&#32;__pos._M_cur));
1066 &#32;&#32;&#32;&#32;&#32;&#32;}
1067 
1069 &#32;&#32;&#32;&#32;&#32;&#32;node_type
1070 &#32;&#32;&#32;&#32;&#32;&#32;extract(<emphasis role="keyword">const</emphasis>&#32;_Key&amp;&#32;__k)
1071 &#32;&#32;&#32;&#32;&#32;&#32;{
1072 &#32;&#32;&#32;&#32;node_type&#32;__nh;
1073 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
1074 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1075 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node_base_ptr&#32;__prev_node&#32;=&#32;_M_find_before_node(__bkt,&#32;__k,&#32;__code))
1076 &#32;&#32;&#32;&#32;&#32;&#32;__nh&#32;=&#32;_M_extract_node(__bkt,&#32;__prev_node);
1077 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__nh;
1078 &#32;&#32;&#32;&#32;&#32;&#32;}
1079 
1081 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Compatible_Hashtable&gt;
1082 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1083 &#32;&#32;&#32;&#32;_M_merge_unique(_Compatible_Hashtable&amp;&#32;__src)
1084 &#32;&#32;&#32;&#32;{
1085 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_same_v&lt;<emphasis role="keyword">typename</emphasis>&#32;_Compatible_Hashtable::node_type,
1086 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;node_type&gt;,&#32;<emphasis role="stringliteral">&quot;Node&#32;types&#32;are&#32;compatible&quot;</emphasis>);
1087 &#32;&#32;&#32;&#32;&#32;&#32;__glibcxx_assert(get_allocator()&#32;==&#32;__src.get_allocator());
1088 
1089 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__n_elt&#32;=&#32;__src.size();
1090 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__i&#32;=&#32;__src.cbegin(),&#32;__end&#32;=&#32;__src.cend();&#32;__i&#32;!=&#32;__end;)
1091 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1092 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos&#32;=&#32;__i++;
1093 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;_ExtractKey{}(*__pos);
1094 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code
1095 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;this-&gt;_M_hash_code(__src.hash_function(),&#32;*__pos._M_cur);
1096 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1097 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_find_node(__bkt,&#32;__k,&#32;__code)&#32;==&#32;<emphasis role="keyword">nullptr</emphasis>)
1098 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1099 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__nh&#32;=&#32;__src.extract(__pos);
1100 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_insert_unique_node(__bkt,&#32;__code,&#32;__nh._M_ptr,&#32;__n_elt);
1101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__nh._M_ptr&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n_elt&#32;=&#32;1;
1103 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1104 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n_elt&#32;!=&#32;1)
1105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;--__n_elt;
1106 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1107 &#32;&#32;&#32;&#32;}
1108 
1110 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Compatible_Hashtable&gt;
1111 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1112 &#32;&#32;&#32;&#32;_M_merge_multi(_Compatible_Hashtable&amp;&#32;__src)
1113 &#32;&#32;&#32;&#32;{
1114 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(is_same_v&lt;<emphasis role="keyword">typename</emphasis>&#32;_Compatible_Hashtable::node_type,
1115 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;node_type&gt;,&#32;<emphasis role="stringliteral">&quot;Node&#32;types&#32;are&#32;compatible&quot;</emphasis>);
1116 &#32;&#32;&#32;&#32;&#32;&#32;__glibcxx_assert(get_allocator()&#32;==&#32;__src.get_allocator());
1117 
1118 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__hint&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1119 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;reserve(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;+&#32;__src.size());
1120 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__i&#32;=&#32;__src.cbegin(),&#32;__end&#32;=&#32;__src.cend();&#32;__i&#32;!=&#32;__end;)
1121 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1122 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos&#32;=&#32;__i++;
1123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code
1124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;this-&gt;_M_hash_code(__src.hash_function(),&#32;*__pos._M_cur);
1125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__nh&#32;=&#32;__src.extract(__pos);
1126 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hint&#32;=&#32;_M_insert_multi_node(__hint,&#32;__code,&#32;__nh._M_ptr)._M_cur;
1127 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__nh._M_ptr&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1128 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1129 &#32;&#32;&#32;&#32;}
1130 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;C++17</emphasis>
1131 
1132 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
1133 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Helper&#32;rehash&#32;method&#32;used&#32;when&#32;keys&#32;are&#32;unique.</emphasis>
1134 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;_M_rehash_aux(size_type&#32;__bkt_count,&#32;true_type&#32;__uks);
1135 
1136 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Helper&#32;rehash&#32;method&#32;used&#32;when&#32;keys&#32;can&#32;be&#32;non-unique.</emphasis>
1137 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;_M_rehash_aux(size_type&#32;__bkt_count,&#32;false_type&#32;__uks);
1138 
1139 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Unconditionally&#32;change&#32;size&#32;of&#32;bucket&#32;array&#32;to&#32;n,&#32;restore</emphasis>
1140 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;hash&#32;policy&#32;state&#32;to&#32;__state&#32;on&#32;exception.</emphasis>
1141 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;_M_rehash(size_type&#32;__bkt_count,&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__state);
1142 &#32;&#32;&#32;&#32;};
1143 
1144 &#32;&#32;<emphasis role="comment">//&#32;Definitions&#32;of&#32;class&#32;template&#32;_Hashtable&apos;s&#32;out-of-line&#32;member&#32;functions.</emphasis>
1145 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1146 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1147 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1148 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1149 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1150 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1151 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1152 &#32;&#32;&#32;&#32;_M_bucket_begin(size_type&#32;__bkt)&#32;<emphasis role="keyword">const</emphasis>
1153 &#32;&#32;&#32;&#32;-&gt;&#32;__node_ptr
1154 &#32;&#32;&#32;&#32;{
1155 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__n&#32;=&#32;_M_buckets[__bkt];
1156 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__n&#32;?&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__n-&gt;_M_nxt)&#32;:&#32;<emphasis role="keyword">nullptr</emphasis>;
1157 &#32;&#32;&#32;&#32;}
1158 
1159 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1160 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1161 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1162 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1163 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1164 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1165 &#32;&#32;&#32;&#32;_Hashtable(size_type&#32;__bkt_count_hint,
1166 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__h,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;&#32;__eq,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a)
1167 &#32;&#32;&#32;&#32;:&#32;_Hashtable(__h,&#32;__eq,&#32;__a)
1168 &#32;&#32;&#32;&#32;{
1169 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__bkt_count&#32;=&#32;_M_rehash_policy._M_next_bkt(__bkt_count_hint);
1170 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__bkt_count&#32;&gt;&#32;_M_bucket_count)
1171 &#32;&#32;&#32;&#32;{
1172 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;_M_allocate_buckets(__bkt_count);
1173 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__bkt_count;
1174 &#32;&#32;&#32;&#32;}
1175 &#32;&#32;&#32;&#32;}
1176 
1177 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1178 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1179 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1180 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1181 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
1182 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1183 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1184 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_InputIterator&#32;__f,&#32;_InputIterator&#32;__l,
1185 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint,
1186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__h,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;&#32;__eq,
1187 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a,&#32;true_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
1188 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_Hashtable(__bkt_count_hint,&#32;__h,&#32;__eq,&#32;__a)
1189 &#32;&#32;&#32;&#32;&#32;&#32;{
1190 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;&#32;__f&#32;!=&#32;__l;&#32;++__f)
1191 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;insert(*__f);
1192 &#32;&#32;&#32;&#32;&#32;&#32;}
1193 
1194 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1195 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1196 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1197 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1198 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_InputIterator&gt;
1199 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1200 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1201 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable(_InputIterator&#32;__f,&#32;_InputIterator&#32;__l,
1202 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt_count_hint,
1203 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hash&amp;&#32;__h,&#32;<emphasis role="keyword">const</emphasis>&#32;_Equal&amp;&#32;__eq,
1204 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a,&#32;false_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
1205 &#32;&#32;&#32;&#32;&#32;&#32;:&#32;_Hashtable(__h,&#32;__eq,&#32;__a)
1206 &#32;&#32;&#32;&#32;&#32;&#32;{
1207 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__nb_elems&#32;=&#32;__detail::__distance_fw(__f,&#32;__l);
1208 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__bkt_count&#32;=
1209 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy._M_next_bkt(
1210 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
1211 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt_count_hint));
1212 
1213 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__bkt_count&#32;&gt;&#32;_M_bucket_count)
1214 &#32;&#32;&#32;&#32;&#32;&#32;{
1215 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;_M_allocate_buckets(__bkt_count);
1216 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__bkt_count;
1217 &#32;&#32;&#32;&#32;&#32;&#32;}
1218 
1219 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;&#32;__f&#32;!=&#32;__l;&#32;++__f)
1220 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;insert(*__f);
1221 &#32;&#32;&#32;&#32;&#32;&#32;}
1222 
1223 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1224 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1227 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1228 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1229 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1230 &#32;&#32;&#32;&#32;operator=(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;&#32;__ht)
1231 &#32;&#32;&#32;&#32;-&gt;&#32;_Hashtable&amp;
1232 &#32;&#32;&#32;&#32;{
1233 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(&amp;__ht&#32;==&#32;<emphasis role="keyword">this</emphasis>)
1234 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1235 
1236 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node_alloc_traits::_S_propagate_on_copy_assign())
1237 &#32;&#32;&#32;&#32;{
1238 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&amp;&#32;__this_alloc&#32;=&#32;this-&gt;_M_node_allocator();
1239 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&amp;&#32;__that_alloc&#32;=&#32;__ht._M_node_allocator();
1240 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__node_alloc_traits::_S_always_equal()
1241 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;__this_alloc&#32;!=&#32;__that_alloc)
1242 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1243 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Replacement&#32;allocator&#32;cannot&#32;free&#32;existing&#32;storage.</emphasis>
1244 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_nodes(_M_begin());
1245 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1246 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
1247 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1248 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::__alloc_on_copy(__this_alloc,&#32;__that_alloc);
1249 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hashtable_base::operator=(__ht);
1250 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__ht._M_bucket_count;
1251 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;=&#32;__ht._M_element_count;
1252 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy&#32;=&#32;__ht._M_rehash_policy;
1253 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__alloc_node_gen_t&#32;__alloc_node_gen(*<emphasis role="keyword">this</emphasis>);
1254 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
1255 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1256 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_assign(__ht,&#32;__alloc_node_gen);
1257 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1258 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
1259 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1260 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_M_assign&#32;took&#32;care&#32;of&#32;deallocating&#32;all&#32;memory.&#32;Now&#32;we</emphasis>
1261 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;must&#32;make&#32;sure&#32;this&#32;instance&#32;remains&#32;in&#32;a&#32;usable&#32;state.</emphasis>
1262 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_reset();
1263 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
1264 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1265 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1266 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1267 &#32;&#32;&#32;&#32;&#32;&#32;std::__alloc_on_copy(__this_alloc,&#32;__that_alloc);
1268 &#32;&#32;&#32;&#32;}
1269 
1270 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Reuse&#32;allocated&#32;buckets&#32;and&#32;nodes.</emphasis>
1271 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign_elements(__ht);
1272 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;*<emphasis role="keyword">this</emphasis>;
1273 &#32;&#32;&#32;&#32;}
1274 
1275 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1276 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1277 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1278 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1279 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Ht&gt;
1280 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1281 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1282 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1283 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign_elements(_Ht&amp;&amp;&#32;__ht)
1284 &#32;&#32;&#32;&#32;&#32;&#32;{
1285 &#32;&#32;&#32;&#32;__buckets_ptr&#32;__former_buckets&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1286 &#32;&#32;&#32;&#32;std::size_t&#32;__former_bucket_count&#32;=&#32;_M_bucket_count;
1287 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__former_state&#32;=&#32;_M_rehash_policy._M_state();
1288 
1289 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_bucket_count&#32;!=&#32;__ht._M_bucket_count)
1290 &#32;&#32;&#32;&#32;&#32;&#32;{
1291 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__former_buckets&#32;=&#32;_M_buckets;
1292 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;_M_allocate_buckets(__ht._M_bucket_count);
1293 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__ht._M_bucket_count;
1294 &#32;&#32;&#32;&#32;&#32;&#32;}
1295 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1296 &#32;&#32;&#32;&#32;&#32;&#32;__builtin_memset(_M_buckets,&#32;0,
1297 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;*&#32;<emphasis role="keyword">sizeof</emphasis>(__node_base_ptr));
1298 
1299 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
1300 &#32;&#32;&#32;&#32;&#32;&#32;{
1301 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hashtable_base::operator=(std::forward&lt;_Ht&gt;(__ht));
1302 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;=&#32;__ht._M_element_count;
1303 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy&#32;=&#32;__ht._M_rehash_policy;
1304 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__reuse_or_alloc_node_gen_t&#32;__roan(_M_begin(),&#32;*<emphasis role="keyword">this</emphasis>);
1305 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1306 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_assign(std::forward&lt;_Ht&gt;(__ht),&#32;__roan);
1307 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__former_buckets)
1308 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets(__former_buckets,&#32;__former_bucket_count);
1309 &#32;&#32;&#32;&#32;&#32;&#32;}
1310 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
1311 &#32;&#32;&#32;&#32;&#32;&#32;{
1312 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__former_buckets)
1313 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1314 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Restore&#32;previous&#32;buckets.</emphasis>
1315 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
1316 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy._M_reset(__former_state);
1317 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__former_buckets;
1318 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__former_bucket_count;
1319 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1320 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__builtin_memset(_M_buckets,&#32;0,
1321 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;*&#32;<emphasis role="keyword">sizeof</emphasis>(__node_base_ptr));
1322 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
1323 &#32;&#32;&#32;&#32;&#32;&#32;}
1324 &#32;&#32;&#32;&#32;&#32;&#32;}
1325 
1326 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1327 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1328 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1329 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1330 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Ht,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
1331 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1332 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1333 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1334 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign(_Ht&amp;&amp;&#32;__ht,&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen)
1335 &#32;&#32;&#32;&#32;&#32;&#32;{
1336 &#32;&#32;&#32;&#32;__buckets_ptr&#32;__buckets&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1337 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_M_buckets)
1338 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__buckets&#32;=&#32;_M_allocate_buckets(_M_bucket_count);
1339 
1340 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
1341 &#32;&#32;&#32;&#32;&#32;&#32;{
1342 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ht._M_before_begin._M_nxt)
1343 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1344 
1345 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;First&#32;deal&#32;with&#32;the&#32;special&#32;first&#32;node&#32;pointed&#32;to&#32;by</emphasis>
1346 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_M_before_begin.</emphasis>
1347 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__ht_n&#32;=&#32;__ht._M_begin();
1348 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__this_n
1349 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__node_gen(__fwd_value_for&lt;_Ht&gt;(__ht_n-&gt;_M_v()));
1350 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_copy_code(*__this_n,&#32;*__ht_n);
1351 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin(__this_n);
1352 
1353 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Then&#32;deal&#32;with&#32;other&#32;nodes.</emphasis>
1354 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__prev_n&#32;=&#32;__this_n;
1355 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__ht_n&#32;=&#32;__ht_n-&gt;_M_next();&#32;__ht_n;&#32;__ht_n&#32;=&#32;__ht_n-&gt;_M_next())
1356 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1357 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__this_n&#32;=&#32;__node_gen(__fwd_value_for&lt;_Ht&gt;(__ht_n-&gt;_M_v()));
1358 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__prev_n-&gt;_M_nxt&#32;=&#32;__this_n;
1359 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_copy_code(*__this_n,&#32;*__ht_n);
1360 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(*__this_n);
1361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_M_buckets[__bkt])
1362 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__bkt]&#32;=&#32;__prev_n;
1363 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__prev_n&#32;=&#32;__this_n;
1364 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1365 &#32;&#32;&#32;&#32;&#32;&#32;}
1366 &#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
1367 &#32;&#32;&#32;&#32;&#32;&#32;{
1368 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;clear();
1369 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__buckets)
1370 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
1371 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
1372 &#32;&#32;&#32;&#32;&#32;&#32;}
1373 &#32;&#32;&#32;&#32;&#32;&#32;}
1374 
1375 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1379 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1380 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1381 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1382 &#32;&#32;&#32;&#32;_M_reset()&#32;<emphasis role="keyword">noexcept</emphasis>
1383 &#32;&#32;&#32;&#32;{
1384 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy._M_reset();
1385 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;1;
1386 &#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1387 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;&amp;_M_single_bucket;
1388 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
1389 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;=&#32;0;
1390 &#32;&#32;&#32;&#32;}
1391 
1392 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1393 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1394 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1395 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1396 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1397 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1398 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1399 &#32;&#32;&#32;&#32;_M_move_assign(_Hashtable&amp;&amp;&#32;__ht,&#32;true_type)
1400 &#32;&#32;&#32;&#32;{
1401 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__builtin_expect(std::__addressof(__ht)&#32;==&#32;<emphasis role="keyword">this</emphasis>,&#32;<emphasis role="keyword">false</emphasis>))
1402 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>;
1403 
1404 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_nodes(_M_begin());
1405 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
1406 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_base::operator=(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht));
1407 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy&#32;=&#32;__ht._M_rehash_policy;
1408 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ht._M_uses_single_bucket())
1409 &#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__ht._M_buckets;
1410 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1411 &#32;&#32;&#32;&#32;{
1412 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;&amp;_M_single_bucket;
1413 &#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;=&#32;__ht._M_single_bucket;
1414 &#32;&#32;&#32;&#32;}
1415 
1416 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__ht._M_bucket_count;
1417 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__ht._M_before_begin._M_nxt;
1418 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;=&#32;__ht._M_element_count;
1419 &#32;&#32;&#32;&#32;&#32;&#32;std::__alloc_on_move(this-&gt;_M_node_allocator(),&#32;__ht._M_node_allocator());
1420 
1421 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Fix&#32;bucket&#32;containing&#32;the&#32;_M_before_begin&#32;pointer&#32;that&#32;can&apos;t&#32;be&#32;moved.</emphasis>
1422 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin();
1423 &#32;&#32;&#32;&#32;&#32;&#32;__ht._M_reset();
1424 &#32;&#32;&#32;&#32;}
1425 
1426 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1427 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1428 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1429 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1430 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1431 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1432 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1433 &#32;&#32;&#32;&#32;_M_move_assign(_Hashtable&amp;&amp;&#32;__ht,&#32;false_type)
1434 &#32;&#32;&#32;&#32;{
1435 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__ht._M_node_allocator()&#32;==&#32;this-&gt;_M_node_allocator())
1436 &#32;&#32;&#32;&#32;_M_move_assign(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht),&#32;true_type{});
1437 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1438 &#32;&#32;&#32;&#32;{
1439 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Can&apos;t&#32;move&#32;memory,&#32;move&#32;elements&#32;then.</emphasis>
1440 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign_elements(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__ht));
1441 &#32;&#32;&#32;&#32;&#32;&#32;__ht.clear();
1442 &#32;&#32;&#32;&#32;}
1443 &#32;&#32;&#32;&#32;}
1444 
1445 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1446 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1447 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1448 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1449 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1450 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1451 &#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;&#32;__ht)
1452 &#32;&#32;&#32;&#32;:&#32;__hashtable_base(__ht),
1453 &#32;&#32;&#32;&#32;&#32;&#32;__map_base(__ht),
1454 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_base(__ht),
1455 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc(
1456 &#32;&#32;&#32;&#32;__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
1457 &#32;&#32;&#32;&#32;&#32;&#32;__enable_default_ctor(__ht),
1458 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets(<emphasis role="keyword">nullptr</emphasis>),
1459 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count(__ht._M_bucket_count),
1460 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count(__ht._M_element_count),
1461 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy(__ht._M_rehash_policy)
1462 &#32;&#32;&#32;&#32;{
1463 &#32;&#32;&#32;&#32;&#32;&#32;__alloc_node_gen_t&#32;__alloc_node_gen(*<emphasis role="keyword">this</emphasis>);
1464 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign(__ht,&#32;__alloc_node_gen);
1465 &#32;&#32;&#32;&#32;}
1466 
1467 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1468 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1470 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1471 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1472 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1473 &#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;&#32;__ht,&#32;__node_alloc_type&amp;&amp;&#32;__a,
1474 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;true_type&#32;<emphasis role="comment">/*&#32;alloc&#32;always&#32;equal&#32;*/</emphasis>)
1475 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(_S_nothrow_move())
1476 &#32;&#32;&#32;&#32;:&#32;__hashtable_base(__ht),
1477 &#32;&#32;&#32;&#32;&#32;&#32;__map_base(__ht),
1478 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_base(__ht),
1479 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__a)),
1480 &#32;&#32;&#32;&#32;&#32;&#32;__enable_default_ctor(__ht),
1481 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets(__ht._M_buckets),
1482 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count(__ht._M_bucket_count),
1483 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin(__ht._M_before_begin._M_nxt),
1484 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count(__ht._M_element_count),
1485 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy(__ht._M_rehash_policy)
1486 &#32;&#32;&#32;&#32;{
1487 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Update&#32;buckets&#32;if&#32;__ht&#32;is&#32;using&#32;its&#32;single&#32;bucket.</emphasis>
1488 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__ht._M_uses_single_bucket())
1489 &#32;&#32;&#32;&#32;{
1490 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;&amp;_M_single_bucket;
1491 &#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;=&#32;__ht._M_single_bucket;
1492 &#32;&#32;&#32;&#32;}
1493 
1494 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Fix&#32;bucket&#32;containing&#32;the&#32;_M_before_begin&#32;pointer&#32;that&#32;can&apos;t&#32;be&#32;moved.</emphasis>
1495 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin();
1496 
1497 &#32;&#32;&#32;&#32;&#32;&#32;__ht._M_reset();
1498 &#32;&#32;&#32;&#32;}
1499 
1500 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1502 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1503 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1504 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1505 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1506 &#32;&#32;&#32;&#32;_Hashtable(<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;&#32;__ht,&#32;<emphasis role="keyword">const</emphasis>&#32;allocator_type&amp;&#32;__a)
1507 &#32;&#32;&#32;&#32;:&#32;__hashtable_base(__ht),
1508 &#32;&#32;&#32;&#32;&#32;&#32;__map_base(__ht),
1509 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_base(__ht),
1510 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc(__node_alloc_type(__a)),
1511 &#32;&#32;&#32;&#32;&#32;&#32;__enable_default_ctor(__ht),
1512 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets(),
1513 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count(__ht._M_bucket_count),
1514 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count(__ht._M_element_count),
1515 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy(__ht._M_rehash_policy)
1516 &#32;&#32;&#32;&#32;{
1517 &#32;&#32;&#32;&#32;&#32;&#32;__alloc_node_gen_t&#32;__alloc_node_gen(*<emphasis role="keyword">this</emphasis>);
1518 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign(__ht,&#32;__alloc_node_gen);
1519 &#32;&#32;&#32;&#32;}
1520 
1521 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1522 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1523 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1524 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1525 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1526 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1527 &#32;&#32;&#32;&#32;_Hashtable(_Hashtable&amp;&amp;&#32;__ht,&#32;__node_alloc_type&amp;&amp;&#32;__a,
1528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;<emphasis role="comment">/*&#32;alloc&#32;always&#32;equal&#32;*/</emphasis>)
1529 &#32;&#32;&#32;&#32;:&#32;__hashtable_base(__ht),
1530 &#32;&#32;&#32;&#32;&#32;&#32;__map_base(__ht),
1531 &#32;&#32;&#32;&#32;&#32;&#32;__rehash_base(__ht),
1532 &#32;&#32;&#32;&#32;&#32;&#32;__hashtable_alloc(<link linkend="_namespacestd_1ac7095819f6a8da64d69b1ee3029c52be">std::move</link>(__a)),
1533 &#32;&#32;&#32;&#32;&#32;&#32;__enable_default_ctor(__ht),
1534 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets(<emphasis role="keyword">nullptr</emphasis>),
1535 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count(__ht._M_bucket_count),
1536 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count(__ht._M_element_count),
1537 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy(__ht._M_rehash_policy)
1538 &#32;&#32;&#32;&#32;{
1539 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__ht._M_node_allocator()&#32;==&#32;this-&gt;_M_node_allocator())
1540 &#32;&#32;&#32;&#32;{
1541 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__ht._M_uses_single_bucket())
1542 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1543 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;&amp;_M_single_bucket;
1544 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_single_bucket&#32;=&#32;__ht._M_single_bucket;
1545 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1546 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__ht._M_buckets;
1548 
1549 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Fix&#32;bucket&#32;containing&#32;the&#32;_M_before_begin&#32;pointer&#32;that&#32;can&apos;t&#32;be</emphasis>
1550 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;moved.</emphasis>
1551 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin(__ht._M_begin());
1552 
1553 &#32;&#32;&#32;&#32;&#32;&#32;__ht._M_reset();
1554 &#32;&#32;&#32;&#32;}
1555 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1556 &#32;&#32;&#32;&#32;{
1557 &#32;&#32;&#32;&#32;&#32;&#32;__alloc_node_gen_t&#32;__alloc_gen(*<emphasis role="keyword">this</emphasis>);
1558 
1559 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_Fwd_Ht&#32;=&#32;__conditional_t&lt;
1560 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__move_if_noexcept_cond&lt;value_type&gt;::value,
1561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_Hashtable&amp;,&#32;_Hashtable&amp;&amp;&gt;;
1562 &#32;&#32;&#32;&#32;&#32;&#32;_M_assign(std::forward&lt;_Fwd_Ht&gt;(__ht),&#32;__alloc_gen);
1563 &#32;&#32;&#32;&#32;&#32;&#32;__ht.clear();
1564 &#32;&#32;&#32;&#32;}
1565 &#32;&#32;&#32;&#32;}
1566 
1567 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1568 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1569 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1570 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1571 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1572 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1573 &#32;&#32;&#32;&#32;~_Hashtable()&#32;<emphasis role="keyword">noexcept</emphasis>
1574 &#32;&#32;&#32;&#32;{
1575 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Getting&#32;a&#32;bucket&#32;index&#32;from&#32;a&#32;node&#32;shall&#32;not&#32;throw&#32;because&#32;it&#32;is&#32;used</emphasis>
1576 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;in&#32;methods&#32;(erase,&#32;swap...)&#32;that&#32;shall&#32;not&#32;throw.&#32;Need&#32;a&#32;complete</emphasis>
1577 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;type&#32;to&#32;check&#32;this,&#32;so&#32;do&#32;it&#32;in&#32;the&#32;destructor&#32;not&#32;at&#32;class&#32;scope.</emphasis>
1578 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(<emphasis role="keyword">noexcept</emphasis>(declval&lt;const&#32;__hash_code_base_access&amp;&gt;()
1579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;._M_bucket_index(declval&lt;const&#32;__node_value_type&amp;&gt;(),
1580 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(std::size_t)0)),
1581 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;Cache&#32;the&#32;hash&#32;code&#32;or&#32;qualify&#32;your&#32;functors&#32;involved&quot;</emphasis>
1582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;&#32;in&#32;hash&#32;code&#32;and&#32;bucket&#32;index&#32;computation&#32;with&#32;noexcept&quot;</emphasis>);
1583 
1584 &#32;&#32;&#32;&#32;&#32;&#32;clear();
1585 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
1586 &#32;&#32;&#32;&#32;}
1587 
1588 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1589 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1590 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1591 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1592 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1593 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1594 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">::</link>
1595 <link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">    swap</link>(_Hashtable&amp;&#32;__x)
1596 &#32;&#32;&#32;&#32;<emphasis role="keyword">noexcept</emphasis>(__and_&lt;__is_nothrow_swappable&lt;_Hash&gt;,
1597 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__is_nothrow_swappable&lt;_Equal&gt;&gt;<link linkend="_classvalue">::value</link>)
1598 &#32;&#32;&#32;&#32;{
1599 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;only&#32;base&#32;class&#32;with&#32;member&#32;variables&#32;is&#32;hash_code_base.</emphasis>
1600 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;define&#32;_Hash_code_base::_M_swap&#32;because&#32;different</emphasis>
1601 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;specializations&#32;have&#32;different&#32;members.</emphasis>
1602 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_swap(__x);
1603 
1604 &#32;&#32;&#32;&#32;&#32;&#32;std::__alloc_on_swap(this-&gt;_M_node_allocator(),&#32;__x._M_node_allocator());
1605 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_rehash_policy,&#32;__x._M_rehash_policy);
1606 
1607 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Deal&#32;properly&#32;with&#32;potentially&#32;moved&#32;instances.</emphasis>
1608 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_uses_single_bucket())
1609 &#32;&#32;&#32;&#32;{
1610 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__x._M_uses_single_bucket())
1611 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1612 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__x._M_buckets;
1613 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__x._M_buckets&#32;=&#32;&amp;__x._M_single_bucket;
1614 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1615 &#32;&#32;&#32;&#32;}
1616 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__x._M_uses_single_bucket())
1617 &#32;&#32;&#32;&#32;{
1618 &#32;&#32;&#32;&#32;&#32;&#32;__x._M_buckets&#32;=&#32;_M_buckets;
1619 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;&amp;_M_single_bucket;
1620 &#32;&#32;&#32;&#32;}&#32;&#32;&#32;
1621 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1622 &#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_buckets,&#32;__x._M_buckets);
1623 
1624 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_bucket_count,&#32;__x._M_bucket_count);
1625 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_before_begin._M_nxt,&#32;__x._M_before_begin._M_nxt);
1626 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_element_count,&#32;__x._M_element_count);
1627 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespacestd_1a3ece115a1c8ed9020a20f1d0b70efda8">std::swap</link>(_M_single_bucket,&#32;__x._M_single_bucket);
1628 
1629 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Fix&#32;buckets&#32;containing&#32;the&#32;_M_before_begin&#32;pointers&#32;that&#32;can&apos;t&#32;be</emphasis>
1630 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;swapped.</emphasis>
1631 &#32;&#32;&#32;&#32;&#32;&#32;_M_update_bbegin();
1632 &#32;&#32;&#32;&#32;&#32;&#32;__x._M_update_bbegin();
1633 &#32;&#32;&#32;&#32;}
1634 
1635 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1636 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1637 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1638 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1639 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1640 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1641 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;<link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">::</link>
1642 <link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">    find</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
1643 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
1644 &#32;&#32;&#32;&#32;{
1645 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
1646 &#32;&#32;&#32;&#32;{
1647 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;begin();&#32;__it&#32;!=&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();&#32;++__it)
1648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__it._M_cur))
1649 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__it;
1650 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();
1651 &#32;&#32;&#32;&#32;}
1652 
1653 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
1654 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1655 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(_M_find_node(__bkt,&#32;__k,&#32;__code));
1656 &#32;&#32;&#32;&#32;}
1657 
1658 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1659 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1660 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1661 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1662 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1663 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1664 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;<link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">::</link>
1665 <link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">    find</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1666 &#32;&#32;&#32;&#32;-&gt;&#32;const_iterator
1667 &#32;&#32;&#32;&#32;{
1668 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
1669 &#32;&#32;&#32;&#32;{
1670 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;begin();&#32;__it&#32;!=&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();&#32;++__it)
1671 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__it._M_cur))
1672 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__it;
1673 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();
1674 &#32;&#32;&#32;&#32;}
1675 
1676 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
1677 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1678 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(_M_find_node(__bkt,&#32;__k,&#32;__code));
1679 &#32;&#32;&#32;&#32;}
1680 
1681 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201703L</emphasis>
1682 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1683 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1684 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1685 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1686 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;
1687 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1688 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1689 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1690 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)
1691 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;iterator
1692 &#32;&#32;&#32;&#32;&#32;&#32;{
1693 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
1694 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1695 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(_M_find_node_tr(__bkt,&#32;__k,&#32;__code));
1696 &#32;&#32;&#32;&#32;&#32;&#32;}
1697 
1698 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1699 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1700 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1701 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1702 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;
1703 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1704 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1705 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1706 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1707 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;const_iterator
1708 &#32;&#32;&#32;&#32;&#32;&#32;{
1709 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
1710 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1711 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;const_iterator(_M_find_node_tr(__bkt,&#32;__k,&#32;__code));
1712 &#32;&#32;&#32;&#32;&#32;&#32;}
1713 <emphasis role="preprocessor">#endif</emphasis>
1714 
1715 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1716 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1717 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1718 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1719 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1720 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1721 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a22486c0c8d9f7d79a07bf22ecffeeb2f">::</link>
1722 <link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a22486c0c8d9f7d79a07bf22ecffeeb2f">    count</link>(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1723 &#32;&#32;&#32;&#32;-&gt;&#32;size_type
1724 &#32;&#32;&#32;&#32;{
1725 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;<link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">find</link>(__k);
1726 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__it._M_cur)
1727 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
1728 
1729 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__unique_keys::value)
1730 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;1;
1731 
1732 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1733 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1734 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1735 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__result&#32;=&#32;1;
1736 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__ref&#32;=&#32;__it++;
1737 &#32;&#32;&#32;&#32;&#32;&#32;&#32;__it._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_node_equals(*__ref._M_cur,&#32;*__it._M_cur);
1738 &#32;&#32;&#32;&#32;&#32;&#32;&#32;++__it)
1739 &#32;&#32;&#32;&#32;++__result;
1740 
1741 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__result;
1742 &#32;&#32;&#32;&#32;}
1743 
1744 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201703L</emphasis>
1745 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1746 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1747 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1748 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1749 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;
1750 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1751 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1752 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1753 &#32;&#32;&#32;&#32;&#32;&#32;_M_count_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1754 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;size_type
1755 &#32;&#32;&#32;&#32;&#32;&#32;{
1756 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
1757 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1758 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__n&#32;=&#32;_M_find_node_tr(__bkt,&#32;__k,&#32;__code);
1759 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__n)
1760 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
1761 
1762 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1763 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1764 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1765 &#32;&#32;&#32;&#32;iterator&#32;__it(__n);
1766 &#32;&#32;&#32;&#32;size_type&#32;__result&#32;=&#32;1;
1767 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(++__it;
1768 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__it._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_equals_tr(__k,&#32;__code,&#32;*__it._M_cur);
1769 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;++__it)
1770 &#32;&#32;&#32;&#32;&#32;&#32;++__result;
1771 
1772 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__result;
1773 &#32;&#32;&#32;&#32;&#32;&#32;}
1774 <emphasis role="preprocessor">#endif</emphasis>
1775 
1776 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1777 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1778 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1780 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1781 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1782 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1783 &#32;&#32;&#32;&#32;equal_range(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
1784 &#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;iterator,&#32;iterator&gt;
1785 &#32;&#32;&#32;&#32;{
1786 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ite&#32;=&#32;<link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">find</link>(__k);
1787 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ite._M_cur)
1788 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__ite,&#32;__ite&#32;};
1789 
1790 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__beg&#32;=&#32;__ite++;
1791 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__unique_keys::value)
1792 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1793 
1794 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1795 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1796 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1797 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__ite._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_node_equals(*__beg._M_cur,&#32;*__ite._M_cur))
1798 &#32;&#32;&#32;&#32;++__ite;
1799 
1800 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1801 &#32;&#32;&#32;&#32;}
1802 
1803 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1804 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1805 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1807 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1808 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1809 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1810 &#32;&#32;&#32;&#32;equal_range(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1811 &#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;const_iterator,&#32;const_iterator&gt;
1812 &#32;&#32;&#32;&#32;{
1813 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__ite&#32;=&#32;<link linkend="_namespacestd_1ae3e398a3f38b0182e770944d57402701">find</link>(__k);
1814 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__ite._M_cur)
1815 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__ite,&#32;__ite&#32;};
1816 
1817 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__beg&#32;=&#32;__ite++;
1818 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__unique_keys::value)
1819 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1820 
1821 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1822 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1823 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1824 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__ite._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_node_equals(*__beg._M_cur,&#32;*__ite._M_cur))
1825 &#32;&#32;&#32;&#32;++__ite;
1826 
1827 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1828 &#32;&#32;&#32;&#32;}
1829 
1830 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201703L</emphasis>
1831 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1832 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1833 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1834 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1835 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;
1836 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1837 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1838 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1839 &#32;&#32;&#32;&#32;&#32;&#32;_M_equal_range_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)
1840 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;iterator,&#32;iterator&gt;
1841 &#32;&#32;&#32;&#32;&#32;&#32;{
1842 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
1843 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1844 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__n&#32;=&#32;_M_find_node_tr(__bkt,&#32;__k,&#32;__code);
1845 &#32;&#32;&#32;&#32;iterator&#32;__ite(__n);
1846 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__n)
1847 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__ite,&#32;__ite&#32;};
1848 
1849 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1850 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1851 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1852 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__beg&#32;=&#32;__ite++;
1853 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__ite._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_equals_tr(__k,&#32;__code,&#32;*__ite._M_cur))
1854 &#32;&#32;&#32;&#32;&#32;&#32;++__ite;
1855 
1856 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1857 &#32;&#32;&#32;&#32;&#32;&#32;}
1858 
1859 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1860 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1861 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1862 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1863 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;
1864 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1865 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1866 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1867 &#32;&#32;&#32;&#32;&#32;&#32;_M_equal_range_tr(<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
1868 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;const_iterator,&#32;const_iterator&gt;
1869 &#32;&#32;&#32;&#32;&#32;&#32;{
1870 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
1871 &#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
1872 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__n&#32;=&#32;_M_find_node_tr(__bkt,&#32;__k,&#32;__code);
1873 &#32;&#32;&#32;&#32;const_iterator&#32;__ite(__n);
1874 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__n)
1875 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__ite,&#32;__ite&#32;};
1876 
1877 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;All&#32;equivalent&#32;values&#32;are&#32;next&#32;to&#32;each&#32;other,&#32;if&#32;we&#32;find&#32;a</emphasis>
1878 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;non-equivalent&#32;value&#32;after&#32;an&#32;equivalent&#32;one&#32;it&#32;means&#32;that&#32;we&#32;won&apos;t</emphasis>
1879 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;find&#32;any&#32;new&#32;equivalent&#32;value.</emphasis>
1880 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__beg&#32;=&#32;__ite++;
1881 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__ite._M_cur&#32;&amp;&amp;&#32;this-&gt;_M_equals_tr(__k,&#32;__code,&#32;*__ite._M_cur))
1882 &#32;&#32;&#32;&#32;&#32;&#32;++__ite;
1883 
1884 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__beg,&#32;__ite&#32;};
1885 &#32;&#32;&#32;&#32;&#32;&#32;}
1886 <emphasis role="preprocessor">#endif</emphasis>
1887 
1888 &#32;&#32;<emphasis role="comment">//&#32;Find&#32;the&#32;node&#32;before&#32;the&#32;one&#32;whose&#32;key&#32;compares&#32;equal&#32;to&#32;k.</emphasis>
1889 &#32;&#32;<emphasis role="comment">//&#32;Return&#32;nullptr&#32;if&#32;no&#32;node&#32;is&#32;found.</emphasis>
1890 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1891 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1892 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1893 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1894 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1895 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1896 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1897 &#32;&#32;&#32;&#32;_M_find_before_node(<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
1898 &#32;&#32;&#32;&#32;-&gt;&#32;__node_base_ptr
1899 &#32;&#32;&#32;&#32;{
1900 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_p&#32;=&#32;&amp;_M_before_begin;
1901 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_p-&gt;_M_nxt)
1902 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1903 
1904 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__node_ptr&#32;__p&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_p-&gt;_M_nxt);
1905 &#32;&#32;&#32;&#32;&#32;&#32;&#32;__p&#32;!=&#32;<emphasis role="keyword">nullptr</emphasis>;
1906 &#32;&#32;&#32;&#32;&#32;&#32;&#32;__p&#32;=&#32;__p-&gt;_M_next())
1907 &#32;&#32;&#32;&#32;{
1908 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__p))
1909 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__prev_p;
1910 
1911 &#32;&#32;&#32;&#32;&#32;&#32;__prev_p&#32;=&#32;__p;
1912 &#32;&#32;&#32;&#32;}
1913 
1914 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1915 &#32;&#32;&#32;&#32;}
1916 
1917 &#32;&#32;<emphasis role="comment">//&#32;Find&#32;the&#32;node&#32;before&#32;the&#32;one&#32;whose&#32;key&#32;compares&#32;equal&#32;to&#32;k&#32;in&#32;the&#32;bucket</emphasis>
1918 &#32;&#32;<emphasis role="comment">//&#32;bkt.&#32;Return&#32;nullptr&#32;if&#32;no&#32;node&#32;is&#32;found.</emphasis>
1919 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1920 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1922 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1923 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1924 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1926 &#32;&#32;&#32;&#32;_M_find_before_node(size_type&#32;__bkt,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k,
1927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code)&#32;<emphasis role="keyword">const</emphasis>
1928 &#32;&#32;&#32;&#32;-&gt;&#32;__node_base_ptr
1929 &#32;&#32;&#32;&#32;{
1930 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_p&#32;=&#32;_M_buckets[__bkt];
1931 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_p)
1932 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1933 
1934 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__node_ptr&#32;__p&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_p-&gt;_M_nxt);;
1935 &#32;&#32;&#32;&#32;&#32;&#32;&#32;__p&#32;=&#32;__p-&gt;_M_next())
1936 &#32;&#32;&#32;&#32;{
1937 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_equals(__k,&#32;__code,&#32;*__p))
1938 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__prev_p;
1939 
1940 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__p-&gt;_M_nxt&#32;||&#32;_M_bucket_index(*__p-&gt;_M_next())&#32;!=&#32;__bkt)
1941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1942 &#32;&#32;&#32;&#32;&#32;&#32;__prev_p&#32;=&#32;__p;
1943 &#32;&#32;&#32;&#32;}
1944 
1945 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1946 &#32;&#32;&#32;&#32;}
1947 
1948 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1949 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1950 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1951 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1952 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt&gt;
1953 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
1954 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1955 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1956 &#32;&#32;&#32;&#32;&#32;&#32;_M_find_before_node_tr(size_type&#32;__bkt,&#32;<emphasis role="keyword">const</emphasis>&#32;_Kt&amp;&#32;__k,
1957 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code)&#32;<emphasis role="keyword">const</emphasis>
1958 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;__node_base_ptr
1959 &#32;&#32;&#32;&#32;&#32;&#32;{
1960 &#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_p&#32;=&#32;_M_buckets[__bkt];
1961 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_p)
1962 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1963 
1964 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(__node_ptr&#32;__p&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_p-&gt;_M_nxt);;
1965 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p&#32;=&#32;__p-&gt;_M_next())
1966 &#32;&#32;&#32;&#32;&#32;&#32;{
1967 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_equals_tr(__k,&#32;__code,&#32;*__p))
1968 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__prev_p;
1969 
1970 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__p-&gt;_M_nxt&#32;||&#32;_M_bucket_index(*__p-&gt;_M_next())&#32;!=&#32;__bkt)
1971 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1972 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__prev_p&#32;=&#32;__p;
1973 &#32;&#32;&#32;&#32;&#32;&#32;}
1974 
1975 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">nullptr</emphasis>;
1976 &#32;&#32;&#32;&#32;&#32;&#32;}
1977 
1978 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
1979 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
1980 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
1981 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
1982 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
1983 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
1984 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
1985 &#32;&#32;&#32;&#32;_M_insert_bucket_begin(size_type&#32;__bkt,&#32;__node_ptr&#32;__node)
1986 &#32;&#32;&#32;&#32;{
1987 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_M_buckets[__bkt])
1988 &#32;&#32;&#32;&#32;{
1989 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Bucket&#32;is&#32;not&#32;empty,&#32;we&#32;just&#32;need&#32;to&#32;insert&#32;the&#32;new&#32;node</emphasis>
1990 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;after&#32;the&#32;bucket&#32;before&#32;begin.</emphasis>
1991 &#32;&#32;&#32;&#32;&#32;&#32;__node-&gt;_M_nxt&#32;=&#32;_M_buckets[__bkt]-&gt;_M_nxt;
1992 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__bkt]-&gt;_M_nxt&#32;=&#32;__node;
1993 &#32;&#32;&#32;&#32;}
1994 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1995 &#32;&#32;&#32;&#32;{
1996 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;bucket&#32;is&#32;empty,&#32;the&#32;new&#32;node&#32;is&#32;inserted&#32;at&#32;the</emphasis>
1997 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;beginning&#32;of&#32;the&#32;singly-linked&#32;list&#32;and&#32;the&#32;bucket&#32;will</emphasis>
1998 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;contain&#32;_M_before_begin&#32;pointer.</emphasis>
1999 &#32;&#32;&#32;&#32;&#32;&#32;__node-&gt;_M_nxt&#32;=&#32;_M_before_begin._M_nxt;
2000 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__node;
2001 
2002 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node-&gt;_M_nxt)
2003 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;must&#32;update&#32;former&#32;begin&#32;bucket&#32;that&#32;is&#32;pointing&#32;to</emphasis>
2004 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_M_before_begin.</emphasis>
2005 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[_M_bucket_index(*__node-&gt;_M_next())]&#32;=&#32;__node;
2006 
2007 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__bkt]&#32;=&#32;&amp;_M_before_begin;
2008 &#32;&#32;&#32;&#32;}
2009 &#32;&#32;&#32;&#32;}
2010 
2011 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2012 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2015 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2016 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2018 &#32;&#32;&#32;&#32;_M_remove_bucket_begin(size_type&#32;__bkt,&#32;__node_ptr&#32;__next,
2019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__next_bkt)
2020 &#32;&#32;&#32;&#32;{
2021 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__next&#32;||&#32;__next_bkt&#32;!=&#32;__bkt)
2022 &#32;&#32;&#32;&#32;{
2023 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Bucket&#32;is&#32;now&#32;empty</emphasis>
2024 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;First&#32;update&#32;next&#32;bucket&#32;if&#32;any</emphasis>
2025 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next)
2026 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__next_bkt]&#32;=&#32;_M_buckets[__bkt];
2027 
2028 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Second&#32;update&#32;before&#32;begin&#32;node&#32;if&#32;necessary</emphasis>
2029 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(&amp;_M_before_begin&#32;==&#32;_M_buckets[__bkt])
2030 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__next;
2031 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__bkt]&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2032 &#32;&#32;&#32;&#32;}
2033 &#32;&#32;&#32;&#32;}
2034 
2035 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2036 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2037 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2038 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2039 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2040 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2041 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2042 &#32;&#32;&#32;&#32;_M_get_previous_node(size_type&#32;__bkt,&#32;__node_ptr&#32;__n)
2043 &#32;&#32;&#32;&#32;-&gt;&#32;__node_base_ptr
2044 &#32;&#32;&#32;&#32;{
2045 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_n&#32;=&#32;_M_buckets[__bkt];
2046 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__prev_n-&gt;_M_nxt&#32;!=&#32;__n)
2047 &#32;&#32;&#32;&#32;__prev_n&#32;=&#32;__prev_n-&gt;_M_nxt;
2048 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__prev_n;
2049 &#32;&#32;&#32;&#32;}
2050 
2051 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2052 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2053 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2055 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
2056 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2057 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2058 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2059 &#32;&#32;&#32;&#32;&#32;&#32;_M_emplace(true_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>,&#32;_Args&amp;&amp;...&#32;__args)
2060 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;iterator,&#32;bool&gt;
2061 &#32;&#32;&#32;&#32;&#32;&#32;{
2062 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;First&#32;build&#32;the&#32;node&#32;to&#32;get&#32;access&#32;to&#32;the&#32;hash&#32;code</emphasis>
2063 &#32;&#32;&#32;&#32;_Scoped_node&#32;__node&#32;{&#32;<emphasis role="keyword">this</emphasis>,&#32;std::forward&lt;_Args&gt;(__args)...&#32;&#32;};
2064 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;_ExtractKey{}(__node._M_node-&gt;_M_v());
2065 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
2066 &#32;&#32;&#32;&#32;&#32;&#32;{
2067 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;begin();&#32;__it&#32;!=&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();&#32;++__it)
2068 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__it._M_cur))
2069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;There&#32;is&#32;already&#32;an&#32;equivalent&#32;node,&#32;no&#32;insertion</emphasis>
2070 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__it,&#32;<emphasis role="keyword">false</emphasis>&#32;};
2071 &#32;&#32;&#32;&#32;&#32;&#32;}
2072 
2073 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
2074 &#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2075 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&gt;&#32;__small_size_threshold())
2076 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node_ptr&#32;__p&#32;=&#32;_M_find_node(__bkt,&#32;__k,&#32;__code))
2077 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;There&#32;is&#32;already&#32;an&#32;equivalent&#32;node,&#32;no&#32;insertion</emphasis>
2078 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;iterator(__p),&#32;<emphasis role="keyword">false</emphasis>&#32;};
2079 
2080 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;the&#32;node</emphasis>
2081 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos&#32;=&#32;_M_insert_unique_node(__bkt,&#32;__code,&#32;__node._M_node);
2082 &#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2083 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__pos,&#32;<emphasis role="keyword">true</emphasis>&#32;};
2084 &#32;&#32;&#32;&#32;&#32;&#32;}
2085 
2086 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2087 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2088 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2089 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2090 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>...&#32;_Args&gt;
2091 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2092 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2093 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2094 &#32;&#32;&#32;&#32;&#32;&#32;_M_emplace(const_iterator&#32;__hint,&#32;false_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>,
2095 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Args&amp;&amp;...&#32;__args)
2096 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;iterator
2097 &#32;&#32;&#32;&#32;&#32;&#32;{
2098 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;First&#32;build&#32;the&#32;node&#32;to&#32;get&#32;its&#32;hash&#32;code.</emphasis>
2099 &#32;&#32;&#32;&#32;_Scoped_node&#32;__node&#32;{&#32;<emphasis role="keyword">this</emphasis>,&#32;std::forward&lt;_Args&gt;(__args)...&#32;&#32;};
2100 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;_ExtractKey{}(__node._M_node-&gt;_M_v());
2101 
2102 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__res&#32;=&#32;this-&gt;_M_compute_hash_code(__hint,&#32;__k);
2103 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos
2104 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_M_insert_multi_node(__res.first._M_cur,&#32;__res.second,
2105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node._M_node);
2106 &#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2107 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__pos;
2108 &#32;&#32;&#32;&#32;&#32;&#32;}
2109 
2110 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2111 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2112 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2113 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2114 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2115 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2116 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2117 &#32;&#32;&#32;&#32;_M_compute_hash_code(const_iterator&#32;__hint,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)&#32;<emphasis role="keyword">const</emphasis>
2118 &#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;const_iterator,&#32;__hash_code&gt;
2119 &#32;&#32;&#32;&#32;{
2120 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
2121 &#32;&#32;&#32;&#32;{
2122 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__hint&#32;!=&#32;cend())
2123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;__hint;&#32;__it&#32;!=&#32;cend();&#32;++__it)
2125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__it._M_cur))
2126 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__it,&#32;this-&gt;_M_hash_code(*__it._M_cur)&#32;};
2127 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2128 
2129 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;cbegin();&#32;__it&#32;!=&#32;__hint;&#32;++__it)
2130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals(__k,&#32;*__it._M_cur))
2131 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__it,&#32;this-&gt;_M_hash_code(*__it._M_cur)&#32;};
2132 &#32;&#32;&#32;&#32;}
2133 
2134 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__hint,&#32;this-&gt;_M_hash_code(__k)&#32;};
2135 &#32;&#32;&#32;&#32;}
2136 
2137 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2138 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2139 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2140 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2141 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2142 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2144 &#32;&#32;&#32;&#32;_M_insert_unique_node(size_type&#32;__bkt,&#32;__hash_code&#32;__code,
2145 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__node,&#32;size_type&#32;__n_elt)
2146 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
2147 &#32;&#32;&#32;&#32;{
2148 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__saved_state&#32;=&#32;_M_rehash_policy._M_state();
2149 &#32;&#32;&#32;&#32;&#32;&#32;std::pair&lt;bool,&#32;std::size_t&gt;&#32;__do_rehash
2150 &#32;&#32;&#32;&#32;=&#32;_M_rehash_policy._M_need_rehash(_M_bucket_count,&#32;_M_element_count,
2151 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n_elt);
2152 
2153 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__do_rehash.first)
2154 &#32;&#32;&#32;&#32;{
2155 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash(__do_rehash.second,&#32;__saved_state);
2156 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2157 &#32;&#32;&#32;&#32;}
2158 
2159 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_store_code(*__node,&#32;__code);
2160 
2161 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Always&#32;insert&#32;at&#32;the&#32;beginning&#32;of&#32;the&#32;bucket.</emphasis>
2162 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_bucket_begin(__bkt,&#32;__node);
2163 &#32;&#32;&#32;&#32;&#32;&#32;++_M_element_count;
2164 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(__node);
2165 &#32;&#32;&#32;&#32;}
2166 
2167 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2168 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2171 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2172 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2173 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2174 &#32;&#32;&#32;&#32;_M_insert_multi_node(__node_ptr&#32;__hint,
2175 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code,&#32;__node_ptr&#32;__node)
2176 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
2177 &#32;&#32;&#32;&#32;{
2178 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__saved_state&#32;=&#32;_M_rehash_policy._M_state();
2179 &#32;&#32;&#32;&#32;&#32;&#32;std::pair&lt;bool,&#32;std::size_t&gt;&#32;__do_rehash
2180 &#32;&#32;&#32;&#32;=&#32;_M_rehash_policy._M_need_rehash(_M_bucket_count,&#32;_M_element_count,&#32;1);
2181 
2182 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__do_rehash.first)
2183 &#32;&#32;&#32;&#32;_M_rehash(__do_rehash.second,&#32;__saved_state);
2184 
2185 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_store_code(*__node,&#32;__code);
2186 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k&#32;=&#32;_ExtractKey{}(__node-&gt;_M_v());
2187 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2188 
2189 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Find&#32;the&#32;node&#32;before&#32;an&#32;equivalent&#32;one&#32;or&#32;use&#32;hint&#32;if&#32;it&#32;exists&#32;and</emphasis>
2190 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;if&#32;it&#32;is&#32;equivalent.</emphasis>
2191 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev
2192 &#32;&#32;&#32;&#32;=&#32;__builtin_expect(__hint&#32;!=&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;<emphasis role="keyword">false</emphasis>)
2193 &#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;this-&gt;_M_equals(__k,&#32;__code,&#32;*__hint)
2194 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;?&#32;__hint
2195 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;:&#32;_M_find_before_node(__bkt,&#32;__k,&#32;__code);
2196 
2197 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev)
2198 &#32;&#32;&#32;&#32;{
2199 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Insert&#32;after&#32;the&#32;node&#32;before&#32;the&#32;equivalent&#32;one.</emphasis>
2200 &#32;&#32;&#32;&#32;&#32;&#32;__node-&gt;_M_nxt&#32;=&#32;__prev-&gt;_M_nxt;
2201 &#32;&#32;&#32;&#32;&#32;&#32;__prev-&gt;_M_nxt&#32;=&#32;__node;
2202 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__builtin_expect(__prev&#32;==&#32;__hint,&#32;<emphasis role="keyword">false</emphasis>))
2203 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;hint&#32;might&#32;be&#32;the&#32;last&#32;bucket&#32;node,&#32;in&#32;this&#32;case&#32;we&#32;need&#32;to</emphasis>
2204 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;update&#32;next&#32;bucket.</emphasis>
2205 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node-&gt;_M_nxt
2206 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;&amp;&#32;!this-&gt;_M_equals(__k,&#32;__code,&#32;*__node-&gt;_M_next()))
2207 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2208 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__next_bkt&#32;=&#32;_M_bucket_index(*__node-&gt;_M_next());
2209 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next_bkt&#32;!=&#32;__bkt)
2210 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__next_bkt]&#32;=&#32;__node;
2211 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2212 &#32;&#32;&#32;&#32;}
2213 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2214 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;inserted&#32;node&#32;has&#32;no&#32;equivalent&#32;in&#32;the&#32;hashtable.&#32;We&#32;must</emphasis>
2215 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;insert&#32;the&#32;new&#32;node&#32;at&#32;the&#32;beginning&#32;of&#32;the&#32;bucket&#32;to&#32;preserve</emphasis>
2216 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;equivalent&#32;elements&apos;&#32;relative&#32;positions.</emphasis>
2217 &#32;&#32;&#32;&#32;_M_insert_bucket_begin(__bkt,&#32;__node);
2218 &#32;&#32;&#32;&#32;&#32;&#32;++_M_element_count;
2219 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(__node);
2220 &#32;&#32;&#32;&#32;}
2221 
2222 &#32;&#32;<emphasis role="comment">//&#32;Insert&#32;v&#32;if&#32;no&#32;element&#32;with&#32;its&#32;key&#32;is&#32;already&#32;present.</emphasis>
2223 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2224 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2227 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Kt,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
2228 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2229 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2230 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2231 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert_unique(_Kt&amp;&amp;&#32;__k,&#32;_Arg&amp;&amp;&#32;__v,
2232 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen)
2233 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;pair&lt;iterator,&#32;bool&gt;
2234 &#32;&#32;&#32;&#32;&#32;&#32;{
2235 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
2236 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;__it&#32;=&#32;begin();&#32;__it&#32;!=&#32;<link linkend="__classes_2lib_2raylib_2src_2external_2glad_8h_1a432111147038972f06e049e18a837002">end</link>();&#32;++__it)
2237 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(this-&gt;_M_key_equals_tr(__k,&#32;*__it._M_cur))
2238 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__it,&#32;<emphasis role="keyword">false</emphasis>&#32;};
2239 
2240 &#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code_tr(__k);
2241 &#32;&#32;&#32;&#32;size_type&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2242 
2243 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&gt;&#32;__small_size_threshold())
2244 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__node_ptr&#32;__node&#32;=&#32;_M_find_node_tr(__bkt,&#32;__k,&#32;__code))
2245 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;iterator(__node),&#32;<emphasis role="keyword">false</emphasis>&#32;};
2246 
2247 &#32;&#32;&#32;&#32;_Scoped_node&#32;__node&#32;{
2248 &#32;&#32;&#32;&#32;&#32;&#32;__node_builder_t::_S_build(std::forward&lt;_Kt&gt;(__k),
2249 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::forward&lt;_Arg&gt;(__v),
2250 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_gen),
2251 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">this</emphasis>
2252 &#32;&#32;&#32;&#32;};
2253 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos
2254 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_M_insert_unique_node(__bkt,&#32;__code,&#32;__node._M_node);
2255 &#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2256 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;{&#32;__pos,&#32;<emphasis role="keyword">true</emphasis>&#32;};
2257 &#32;&#32;&#32;&#32;&#32;&#32;}
2258 
2259 &#32;&#32;<emphasis role="comment">//&#32;Insert&#32;v&#32;unconditionally.</emphasis>
2260 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2261 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2262 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2263 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2264 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Arg,&#32;<emphasis role="keyword">typename</emphasis>&#32;_NodeGenerator&gt;
2265 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2266 &#32;&#32;&#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2267 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2268 &#32;&#32;&#32;&#32;&#32;&#32;_M_insert(const_iterator&#32;__hint,&#32;_Arg&amp;&amp;&#32;__v,
2269 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;_NodeGenerator&amp;&#32;__node_gen,
2270 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;false_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
2271 &#32;&#32;&#32;&#32;&#32;&#32;-&gt;&#32;iterator
2272 &#32;&#32;&#32;&#32;&#32;&#32;{
2273 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;First&#32;allocate&#32;new&#32;node&#32;so&#32;that&#32;we&#32;don&apos;t&#32;do&#32;anything&#32;if&#32;it&#32;throws.</emphasis>
2274 &#32;&#32;&#32;&#32;_Scoped_node&#32;__node{&#32;__node_gen(std::forward&lt;_Arg&gt;(__v)),&#32;<emphasis role="keyword">this</emphasis>&#32;};
2275 
2276 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Second&#32;compute&#32;the&#32;hash&#32;code&#32;so&#32;that&#32;we&#32;don&apos;t&#32;rehash&#32;if&#32;it&#32;throws.</emphasis>
2277 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__res&#32;=&#32;this-&gt;_M_compute_hash_code(
2278 &#32;&#32;&#32;&#32;&#32;&#32;__hint,&#32;_ExtractKey{}(__node._M_node-&gt;_M_v()));
2279 
2280 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;__pos
2281 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;_M_insert_multi_node(__res.first._M_cur,&#32;__res.second,
2282 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node._M_node);
2283 &#32;&#32;&#32;&#32;__node._M_node&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2284 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__pos;
2285 &#32;&#32;&#32;&#32;&#32;&#32;}
2286 
2287 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2288 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2289 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2290 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2291 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2292 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2293 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2294 &#32;&#32;&#32;&#32;erase(const_iterator&#32;__it)
2295 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
2296 &#32;&#32;&#32;&#32;{
2297 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n&#32;=&#32;__it._M_cur;
2298 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(*__n);
2299 
2300 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Look&#32;for&#32;previous&#32;node&#32;to&#32;unlink&#32;it&#32;from&#32;the&#32;erased&#32;one,&#32;this</emphasis>
2301 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;is&#32;why&#32;we&#32;need&#32;buckets&#32;to&#32;contain&#32;the&#32;before&#32;begin&#32;to&#32;make</emphasis>
2302 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;this&#32;search&#32;fast.</emphasis>
2303 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_n&#32;=&#32;_M_get_previous_node(__bkt,&#32;__n);
2304 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_M_erase(__bkt,&#32;__prev_n,&#32;__n);
2305 &#32;&#32;&#32;&#32;}
2306 
2307 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2308 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2309 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2310 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2311 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2312 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2313 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2314 &#32;&#32;&#32;&#32;_M_erase(size_type&#32;__bkt,&#32;__node_base_ptr&#32;__prev_n,&#32;__node_ptr&#32;__n)
2315 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
2316 &#32;&#32;&#32;&#32;{
2317 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev_n&#32;==&#32;_M_buckets[__bkt])
2318 &#32;&#32;&#32;&#32;_M_remove_bucket_begin(__bkt,&#32;__n-&gt;_M_next(),
2319 &#32;&#32;&#32;&#32;&#32;&#32;__n-&gt;_M_nxt&#32;?&#32;_M_bucket_index(*__n-&gt;_M_next())&#32;:&#32;0);
2320 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n-&gt;_M_nxt)
2321 &#32;&#32;&#32;&#32;{
2322 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__next_bkt&#32;=&#32;_M_bucket_index(*__n-&gt;_M_next());
2323 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next_bkt&#32;!=&#32;__bkt)
2324 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_buckets[__next_bkt]&#32;=&#32;__prev_n;
2325 &#32;&#32;&#32;&#32;}
2326 
2327 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n-&gt;_M_nxt&#32;=&#32;__n-&gt;_M_nxt;
2328 &#32;&#32;&#32;&#32;&#32;&#32;iterator&#32;__result(__n-&gt;_M_next());
2329 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_node(__n);
2330 &#32;&#32;&#32;&#32;&#32;&#32;--_M_element_count;
2331 
2332 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__result;
2333 &#32;&#32;&#32;&#32;}
2334 
2335 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2336 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2337 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2338 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2339 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2340 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2341 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2342 &#32;&#32;&#32;&#32;_M_erase(true_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
2343 &#32;&#32;&#32;&#32;-&gt;&#32;size_type
2344 &#32;&#32;&#32;&#32;{
2345 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_n;
2346 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n;
2347 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt;
2348 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
2349 &#32;&#32;&#32;&#32;{
2350 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n&#32;=&#32;_M_find_before_node(__k);
2351 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_n)
2352 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
2353 
2354 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;found&#32;a&#32;matching&#32;node,&#32;erase&#32;it.</emphasis>
2355 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);
2356 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;_M_bucket_index(*__n);
2357 &#32;&#32;&#32;&#32;}
2358 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2359 &#32;&#32;&#32;&#32;{
2360 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
2361 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2362 
2363 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Look&#32;for&#32;the&#32;node&#32;before&#32;the&#32;first&#32;matching&#32;node.</emphasis>
2364 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n&#32;=&#32;_M_find_before_node(__bkt,&#32;__k,&#32;__code);
2365 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_n)
2366 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
2367 
2368 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;found&#32;a&#32;matching&#32;node,&#32;erase&#32;it.</emphasis>
2369 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);
2370 &#32;&#32;&#32;&#32;}
2371 
2372 &#32;&#32;&#32;&#32;&#32;&#32;_M_erase(__bkt,&#32;__prev_n,&#32;__n);
2373 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;1;
2374 &#32;&#32;&#32;&#32;}
2375 
2376 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2377 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2378 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2379 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2380 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2381 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2382 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2383 &#32;&#32;&#32;&#32;_M_erase(false_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>,&#32;<emphasis role="keyword">const</emphasis>&#32;key_type&amp;&#32;__k)
2384 &#32;&#32;&#32;&#32;-&gt;&#32;size_type
2385 &#32;&#32;&#32;&#32;{
2386 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt;
2387 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_n;
2388 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n;
2389 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="__classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_g_l_e_s2_2gl2ext_8h_1a3d1e3edfcf61ca2d831883e1afbad89e">size</link>()&#32;&lt;=&#32;__small_size_threshold())
2390 &#32;&#32;&#32;&#32;{
2391 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n&#32;=&#32;_M_find_before_node(__k);
2392 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_n)
2393 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
2394 
2395 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;found&#32;a&#32;matching&#32;node,&#32;erase&#32;it.</emphasis>
2396 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);
2397 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;_M_bucket_index(*__n);
2398 &#32;&#32;&#32;&#32;}
2399 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2400 &#32;&#32;&#32;&#32;{
2401 &#32;&#32;&#32;&#32;&#32;&#32;__hash_code&#32;__code&#32;=&#32;this-&gt;_M_hash_code(__k);
2402 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;_M_bucket_index(__code);
2403 
2404 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Look&#32;for&#32;the&#32;node&#32;before&#32;the&#32;first&#32;matching&#32;node.</emphasis>
2405 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n&#32;=&#32;_M_find_before_node(__bkt,&#32;__k,&#32;__code);
2406 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__prev_n)
2407 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
2408 
2409 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>__node_ptr<emphasis role="keyword">&gt;</emphasis>(__prev_n-&gt;_M_nxt);
2410 &#32;&#32;&#32;&#32;}
2411 
2412 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;_GLIBCXX_RESOLVE_LIB_DEFECTS</emphasis>
2413 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;526.&#32;Is&#32;it&#32;undefined&#32;if&#32;a&#32;function&#32;in&#32;the&#32;standard&#32;changes</emphasis>
2414 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;in&#32;parameters?</emphasis>
2415 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;We&#32;use&#32;one&#32;loop&#32;to&#32;find&#32;all&#32;matching&#32;nodes&#32;and&#32;another&#32;to&#32;deallocate</emphasis>
2416 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;them&#32;so&#32;that&#32;the&#32;key&#32;stays&#32;valid&#32;during&#32;the&#32;first&#32;loop.&#32;It&#32;might&#32;be</emphasis>
2417 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;invalidated&#32;indirectly&#32;when&#32;destroying&#32;nodes.</emphasis>
2418 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n_last&#32;=&#32;__n-&gt;_M_next();
2419 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__n_last&#32;&amp;&amp;&#32;this-&gt;_M_node_equals(*__n,&#32;*__n_last))
2420 &#32;&#32;&#32;&#32;__n_last&#32;=&#32;__n_last-&gt;_M_next();
2421 
2422 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__n_last_bkt&#32;=&#32;__n_last&#32;?&#32;_M_bucket_index(*__n_last)&#32;:&#32;__bkt;
2423 
2424 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Deallocate&#32;nodes.</emphasis>
2425 &#32;&#32;&#32;&#32;&#32;&#32;size_type&#32;__result&#32;=&#32;0;
2426 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">do</emphasis>
2427 &#32;&#32;&#32;&#32;{
2428 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__p&#32;=&#32;__n-&gt;_M_next();
2429 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_node(__n);
2430 &#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;__p;
2431 &#32;&#32;&#32;&#32;&#32;&#32;++__result;
2432 &#32;&#32;&#32;&#32;}
2433 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__n&#32;!=&#32;__n_last);
2434 
2435 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;-=&#32;__result;
2436 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev_n&#32;==&#32;_M_buckets[__bkt])
2437 &#32;&#32;&#32;&#32;_M_remove_bucket_begin(__bkt,&#32;__n_last,&#32;__n_last_bkt);
2438 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n_last_bkt&#32;!=&#32;__bkt)
2439 &#32;&#32;&#32;&#32;_M_buckets[__n_last_bkt]&#32;=&#32;__prev_n;
2440 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n-&gt;_M_nxt&#32;=&#32;__n_last;
2441 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;__result;
2442 &#32;&#32;&#32;&#32;}
2443 
2444 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2445 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2446 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2447 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2448 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>
2449 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2450 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2451 &#32;&#32;&#32;&#32;erase(const_iterator&#32;__first,&#32;const_iterator&#32;__last)
2452 &#32;&#32;&#32;&#32;-&gt;&#32;iterator
2453 &#32;&#32;&#32;&#32;{
2454 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__n&#32;=&#32;__first._M_cur;
2455 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__last_n&#32;=&#32;__last._M_cur;
2456 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n&#32;==&#32;__last_n)
2457 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(__n);
2458 
2459 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt&#32;=&#32;_M_bucket_index(*__n);
2460 
2461 &#32;&#32;&#32;&#32;&#32;&#32;__node_base_ptr&#32;__prev_n&#32;=&#32;_M_get_previous_node(__bkt,&#32;__n);
2462 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__is_bucket_begin&#32;=&#32;__n&#32;==&#32;_M_bucket_begin(__bkt);
2463 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__n_bkt&#32;=&#32;__bkt;
2464 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(;;)
2465 &#32;&#32;&#32;&#32;{
2466 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">do</emphasis>
2467 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2468 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>&#32;=&#32;__n;
2469 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n&#32;=&#32;__n-&gt;_M_next();
2470 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_node(<link linkend="__classes_2lib_2include_2xmmintrin_8h_1ad56bf6b8c22ee698e455f99196a1fe12">__tmp</link>);
2471 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;--_M_element_count;
2472 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__n)
2473 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2474 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__n_bkt&#32;=&#32;_M_bucket_index(*__n);
2475 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2476 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__n&#32;!=&#32;__last_n&#32;&amp;&amp;&#32;__n_bkt&#32;==&#32;__bkt);
2477 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__is_bucket_begin)
2478 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_remove_bucket_begin(__bkt,&#32;__n,&#32;__n_bkt);
2479 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n&#32;==&#32;__last_n)
2480 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
2481 &#32;&#32;&#32;&#32;&#32;&#32;__is_bucket_begin&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2482 &#32;&#32;&#32;&#32;&#32;&#32;__bkt&#32;=&#32;__n_bkt;
2483 &#32;&#32;&#32;&#32;}
2484 
2485 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__n&#32;&amp;&amp;&#32;(__n_bkt&#32;!=&#32;__bkt&#32;||&#32;__is_bucket_begin))
2486 &#32;&#32;&#32;&#32;_M_buckets[__n_bkt]&#32;=&#32;__prev_n;
2487 &#32;&#32;&#32;&#32;&#32;&#32;__prev_n-&gt;_M_nxt&#32;=&#32;__n;
2488 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;iterator(__n);
2489 &#32;&#32;&#32;&#32;}
2490 
2491 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2492 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2493 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2494 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2495 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2496 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2497 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2498 &#32;&#32;&#32;&#32;clear()&#32;<emphasis role="keyword">noexcept</emphasis>
2499 &#32;&#32;&#32;&#32;{
2500 &#32;&#32;&#32;&#32;&#32;&#32;this-&gt;_M_deallocate_nodes(_M_begin());
2501 &#32;&#32;&#32;&#32;&#32;&#32;__builtin_memset(_M_buckets,&#32;0,
2502 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;*&#32;<emphasis role="keyword">sizeof</emphasis>(__node_base_ptr));
2503 &#32;&#32;&#32;&#32;&#32;&#32;_M_element_count&#32;=&#32;0;
2504 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2505 &#32;&#32;&#32;&#32;}
2506 
2507 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2508 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2509 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2510 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2511 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2512 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2513 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2514 &#32;&#32;&#32;&#32;rehash(size_type&#32;__bkt_count)
2515 &#32;&#32;&#32;&#32;{
2516 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__saved_state&#32;=&#32;_M_rehash_policy._M_state();
2517 &#32;&#32;&#32;&#32;&#32;&#32;__bkt_count
2518 &#32;&#32;&#32;&#32;=&#32;std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count&#32;+&#32;1),
2519 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt_count);
2520 &#32;&#32;&#32;&#32;&#32;&#32;__bkt_count&#32;=&#32;_M_rehash_policy._M_next_bkt(__bkt_count);
2521 
2522 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__bkt_count&#32;!=&#32;_M_bucket_count)
2523 &#32;&#32;&#32;&#32;_M_rehash(__bkt_count,&#32;__saved_state);
2524 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2525 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;No&#32;rehash,&#32;restore&#32;previous&#32;state&#32;to&#32;keep&#32;it&#32;consistent&#32;with</emphasis>
2526 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;container&#32;state.</emphasis>
2527 &#32;&#32;&#32;&#32;_M_rehash_policy._M_reset(__saved_state);
2528 &#32;&#32;&#32;&#32;}
2529 
2530 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2531 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2532 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2533 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2534 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2535 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2536 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2537 &#32;&#32;&#32;&#32;_M_rehash(size_type&#32;__bkt_count,&#32;<emphasis role="keyword">const</emphasis>&#32;__rehash_state&amp;&#32;__state)
2538 &#32;&#32;&#32;&#32;{
2539 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a130bf0cd31a0783cd03563f46b46915b">__try</link>
2540 &#32;&#32;&#32;&#32;{
2541 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_aux(__bkt_count,&#32;__unique_keys{});
2542 &#32;&#32;&#32;&#32;}
2543 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a9e51d2f324c18a996a3e4f9a6ba0f6c2">__catch</link>(...)
2544 &#32;&#32;&#32;&#32;{
2545 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;A&#32;failure&#32;here&#32;means&#32;that&#32;buckets&#32;allocation&#32;failed.&#32;&#32;We&#32;only</emphasis>
2546 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;have&#32;to&#32;restore&#32;hash&#32;policy&#32;previous&#32;state.</emphasis>
2547 &#32;&#32;&#32;&#32;&#32;&#32;_M_rehash_policy._M_reset(__state);
2548 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="__classes_2lib_2include_2c_09_09_2bits_2exception__defines_8h_1a92ef03a5310b10a4243a6ec8f43494b5">__throw_exception_again</link>;
2549 &#32;&#32;&#32;&#32;}
2550 &#32;&#32;&#32;&#32;}
2551 
2552 &#32;&#32;<emphasis role="comment">//&#32;Rehash&#32;when&#32;there&#32;is&#32;no&#32;equivalent&#32;elements.</emphasis>
2553 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2554 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2555 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2556 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2557 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2558 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2559 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2560 &#32;&#32;&#32;&#32;_M_rehash_aux(size_type&#32;__bkt_count,&#32;true_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
2561 &#32;&#32;&#32;&#32;{
2562 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr&#32;__new_buckets&#32;=&#32;_M_allocate_buckets(__bkt_count);
2563 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__p&#32;=&#32;_M_begin();
2564 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2565 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bbegin_bkt&#32;=&#32;0;
2566 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__p)
2567 &#32;&#32;&#32;&#32;{
2568 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__next&#32;=&#32;__p-&gt;_M_next();
2569 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt
2570 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__hash_code_base::_M_bucket_index(*__p,&#32;__bkt_count);
2571 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__new_buckets[__bkt])
2572 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2573 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p-&gt;_M_nxt&#32;=&#32;_M_before_begin._M_nxt;
2574 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__p;
2575 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bkt]&#32;=&#32;&amp;_M_before_begin;
2576 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__p-&gt;_M_nxt)
2577 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bbegin_bkt]&#32;=&#32;__p;
2578 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bbegin_bkt&#32;=&#32;__bkt;
2579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2580 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2581 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p-&gt;_M_nxt&#32;=&#32;__new_buckets[__bkt]-&gt;_M_nxt;
2583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bkt]-&gt;_M_nxt&#32;=&#32;__p;
2584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2585 
2586 &#32;&#32;&#32;&#32;&#32;&#32;__p&#32;=&#32;__next;
2587 &#32;&#32;&#32;&#32;}
2588 
2589 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
2590 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__bkt_count;
2591 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__new_buckets;
2592 &#32;&#32;&#32;&#32;}
2593 
2594 &#32;&#32;<emphasis role="comment">//&#32;Rehash&#32;when&#32;there&#32;can&#32;be&#32;equivalent&#32;elements,&#32;preserve&#32;their&#32;relative</emphasis>
2595 &#32;&#32;<emphasis role="comment">//&#32;order.</emphasis>
2596 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Key,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Value,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Alloc,
2597 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_ExtractKey,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Equal,
2598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_Hash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_RangeHash,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Unused,
2599 &#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">typename</emphasis>&#32;_RehashPolicy,&#32;<emphasis role="keyword">typename</emphasis>&#32;_Traits&gt;
2600 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>
2601 &#32;&#32;&#32;&#32;_Hashtable&lt;_Key,&#32;_Value,&#32;_Alloc,&#32;_ExtractKey,&#32;_Equal,
2602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_Hash,&#32;_RangeHash,&#32;_Unused,&#32;_RehashPolicy,&#32;_Traits&gt;::
2603 &#32;&#32;&#32;&#32;_M_rehash_aux(size_type&#32;__bkt_count,&#32;false_type&#32;<emphasis role="comment">/*&#32;__uks&#32;*/</emphasis>)
2604 &#32;&#32;&#32;&#32;{
2605 &#32;&#32;&#32;&#32;&#32;&#32;__buckets_ptr&#32;__new_buckets&#32;=&#32;_M_allocate_buckets(__bkt_count);
2606 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__p&#32;=&#32;_M_begin();
2607 &#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2608 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bbegin_bkt&#32;=&#32;0;
2609 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__prev_bkt&#32;=&#32;0;
2610 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__prev_p&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
2611 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;__check_bucket&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2612 
2613 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(__p)
2614 &#32;&#32;&#32;&#32;{
2615 &#32;&#32;&#32;&#32;&#32;&#32;__node_ptr&#32;__next&#32;=&#32;__p-&gt;_M_next();
2616 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__bkt
2617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__hash_code_base::_M_bucket_index(*__p,&#32;__bkt_count);
2618 
2619 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev_p&#32;&amp;&amp;&#32;__prev_bkt&#32;==&#32;__bkt)
2620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Previous&#32;insert&#32;was&#32;already&#32;in&#32;this&#32;bucket,&#32;we&#32;insert&#32;after</emphasis>
2622 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;the&#32;previously&#32;inserted&#32;one&#32;to&#32;preserve&#32;equivalent&#32;elements</emphasis>
2623 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;relative&#32;order.</emphasis>
2624 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p-&gt;_M_nxt&#32;=&#32;__prev_p-&gt;_M_nxt;
2625 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__prev_p-&gt;_M_nxt&#32;=&#32;__p;
2626 
2627 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Inserting&#32;after&#32;a&#32;node&#32;in&#32;a&#32;bucket&#32;require&#32;to&#32;check&#32;that&#32;we</emphasis>
2628 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;haven&apos;t&#32;change&#32;the&#32;bucket&#32;last&#32;node,&#32;in&#32;this&#32;case&#32;next</emphasis>
2629 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;bucket&#32;containing&#32;its&#32;before&#32;begin&#32;node&#32;must&#32;be&#32;updated.&#32;We</emphasis>
2630 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;schedule&#32;a&#32;check&#32;as&#32;soon&#32;as&#32;we&#32;move&#32;out&#32;of&#32;the&#32;sequence&#32;of</emphasis>
2631 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;equivalent&#32;nodes&#32;to&#32;limit&#32;the&#32;number&#32;of&#32;checks.</emphasis>
2632 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__check_bucket&#32;=&#32;<emphasis role="keyword">true</emphasis>;
2633 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2634 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2636 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__check_bucket)
2637 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2638 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Check&#32;if&#32;we&#32;shall&#32;update&#32;the&#32;next&#32;bucket&#32;because&#32;of</emphasis>
2639 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;insertions&#32;into&#32;__prev_bkt&#32;bucket.</emphasis>
2640 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__prev_p-&gt;_M_nxt)
2641 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2642 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__next_bkt
2643 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__hash_code_base::_M_bucket_index(
2644 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;*__prev_p-&gt;_M_next(),&#32;__bkt_count);
2645 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next_bkt&#32;!=&#32;__prev_bkt)
2646 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__next_bkt]&#32;=&#32;__prev_p;
2647 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2648 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__check_bucket&#32;=&#32;<emphasis role="keyword">false</emphasis>;
2649 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2650 
2651 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!__new_buckets[__bkt])
2652 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2653 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p-&gt;_M_nxt&#32;=&#32;_M_before_begin._M_nxt;
2654 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_M_before_begin._M_nxt&#32;=&#32;__p;
2655 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bkt]&#32;=&#32;&amp;_M_before_begin;
2656 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__p-&gt;_M_nxt)
2657 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bbegin_bkt]&#32;=&#32;__p;
2658 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bbegin_bkt&#32;=&#32;__bkt;
2659 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2660 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
2661 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
2662 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__p-&gt;_M_nxt&#32;=&#32;__new_buckets[__bkt]-&gt;_M_nxt;
2663 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__bkt]-&gt;_M_nxt&#32;=&#32;__p;
2664 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2665 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
2666 &#32;&#32;&#32;&#32;&#32;&#32;__prev_p&#32;=&#32;__p;
2667 &#32;&#32;&#32;&#32;&#32;&#32;__prev_bkt&#32;=&#32;__bkt;
2668 &#32;&#32;&#32;&#32;&#32;&#32;__p&#32;=&#32;__next;
2669 &#32;&#32;&#32;&#32;}
2670 
2671 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__check_bucket&#32;&amp;&amp;&#32;__prev_p-&gt;_M_nxt)
2672 &#32;&#32;&#32;&#32;{
2673 &#32;&#32;&#32;&#32;&#32;&#32;std::size_t&#32;__next_bkt
2674 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;=&#32;__hash_code_base::_M_bucket_index(*__prev_p-&gt;_M_next(),
2675 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__bkt_count);
2676 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(__next_bkt&#32;!=&#32;__prev_bkt)
2677 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;__new_buckets[__next_bkt]&#32;=&#32;__prev_p;
2678 &#32;&#32;&#32;&#32;}
2679 
2680 &#32;&#32;&#32;&#32;&#32;&#32;_M_deallocate_buckets();
2681 &#32;&#32;&#32;&#32;&#32;&#32;_M_bucket_count&#32;=&#32;__bkt_count;
2682 &#32;&#32;&#32;&#32;&#32;&#32;_M_buckets&#32;=&#32;__new_buckets;
2683 &#32;&#32;&#32;&#32;}
2684 
2685 <emphasis role="preprocessor">#if&#32;__cplusplus&#32;&gt;&#32;201402L</emphasis>
2686 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>,&#32;<emphasis role="keyword">typename</emphasis>&gt;&#32;<emphasis role="keyword">class&#32;</emphasis>_Hash_merge_helper&#32;{&#32;};
2687 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;C++17</emphasis>
2688 
2689 <emphasis role="preprocessor">#if&#32;__cpp_deduction_guides&#32;&gt;=&#32;201606</emphasis>
2690 &#32;&#32;<emphasis role="comment">//&#32;Used&#32;to&#32;constrain&#32;deduction&#32;guides</emphasis>
2691 &#32;&#32;<emphasis role="keyword">template</emphasis>&lt;<emphasis role="keyword">typename</emphasis>&#32;_Hash&gt;
2692 &#32;&#32;&#32;&#32;<emphasis role="keyword">using&#32;</emphasis>_RequireNotAllocatorOrIntegral
2693 &#32;&#32;&#32;&#32;&#32;&#32;=&#32;__enable_if_t&lt;!__or_&lt;is_integral&lt;_Hash&gt;,&#32;__is_allocator&lt;_Hash&gt;&gt;<link linkend="_classvalue">::value</link>&gt;;
2694 <emphasis role="preprocessor">#endif</emphasis>
2695 
2697 _GLIBCXX_END_NAMESPACE_VERSION
2698 }&#32;<emphasis role="comment">//&#32;namespace&#32;std</emphasis>
2699 
2700 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;_HASHTABLE_H</emphasis>
</programlisting></section>
