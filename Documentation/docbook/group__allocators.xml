<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__allocators" xml:lang="en-US">
<title>Allocators</title>
<indexterm><primary>Allocators</primary></indexterm>
Collaboration diagram for Allocators:<para>
    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="group__allocators.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>namespace std <link linkend="_group__allocators_1ga56fd5a6be7c55e53e3eb59de5aa1ab9b">_GLIBCXX_VISIBILITY</link> (default)</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Classes encapsulating memory operations.</para>

<para>Classes encapsulating memory operations.</para>

<para>Classes encapsulating memory operations.</para>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_group__allocators_1ga56fd5a6be7c55e53e3eb59de5aa1ab9b"/><section>
    <title>_GLIBCXX_VISIBILITY()</title>
<indexterm><primary>_GLIBCXX_VISIBILITY</primary><secondary>Allocators</secondary></indexterm>
<indexterm><primary>Allocators</primary><secondary>_GLIBCXX_VISIBILITY</secondary></indexterm>
<para><computeroutput>namespace __gnu_cxx _GLIBCXX_VISIBILITY (default )</computeroutput></para>
<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Uniform interface to C++98 and C++11 allocators.</para>

<para>A meta-allocator with debugging bits.</para>

<para>This is precisely the allocator defined in the C++03 Standard.</para>

<para>An example allocator which uses a non-standard pointer type.</para>

<para>This allocator specifies that containers use a &apos;relative pointer&apos; as it&apos;s pointer type. (See ext/pointer.h) Memory allocation in this example is still performed using std::allocator.</para>

<para>An allocator that uses malloc.</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls malloc</para>
</listitem><listitem>
<para>all deallocation calls free</para>
</listitem></itemizedlist>
</para>

<para>Base class for pool object.</para>

<para>Data describing the underlying memory pool, parameterized on threading support.</para>

<para>Specialization for single thread.</para>

<para>Policy for shared __pool objects.</para>

<para>Policy for individual __pool objects.</para>

<para>Base class for _Tp dependent member functions.</para>

<para>This is a fixed size (power of 2) allocator which - when compiled with thread support - will maintain one freelist per size per thread plus a <emphasis>global</emphasis> one. Steps are taken to limit the per thread freelist sizes (by returning excess back to the <emphasis>global</emphasis> list).</para>

<para>Further details: <link xlink:href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html</link></para>

<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Base class for __pool_alloc.</para>

<para>Uses various allocators to fulfill underlying requests (and makes as few requests as possible when in default high-speed pool mode).</para>

<para>Important implementation properties: 0. If globally mandated, then allocate objects from new<orderedlist>
<listitem>
<para>If the clients request an object of size &gt; _S_max_bytes, the resulting object will be obtained directly from new</para>
</listitem><listitem>
<para>In all other cases, we allocate an object of size exactly _S_round_up(requested_size). Thus the client has enough size information that we can return the object to the proper free list without permanently losing part of the object.</para>
</listitem></orderedlist>
</para>

<para>Allocator using a memory pool with a single lock.</para>

<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Uniform interface to C++98 and C++11 allocators.</para>

<para>A meta-allocator with debugging bits.</para>

<para>This is precisely the allocator defined in the C++03 Standard.</para>

<para>An example allocator which uses a non-standard pointer type.</para>

<para>This allocator specifies that containers use a &apos;relative pointer&apos; as it&apos;s pointer type. (See ext/pointer.h) Memory allocation in this example is still performed using std::allocator.</para>

<para>An allocator that uses malloc.</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls malloc</para>
</listitem><listitem>
<para>all deallocation calls free</para>
</listitem></itemizedlist>
</para>

<para>Base class for pool object.</para>

<para>Data describing the underlying memory pool, parameterized on threading support.</para>

<para>Specialization for single thread.</para>

<para>Policy for shared __pool objects.</para>

<para>Policy for individual __pool objects.</para>

<para>Base class for _Tp dependent member functions.</para>

<para>This is a fixed size (power of 2) allocator which - when compiled with thread support - will maintain one freelist per size per thread plus a <emphasis>global</emphasis> one. Steps are taken to limit the per thread freelist sizes (by returning excess back to the <emphasis>global</emphasis> list).</para>

<para>Further details: <link xlink:href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html</link></para>

<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Base class for __pool_alloc.</para>

<para>Uses various allocators to fulfill underlying requests (and makes as few requests as possible when in default high-speed pool mode).</para>

<para>Important implementation properties: 0. If globally mandated, then allocate objects from new<orderedlist>
<listitem>
<para>If the clients request an object of size &gt; _S_max_bytes, the resulting object will be obtained directly from new</para>
</listitem><listitem>
<para>In all other cases, we allocate an object of size exactly _S_round_up(requested_size). Thus the client has enough size information that we can return the object to the proper free list without permanently losing part of the object.</para>
</listitem></orderedlist>
</para>

<para>Allocator using a memory pool with a single lock.</para>

<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Uniform interface to C++98 and C++11 allocators.</para>

<para>A meta-allocator with debugging bits.</para>

<para>This is precisely the allocator defined in the C++03 Standard.</para>

<para>An example allocator which uses a non-standard pointer type.</para>

<para>This allocator specifies that containers use a &apos;relative pointer&apos; as it&apos;s pointer type. (See ext/pointer.h) Memory allocation in this example is still performed using std::allocator.</para>

<para>An allocator that uses malloc.</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls malloc</para>
</listitem><listitem>
<para>all deallocation calls free</para>
</listitem></itemizedlist>
</para>

<para>Base class for pool object.</para>

<para>Data describing the underlying memory pool, parameterized on threading support.</para>

<para>Specialization for single thread.</para>

<para>Policy for shared __pool objects.</para>

<para>Policy for individual __pool objects.</para>

<para>Base class for _Tp dependent member functions.</para>

<para>This is a fixed size (power of 2) allocator which - when compiled with thread support - will maintain one freelist per size per thread plus a <emphasis>global</emphasis> one. Steps are taken to limit the per thread freelist sizes (by returning excess back to the <emphasis>global</emphasis> list).</para>

<para>Further details: <link xlink:href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.html</link></para>

<para>An allocator that uses global new, as per C++03 [20.4.1].</para>

<para>This is precisely the allocator defined in the C++ Standard.<itemizedlist>
<listitem>
<para>all allocation calls operator new</para>
</listitem><listitem>
<para>all deallocation calls operator delete</para>
</listitem></itemizedlist>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>_Tp</entry><entry>
<para>Type of allocated object.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                Base class for __pool_alloc.</para>

<para>Uses various allocators to fulfill underlying requests (and makes as few requests as possible when in default high-speed pool mode).</para>

<para>Important implementation properties: 0. If globally mandated, then allocate objects from new<orderedlist>
<listitem>
<para>If the clients request an object of size &gt; _S_max_bytes, the resulting object will be obtained directly from new</para>
</listitem><listitem>
<para>In all other cases, we allocate an object of size exactly _S_round_up(requested_size). Thus the client has enough size information that we can return the object to the proper free list without permanently losing part of the object.</para>
</listitem></orderedlist>
</para>

<para>Allocator using a memory pool with a single lock.</para>
</section>
</section>
</section>
