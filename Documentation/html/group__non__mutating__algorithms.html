<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Minero: Non-Mutating</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">Minero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__non__mutating__algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Non-Mutating<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Non-Mutating:</div>
<div class="dyncontent">
<div class="center"><img src="group__non__mutating__algorithms.png" border="0" usemap="#agroup____non____mutating____algorithms" alt=""/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga544d74b2d5d0dd2197f5fd6f02691de0" id="r_ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memItemLeft" align="right" valign="top">namespace std&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__non__mutating__algorithms.html#ga544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</a> (default)</td></tr>
<tr class="separator:ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga544d74b2d5d0dd2197f5fd6f02691de0" name="ga544d74b2d5d0dd2197f5fd6f02691de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544d74b2d5d0dd2197f5fd6f02691de0">&#9670;&#160;</a></span>_GLIBCXX_VISIBILITY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">namespace std _GLIBCXX_VISIBILITY </td>
          <td>(</td>
          <td class="paramtype">default&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the contents of two iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__b</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function swaps the values pointed to by two iterators, not the iterators themselves.</p>
<p>Swap the elements of two sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator equal to <code>first2+</code>(last1-first1).</dd></dl>
<p>Swaps each element in the range <code></code>[first1,last1) with the corresponding element in the range <code></code>[first2,(last1-first1)). The ranges must not overlap.</p>
<p>This does what you think it does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro.</p>
<p>This does what you think it does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro.</p>
<p>This does what you think it does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="group__comparison__functors.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro.</p>
<p>This does what you think it does.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="group__comparison__functors.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro.</p>
<p>Copies the range [first,last) into result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result + (last - first)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). Result may not be contained within [first,last); the copy_backward function should be used instead.</p>
<p>Note that the end of the output range is permitted to be contained within [first,last).</p>
<p>Copies the range [first,last) into result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result - (last - first)</dd></dl>
<p>The function has the same effect as copy, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling).</p>
<p>Result may not be in the range (first,last]. Use copy instead. Note that the start of the output range may overlap [first,last).</p>
<p>Fills the range [first,last) with copies of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or <code>wmemset</code>.</p>
<p>Fills the range [first,first+n) with copies of value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The count of copies to perform. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator at first+n.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or <code>wmemset</code>.</p>
<p>If <code>__n</code> is negative, the function does nothing.</p>
<p>Finds the first position in which <em>val</em> could be inserted without changing the ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element <em>not less than</em> <em>val</em>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if every element is less than <em>val</em>.</dd></dl>
<p>This is a helper function for the sort routines and for random.tcc.</p>
<p>Tests a range for element-wise equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal.</p>
<p>Tests a range for element-wise equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="group__functors.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal.</p>
<p>Performs <b>dictionary</b> comparison on ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p><em>Returns true if the sequence of elements defined by the range [first1,last1) is lexicographically less than the sequence of elements defined by the range [first2,last2). Returns false otherwise.</em> (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to <code>memcmp</code>.</p>
<p>Performs <b>dictionary</b> comparison on ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="group__comparison__functors.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>The same as the four-parameter <code>lexicographical_compare</code>, but uses the comp parameter instead of <code>&lt;</code>.</p>
<p>Finds the places in ranges which don't match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal.</p>
<p>Finds the places in ranges which don't match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="group__functors.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal.</p>
<p>This is an overload used by find algos for the Input Iterator case.</p>
<p>This is an overload used by find algos for the RAI case.</p>
<p>Swaps the median value of *__a, *__b and *__c under __comp to *__result</p>
<p>Provided for stable_partition to use.</p>
<p>Like find_if_not(), but uses and updates a count of the remaining range length instead of comparing against an end iterator.</p>
<p>This is an helper function for search_n overloaded for forward iterators.</p>
<p>This is an helper function for search_n overloaded for random access iterators.</p>
<p>Find last matching subsequence in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first1,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Find last matching subsequence in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code></code>(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Copy a sequence, removing elements of a given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) not equal to <code>__value</code> to the range beginning at <code>__result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Copy a sequence, removing elements for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns false to the range beginning at <code>__result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Remove elements from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code>__value</code> are removed from the range <code></code>[__first,__last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove elements from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code>__pred</code> returns true are removed from the range <code></code>[__first,__last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive duplicate values from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive values from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code>__binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for forward iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and forward iterator as result.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for bidirectional iterators.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for random access iterators.</p>
<p>Reverse a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code></code>[__first,__last), so that the first element becomes the last etc. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first)/2), <code>reverse()</code> swaps <code>*</code>(__first+i) and <code>*</code>(__last-(i+1))</p>
<p>Copy a sequence, reversing its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) such that the order of the elements is reversed. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first), <code>reverse_copy()</code> performs the assignment <code>*</code>(__result+(__last-__first)-1-i) = *(__first+i). The ranges <code></code>[__first,__last) and <code></code>[__result,__result+(__last-__first)) must not overlap.</p>
<p>This is a helper function for the rotate algorithm specialized on RAIs. It returns the greatest common divisor of two integer values.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>Rotate the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first + (last - middle).</dd></dl>
<p>Rotates the elements of the range <code></code>[__first,__last) by <code></code>(__middle - __first) positions so that the element at <code>__middle</code> is moved to <code>__first</code>, the element at <code>__middle+1</code> is moved to <code>__first+1</code> and so on for each element in the range <code></code>[__first,__last).</p>
<p>This effectively swaps the ranges <code></code>[__first,__middle) and <code></code>[__middle,__last).</p>
<p>Performs <code>*</code>(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first).</p>
<p>Copy a sequence, rotating its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements of the range <code></code>[__first,__last) to the range beginning at </p><dl class="section return"><dt>Returns</dt><dd>, rotating the copied elements by <code></code>(__middle-__first) positions so that the element at <code>__middle</code> is moved to <code>__result</code>, the element at <code>__middle+1</code> is moved to <code>__result+1</code> and so on for each element in the range <code></code>[__first,__last).</dd></dl>
<p>Performs <code>*</code>(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first).</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function... Requires __first != __last and !__pred(__first) and __len == distance(__first, __last).</p>
<p>!__pred(__first) allows us to guarantee that we don't move-assign an element onto itself.</p>
<p>Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[first,middle) and false for each <code>i</code> in the range <code></code>[middle,last).</dd></dl>
<p>Performs the same function as <code>partition()</code> with the additional guarantee that the relative ordering of elements in each group is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__pred(x)==__pred(y)</code> will have the same relative ordering after calling <code>stable_partition()</code>.</p>
<p>This is a helper function for the sort routines.</p>
<p>Copy the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>__result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then *j&lt;*i is false. The value returned is <code>__result_first+N</code>.</p>
<p>Copy the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then <code>__comp(*j,*i)</code> is false. The value returned is <code>__result_first+N</code>.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>@doctodo This controls some aspect of the sort routines.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function for the sort routine.</p>
<p>Finds the first position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element <em>not less than</em> <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if every element is less than <code>__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the last position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if no elements are greater than <code>__val</code>.</dd></dl>
<p>Finds the last position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if no elements are greater than <code>__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the largest subrange in which <code>__val</code> could be inserted at any place in it without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>),</div>
<div class="line">               upper_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>))</div>
<div class="ttc" id="a_classes_2lib_2include_2stdatomic_8h_html_a15181bfd16829c92971879064b9d8dbb"><div class="ttname"><a href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a></div><div class="ttdeci">unsigned char __val</div><div class="ttdef"><b>Definition</b> stdatomic.h:223</div></div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Finds the largest subrange in which <code>__val</code> could be inserted at any place in it without changing the ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>, __comp),</div>
<div class="line">               upper_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>, __comp))</div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>__val</code> (or its equivalent) is in [<code>__first</code>,<code>__last</code> ].</dd></dl>
<p>Note that this does not actually return an iterator to <code>__val</code>. For that, use <a class="el" href="namespacestd.html#ae3e398a3f38b0182e770944d57402701">std::find</a> or a container's specialized find member functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>__val</code> (or its equivalent) is in <code></code>[__first,__last].</dd></dl>
<p>Note that this does not actually return an iterator to <code>__val</code>. For that, use <a class="el" href="namespacestd.html#ae3e398a3f38b0182e770944d57402701">std::find</a> or a container's specialized find member functions.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_sort_loop routines.</p>
<p>This is a helper function for the stable sorting routines.</p>
<p>Determines whether all elements of a sequence exists in a range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1). False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1). The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned.</p>
<p>Determines whether all elements of a sequence exists in a range using comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1) according to comp. False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1), using comp to decide. The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Copy a sequence, replacing each element of one value with another value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>result+</code>(last-first).</dd></dl>
<p>Copies each element in the input range <code></code>[__first,__last) to the output range <code></code>[__result,__result+(__last-__first)) replacing elements equal to <code>__old_value</code> with <code>__new_value</code>.</p>
<p>Copy a sequence, replacing each value for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>__result+</code>(__last-__first).</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) replacing elements for which <code>__pred</code> returns true with <code>__new_value</code>.</p>
<p>Apply a function to every element of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>__f</code> </dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code></code>[first,last). <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored.</p>
<p>Find the first occurrence of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>*i</code> == <code>__val</code>, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find the first element in a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is true, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find element from a set in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>*i</code> == <code>*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>.</p>
<p>Find element from a set in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>comp</code>(*i, <code>*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>.</p>
<p>Find two adjacent values in a sequence that are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find two adjacent values in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>__binary_pred</code>(*i,*(i+1)) is true, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Count the number of copies of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>*i</code> == <code>__value</code> </dd></dl>
<p>Count the elements of a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>__pred(*i)</code> is true.</dd></dl>
<p>Search a sequence for a matching sub-sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Search a sequence for a matching sub-sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2), using <code>__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)</dd></dl>
<p>Search a sequence for a number of consecutive values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code>__val</code> for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>count</code> consecutive elements equal to <code>__val</code>.</p>
<p>Search a sequence for a number of consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>__count</code> consecutive elements for which the predicate returns true.</p>
<p>Perform an operation on a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result+</code>(__last-__first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=unary_op(*(__first+N)) for each <code>N</code> in the range <code></code>[0,__last-__first).</p>
<p><code>unary_op</code> must not alter its argument.</p>
<p>Perform an operation on corresponding elements of two sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each <code>N</code> in the range <code></code>[0,__last1-__first1).</p>
<p><code>binary_op</code> must not alter either of its arguments.</p>
<p>Replace each occurrence of one value in a sequence with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>*i</code> == <code>__old_value</code> then the assignment <code>*i</code> = <code>__new_value</code> is performed.</p>
<p>Replace each value in a sequence for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>__pred(*i)</code> is true then the assignment <code>*i</code> = <code>__new_value</code> is performed.</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__last).</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the sequence, <code>__first+__n</code> </dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__first+__n).</p>
<p>If <code>__n</code> is negative, the function does nothing and returns <code>__first</code>.</p>
<p>Copy a sequence, removing consecutive duplicate values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 538. 241 again: Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Copy a sequence, removing consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements for which <code>__binary_pred</code> returns true. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Shuffle the elements of a sequence using a random number generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code></code>[__first,__last) using <code>__rand</code> to provide a random distribution. Calling <code>__rand(N)</code> for a positive integer <code>N</code> should return a randomly chosen integer from the range [0,N).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Since C++14 <code>std::random_shuffle</code> is not part of the C++ standard. Use <code>std::shuffle</code> instead, which was introduced in C++11. </dd></dl>
<p>Move elements for which a predicate is true to the beginning of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[__first,middle) and false for each <code>i</code> in the range <code></code>[middle,__last).</dd></dl>
<p><code>__pred</code> must not modify its operand. <code>partition()</code> does not preserve the relative ordering of elements in each group, use <code>stable_partition()</code> if this is needed.</p>
<p>Sort the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[first,last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then *j&lt;*i and *k&lt;*i are both false.</p>
<p>Sort the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[__first,__last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then <code>*__comp</code>(j,*i) and <code>__comp(*k,*i)</code> are both false.</p>
<p>Sort a sequence just enough to find a particular position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that *j &lt; *i is false.</p>
<p>Sort a sequence just enough to find a particular position using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that <code>__comp(*j,*i)</code> is false.</p>
<p>Sort the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <em>i</em> in the range <code></code>[__first,__last-1), <br  />
 *(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed.</p>
<p>Sort the elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that <code>__comp</code>(*(i+1),*i) is false for every iterator <em>i</em> in the range <code></code>[__first,__last-1).</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Sort the elements of a sequence, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>x&lt;y</code> is false and <code>y&lt;x</code> is false will have the same relative ordering after calling <code>stable_sort()</code>.</p>
<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__comp(x,y)</code> is false and <code>__comp(y,x)</code> is false will have the same relative ordering after calling <code>stable_sort()</code>.</p>
<p>Return the union of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the union of two sorted ranges using a comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that element is copied and the iterator advanced. If an equivalent element according to <code>__comp</code> is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that iterator advances. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that iterator advances. If an element is contained in both ranges according to <code>__comp</code>, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second, that element is copied and the iterator advances. If the current element of the second range is less, the iterator advances, but no element is copied. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second according to <code>__comp</code>, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>comp</code>, that element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the minimum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value.</dd></dl>
<p>Return the minimum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value according to __comp.</dd></dl>
<p>Return the maximum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value.</dd></dl>
<p>Return the maximum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value according to __comp.</dd></dl>
<p>Swaps the median value of *__a, *__b and *__c under __comp to *__result</p>
<p>Provided for stable_partition to use.</p>
<p>Like find_if_not(), but uses and updates a count of the remaining range length instead of comparing against an end iterator.</p>
<p>This is an helper function for search_n overloaded for forward iterators.</p>
<p>This is an helper function for search_n overloaded for random access iterators.</p>
<p>Find last matching subsequence in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first1,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Find last matching subsequence in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code></code>(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Copy a sequence, removing elements of a given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) not equal to <code>__value</code> to the range beginning at <code>__result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Copy a sequence, removing elements for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns false to the range beginning at <code>__result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Remove elements from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code>__value</code> are removed from the range <code></code>[__first,__last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove elements from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code>__pred</code> returns true are removed from the range <code></code>[__first,__last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive duplicate values from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive values from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code>__binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for forward iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and forward iterator as result.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for bidirectional iterators.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for random access iterators.</p>
<p>Reverse a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code></code>[__first,__last), so that the first element becomes the last etc. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first)/2), <code>reverse()</code> swaps <code>*</code>(__first+i) and <code>*</code>(__last-(i+1))</p>
<p>Copy a sequence, reversing its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) such that the order of the elements is reversed. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first), <code>reverse_copy()</code> performs the assignment <code>*</code>(__result+(__last-__first)-1-i) = *(__first+i). The ranges <code></code>[__first,__last) and <code></code>[__result,__result+(__last-__first)) must not overlap.</p>
<p>This is a helper function for the rotate algorithm specialized on RAIs. It returns the greatest common divisor of two integer values.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>Rotate the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first + (last - middle).</dd></dl>
<p>Rotates the elements of the range <code></code>[__first,__last) by <code></code>(__middle - __first) positions so that the element at <code>__middle</code> is moved to <code>__first</code>, the element at <code>__middle+1</code> is moved to <code>__first+1</code> and so on for each element in the range <code></code>[__first,__last).</p>
<p>This effectively swaps the ranges <code></code>[__first,__middle) and <code></code>[__middle,__last).</p>
<p>Performs <code>*</code>(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first).</p>
<p>Copy a sequence, rotating its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements of the range <code></code>[__first,__last) to the range beginning at </p><dl class="section return"><dt>Returns</dt><dd>, rotating the copied elements by <code></code>(__middle-__first) positions so that the element at <code>__middle</code> is moved to <code>__result</code>, the element at <code>__middle+1</code> is moved to <code>__result+1</code> and so on for each element in the range <code></code>[__first,__last).</dd></dl>
<p>Performs <code>*</code>(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first).</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function... Requires __first != __last and !__pred(__first) and __len == distance(__first, __last).</p>
<p>!__pred(__first) allows us to guarantee that we don't move-assign an element onto itself.</p>
<p>Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[first,middle) and false for each <code>i</code> in the range <code></code>[middle,last).</dd></dl>
<p>Performs the same function as <code>partition()</code> with the additional guarantee that the relative ordering of elements in each group is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__pred(x)==__pred(y)</code> will have the same relative ordering after calling <code>stable_partition()</code>.</p>
<p>This is a helper function for the sort routines.</p>
<p>Copy the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>__result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then *j&lt;*i is false. The value returned is <code>__result_first+N</code>.</p>
<p>Copy the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then <code>__comp(*j,*i)</code> is false. The value returned is <code>__result_first+N</code>.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>@doctodo This controls some aspect of the sort routines.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function for the sort routine.</p>
<p>Finds the first position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element <em>not less than</em> <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if every element is less than <code>__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the last position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if no elements are greater than <code>__val</code>.</dd></dl>
<p>Finds the last position in which <code>__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code>__val</code>, or <a class="el" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a432111147038972f06e049e18a837002">end()</a> if no elements are greater than <code>__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the largest subrange in which <code>__val</code> could be inserted at any place in it without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>),</div>
<div class="line">               upper_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>))</div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Finds the largest subrange in which <code>__val</code> could be inserted at any place in it without changing the ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>, __comp),</div>
<div class="line">               upper_bound(__first, __last, <a class="code hl_variable" href="_classes_2lib_2include_2stdatomic_8h.html#a15181bfd16829c92971879064b9d8dbb">__val</a>, __comp))</div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>__val</code> (or its equivalent) is in [<code>__first</code>,<code>__last</code> ].</dd></dl>
<p>Note that this does not actually return an iterator to <code>__val</code>. For that, use <a class="el" href="namespacestd.html#ae3e398a3f38b0182e770944d57402701">std::find</a> or a container's specialized find member functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>__val</code> (or its equivalent) is in <code></code>[__first,__last].</dd></dl>
<p>Note that this does not actually return an iterator to <code>__val</code>. For that, use <a class="el" href="namespacestd.html#ae3e398a3f38b0182e770944d57402701">std::find</a> or a container's specialized find member functions.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_sort_loop routines.</p>
<p>This is a helper function for the stable sorting routines.</p>
<p>Determines whether all elements of a sequence exists in a range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1). False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1). The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned.</p>
<p>Determines whether all elements of a sequence exists in a range using comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1) according to comp. False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1), using comp to decide. The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Copy a sequence, replacing each element of one value with another value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>result+</code>(last-first).</dd></dl>
<p>Copies each element in the input range <code></code>[__first,__last) to the output range <code></code>[__result,__result+(__last-__first)) replacing elements equal to <code>__old_value</code> with <code>__new_value</code>.</p>
<p>Copy a sequence, replacing each value for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>__result+</code>(__last-__first).</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) replacing elements for which <code>__pred</code> returns true with <code>__new_value</code>.</p>
<p>Apply a function to every element of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>__f</code> </dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code></code>[first,last). <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored.</p>
<p>Find the first occurrence of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>*i</code> == <code>__val</code>, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find the first element in a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is true, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find element from a set in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>*i</code> == <code>*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>.</p>
<p>Find element from a set in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>comp</code>(*i, <code>*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>.</p>
<p>Find two adjacent values in a sequence that are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Find two adjacent values in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>__binary_pred</code>(*i,*(i+1)) is true, or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Count the number of copies of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>*i</code> == <code>__value</code> </dd></dl>
<p>Count the elements of a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>__pred(*i)</code> is true.</dd></dl>
<p>Search a sequence for a matching sub-sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2))</p>
<p>Search a sequence for a matching sub-sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2), using <code>__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)</dd></dl>
<p>Search a sequence for a number of consecutive values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code>__val</code> for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>count</code> consecutive elements equal to <code>__val</code>.</p>
<p>Search a sequence for a number of consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>__count</code> consecutive elements for which the predicate returns true.</p>
<p>Perform an operation on a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result+</code>(__last-__first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=unary_op(*(__first+N)) for each <code>N</code> in the range <code></code>[0,__last-__first).</p>
<p><code>unary_op</code> must not alter its argument.</p>
<p>Perform an operation on corresponding elements of two sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each <code>N</code> in the range <code></code>[0,__last1-__first1).</p>
<p><code>binary_op</code> must not alter either of its arguments.</p>
<p>Replace each occurrence of one value in a sequence with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>*i</code> == <code>__old_value</code> then the assignment <code>*i</code> = <code>__new_value</code> is performed.</p>
<p>Replace each value in a sequence for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>__pred(*i)</code> is true then the assignment <code>*i</code> = <code>__new_value</code> is performed.</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__last).</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the sequence, <code>__first+__n</code> </dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__first+__n).</p>
<p>If <code>__n</code> is negative, the function does nothing and returns <code>__first</code>.</p>
<p>Copy a sequence, removing consecutive duplicate values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 538. 241 again: Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Copy a sequence, removing consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements for which <code>__binary_pred</code> returns true. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Shuffle the elements of a sequence using a random number generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code></code>[__first,__last) using <code>__rand</code> to provide a random distribution. Calling <code>__rand(N)</code> for a positive integer <code>N</code> should return a randomly chosen integer from the range [0,N).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Since C++14 <code>std::random_shuffle</code> is not part of the C++ standard. Use <code>std::shuffle</code> instead, which was introduced in C++11. </dd></dl>
<p>Move elements for which a predicate is true to the beginning of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[__first,middle) and false for each <code>i</code> in the range <code></code>[middle,__last).</dd></dl>
<p><code>__pred</code> must not modify its operand. <code>partition()</code> does not preserve the relative ordering of elements in each group, use <code>stable_partition()</code> if this is needed.</p>
<p>Sort the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[first,last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then *j&lt;*i and *k&lt;*i are both false.</p>
<p>Sort the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[__first,__last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then <code>*__comp</code>(j,*i) and <code>__comp(*k,*i)</code> are both false.</p>
<p>Sort a sequence just enough to find a particular position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that *j &lt; *i is false.</p>
<p>Sort a sequence just enough to find a particular position using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that <code>__comp(*j,*i)</code> is false.</p>
<p>Sort the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <em>i</em> in the range <code></code>[__first,__last-1), <br  />
 *(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed.</p>
<p>Sort the elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that <code>__comp</code>(*(i+1),*i) is false for every iterator <em>i</em> in the range <code></code>[__first,__last-1).</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Sort the elements of a sequence, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>x&lt;y</code> is false and <code>y&lt;x</code> is false will have the same relative ordering after calling <code>stable_sort()</code>.</p>
<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__comp(x,y)</code> is false and <code>__comp(y,x)</code> is false will have the same relative ordering after calling <code>stable_sort()</code>.</p>
<p>Return the union of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the union of two sorted ranges using a comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that element is copied and the iterator advanced. If an equivalent element according to <code>__comp</code> is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that iterator advances. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that iterator advances. If an element is contained in both ranges according to <code>__comp</code>, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second, that element is copied and the iterator advances. If the current element of the second range is less, the iterator advances, but no element is copied. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second according to <code>__comp</code>, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__result</td><td>Start of output range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>comp</code>, that element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the minimum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value.</dd></dl>
<p>Return the minimum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value according to __comp.</dd></dl>
<p>Return the maximum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value.</dd></dl>
<p>Return the maximum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value according to __comp.</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__non__mutating__algorithms_ga544d74b2d5d0dd2197f5fd6f02691de0_cgraph.png" border="0" usemap="#agroup__non__mutating__algorithms_ga544d74b2d5d0dd2197f5fd6f02691de0_cgraph" alt=""/></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
