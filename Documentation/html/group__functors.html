<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Minero: Function Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">Minero
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__functors.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Function Objects<div class="ingroups"><a class="el" href="group__utilities.html">Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Function Objects:</div>
<div class="dyncontent">
<div class="center"><img src="group__functors.png" border="0" usemap="#agroup____functors" alt=""/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__binders" id="r_group__binders"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binders.html">Binder Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__hashes" id="r_group__hashes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hashes.html">Hashes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__arithmetic__functors" id="r_group__arithmetic__functors"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithmetic__functors.html">Arithmetic Function Object Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga544d74b2d5d0dd2197f5fd6f02691de0" id="r_ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memItemLeft" align="right" valign="top">namespace std&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functors.html#ga544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</a> (default)</td></tr>
<tr class="separator:ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Function objects, or <em>functors</em>, are objects with an <code>operator()</code> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <em>functors</em>, then, generally we include function pointers in the description as well.</p>
<p>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</p>
<p>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <code>a</code> and <code>b</code> containing <code>double</code>, and put the result in <code>a</code>, use </p><div class="fragment"><div class="line">transform (<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), plus&lt;double&gt;());</div>
<div class="ttc" id="a_classes_2lib_2raylib_2src_2external_2glad_8h_html_a6eba317e3cf44d6d26c04a5a8f197dcb"><div class="ttname"><a href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a></div><div class="ttdeci">GLboolean GLboolean GLboolean b</div><div class="ttdef"><b>Definition</b> glad.h:1629</div></div>
<div class="ttc" id="a_classes_2lib_2raylib_2src_2external_2glad_8h_html_ac8729153468b5dcf13f971b21d84d4e5"><div class="ttname"><a href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a></div><div class="ttdeci">GLboolean GLboolean GLboolean GLboolean a</div><div class="ttdef"><b>Definition</b> glad.h:1629</div></div>
</div><!-- fragment --><p> To negate every element in <code>a</code>, use </p><div class="fragment"><div class="line">transform(<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), negate&lt;double&gt;());</div>
</div><!-- fragment --><p> The addition and negation functions will usually be inlined directly.</p>
<p>An <em>adaptable function object</em> is one which provides nested typedefs <code>result_type</code> and either <code>argument_type</code> (for a unary function) or <code>first_argument_type</code> and <code>second_argument_type</code> (for a binary function). Those typedefs are used by function object adaptors such as <code>bind2nd</code>. The standard library provides two class templates, <code>unary_function</code> and <code>binary_function</code>, which define those typedefs and so can be used as base classes of adaptable function objects.</p>
<p>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <code>function&lt;&gt;</code>, and more powerful type deduction (using <code>auto</code> and <code>decltype</code>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</p>
<p>Function objects, or <em>functors</em>, are objects with an <code>operator()</code> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <em>functors</em>, then, generally we include function pointers in the description as well.</p>
<p>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</p>
<p>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <code>a</code> and <code>b</code> containing <code>double</code>, and put the result in <code>a</code>, use </p><div class="fragment"><div class="line">transform (<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), plus&lt;double&gt;());</div>
</div><!-- fragment --><p> To negate every element in <code>a</code>, use </p><div class="fragment"><div class="line">transform(<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), negate&lt;double&gt;());</div>
</div><!-- fragment --><p> The addition and negation functions will usually be inlined directly.</p>
<p>An <em>adaptable function object</em> is one which provides nested typedefs <code>result_type</code> and either <code>argument_type</code> (for a unary function) or <code>first_argument_type</code> and <code>second_argument_type</code> (for a binary function). Those typedefs are used by function object adaptors such as <code>bind2nd</code>. The standard library provides two class templates, <code>unary_function</code> and <code>binary_function</code>, which define those typedefs and so can be used as base classes of adaptable function objects.</p>
<p>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <code>function&lt;&gt;</code>, and more powerful type deduction (using <code>auto</code> and <code>decltype</code>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</p>
<p>Function objects, or <em>functors</em>, are objects with an <code>operator()</code> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <em>functors</em>, then, generally we include function pointers in the description as well.</p>
<p>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</p>
<p>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <code>a</code> and <code>b</code> containing <code>double</code>, and put the result in <code>a</code>, use </p><div class="fragment"><div class="line">transform (<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), plus&lt;double&gt;());</div>
</div><!-- fragment --><p> To negate every element in <code>a</code>, use </p><div class="fragment"><div class="line">transform(<a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.end(), <a class="code hl_typedef" href="_classes_2lib_2raylib_2src_2external_2glad_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a>.begin(), negate&lt;double&gt;());</div>
</div><!-- fragment --><p> The addition and negation functions will usually be inlined directly.</p>
<p>An <em>adaptable function object</em> is one which provides nested typedefs <code>result_type</code> and either <code>argument_type</code> (for a unary function) or <code>first_argument_type</code> and <code>second_argument_type</code> (for a binary function). Those typedefs are used by function object adaptors such as <code>bind2nd</code>. The standard library provides two class templates, <code>unary_function</code> and <code>binary_function</code>, which define those typedefs and so can be used as base classes of adaptable function objects.</p>
<p>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <code>function&lt;&gt;</code>, and more powerful type deduction (using <code>auto</code> and <code>decltype</code>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension.</p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga544d74b2d5d0dd2197f5fd6f02691de0" name="ga544d74b2d5d0dd2197f5fd6f02691de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544d74b2d5d0dd2197f5fd6f02691de0">&#9670;&#160;</a></span>_GLIBCXX_VISIBILITY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">namespace std _GLIBCXX_VISIBILITY </td>
          <td>(</td>
          <td class="paramtype">default&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Polymorphic function wrapper.</p>
<dl class="section since"><dt>Since</dt><dd>C++23</dd></dl>
<p>The <code>std::move_only_function</code> class template is a call wrapper similar to * <code>std::function</code>, but does not require the stored target function to be copyable.</p>
<p>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <code>move_only_function::operator()</code> member function are respected when invoking the target function.</p>
<p>Creates an empty object.</p>
<p>Creates an empty object.</p>
<p>Moves the target object, leaving the source empty.</p>
<p>Stores a target object initialized from the argument.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a new target object, leaving <code>x</code> empty.</p>
<p>Destroys the target object (if any).</p>
<p>Stores a new target object, initialized from the argument.</p>
<p>True if a target object is present, false otherwise.</p>
<p>Invoke the target object.</p>
<p>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <code>move_only_function</code> specialization.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Must not be empty.</dd></dl>
<p>Exchange the target objects (if any).</p>
<p>Exchange the target objects (if any).</p>
<p>Check for emptiness by comparing with <code>nullptr</code>.</p>
<p>Polymorphic function wrapper.</p>
<dl class="section since"><dt>Since</dt><dd>C++23</dd></dl>
<p>The <code>std::move_only_function</code> class template is a call wrapper similar to * <code>std::function</code>, but does not require the stored target function to be copyable.</p>
<p>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <code>move_only_function::operator()</code> member function are respected when invoking the target function.</p>
<p>Creates an empty object.</p>
<p>Creates an empty object.</p>
<p>Moves the target object, leaving the source empty.</p>
<p>Stores a target object initialized from the argument.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a new target object, leaving <code>x</code> empty.</p>
<p>Destroys the target object (if any).</p>
<p>Stores a new target object, initialized from the argument.</p>
<p>True if a target object is present, false otherwise.</p>
<p>Invoke the target object.</p>
<p>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <code>move_only_function</code> specialization.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Must not be empty.</dd></dl>
<p>Exchange the target objects (if any).</p>
<p>Exchange the target objects (if any).</p>
<p>Check for emptiness by comparing with <code>nullptr</code>.</p>
<p>Polymorphic function wrapper.</p>
<dl class="section since"><dt>Since</dt><dd>C++23</dd></dl>
<p>The <code>std::move_only_function</code> class template is a call wrapper similar to * <code>std::function</code>, but does not require the stored target function to be copyable.</p>
<p>It also supports const-qualification, ref-qualification, and no-throw guarantees. The qualifications and exception-specification of the <code>move_only_function::operator()</code> member function are respected when invoking the target function.</p>
<p>Creates an empty object.</p>
<p>Creates an empty object.</p>
<p>Moves the target object, leaving the source empty.</p>
<p>Stores a target object initialized from the argument.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a target object initialized from the arguments.</p>
<p>Stores a new target object, leaving <code>x</code> empty.</p>
<p>Destroys the target object (if any).</p>
<p>Stores a new target object, initialized from the argument.</p>
<p>True if a target object is present, false otherwise.</p>
<p>Invoke the target object.</p>
<p>The target object will be invoked using the supplied arguments, and as an lvalue or rvalue, and as const or non-const, as dictated by the template arguments of the <code>move_only_function</code> specialization.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Must not be empty.</dd></dl>
<p>Exchange the target objects (if any).</p>
<p>Exchange the target objects (if any).</p>
<p>Check for emptiness by comparing with <code>nullptr</code>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__functors_ga544d74b2d5d0dd2197f5fd6f02691de0_cgraph.png" border="0" usemap="#agroup__functors_ga544d74b2d5d0dd2197f5fd6f02691de0_cgraph" alt=""/></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
